<paragraph></paragraph>
Why C++ for LASI?<paragraph></paragraph>
<paragraph></paragraph>
C++ combines the features necessary for designing and implementing this challenging application. It is Memory Efficient, CPU Efficient, and provides the essential flexibility in abstraction levels.<paragraph></paragraph>
<paragraph></paragraph>
A Multi-Paradigm programming language, C++ provides constructs which fully support Object-Oriented, Functional, and Procedural programming styles and allows them to be mixed flexibly such as to best fit the needs each situation.<paragraph></paragraph>
<paragraph></paragraph>
“[C++ is] a lightweight abstraction programming language.” <paragraph></paragraph>
<paragraph></paragraph>
Bjarne Stroustrup, the creator of C++<paragraph></paragraph>
<paragraph></paragraph>
Although Stroustrup says that the above description of his language is poor marketing speak, it perfectly captures why C++ is the ideal language for LASI.<paragraph></paragraph>
<paragraph></paragraph>
The new features, defined in the C++ 11 standard, are particularly helpful in this particular area. Of particular note are anonymous functions (aka lambdas) and their accompanying closures which allow for type-safe yet flexible interfaces between program components. For example, a function which computes the weight of some potential word relationship may require information to be passed to it which would, if passed as a parameter, be incompatible with the function which it is passed to. Closure solves this problem beautifully and simple without sacrificing the benefits of static type checking and rigid interfaces.<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
-85725029527500Consider the following code:<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
The WeightSVORelationship function is declared as taking a single function parameter. When itis called in the CallWordScore function, it is passed a lambda closure which makes use of 3 vectors of words which are defined inside the scope of CallWordScore.If these vectors were passed as arguments to thelambda, its signature would not match the parameter signature of WeightSVORelationship because that function expects that its Func parameter “scorer”will have a signature which takes 3 words and returns a WordScore.<paragraph></paragraph>
<paragraph></paragraph>
More importantly, the closure property allows them to beWeightSVORelationship to call a function which makes use of three vectors which it doesn’t have access to because those vectors are captured in the lambda closure it is passed.<paragraph></paragraph>
<paragraph></paragraph>
Because Func is a template parameter of WeightSVORelationship, the latter may receive any callable type, so long as it takes 3 words and returns a WordScore,in its actual argument list. These callable types include,functions, function pointers, functors (an object which overloads the operator‘()’), and lambdas as used above.<paragraph></paragraph>
<paragraph></paragraph>
As a result, weight SVO relationship is defined as a type-safe, yet highly flexible functionby taking advantage of the powerful C++ constructs of lambdas closuresand templates.<paragraph></paragraph>
<paragraph></paragraph>
<paragraph></paragraph>
