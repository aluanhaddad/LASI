"bundle";
System.registerDynamic("github:dougludlow/plugin-sass@0.6.0.json", [], true, function() {
  return {
    "main": "index.js"
  };
});

System.registerDynamic("github:twbs/bootstrap@3.3.7.json", [], true, function() {
  return {
    "main": "dist/js/bootstrap.js",
    "meta": {
      "dist/js/bootstrap.js": {
        "deps": [
          "jquery"
        ],
        "exports": "$"
      }
    }
  };
});

System.registerDynamic('github:twbs/bootstrap@3.3.7/dist/js/bootstrap.js', ['jquery'], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = System.registry.get("@@global-helpers").prepareGlobal($__module.id, '$', null);

  (function ($__global) {
    /*!
     * Bootstrap v3.3.7 (http://getbootstrap.com)
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under the MIT license
     */

    if (typeof jQuery === 'undefined') {
      throw new Error('Bootstrap\'s JavaScript requires jQuery');
    }

    +function ($) {
      'use strict';

      var version = $.fn.jquery.split(' ')[0].split('.');
      if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 3) {
        throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4');
      }
    }(jQuery);

    /* ========================================================================
     * Bootstrap: transition.js v3.3.7
     * http://getbootstrap.com/javascript/#transitions
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
      // ============================================================

      function transitionEnd() {
        var el = document.createElement('bootstrap');

        var transEndEventNames = {
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          OTransition: 'oTransitionEnd otransitionend',
          transition: 'transitionend'
        };

        for (var name in transEndEventNames) {
          if (el.style[name] !== undefined) {
            return { end: transEndEventNames[name] };
          }
        }

        return false; // explicit for ie8 (  ._.)
      }

      // http://blog.alexmaccaw.com/css-transitions
      $.fn.emulateTransitionEnd = function (duration) {
        var called = false;
        var $el = this;
        $(this).one('bsTransitionEnd', function () {
          called = true;
        });
        var callback = function () {
          if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
      };

      $(function () {
        $.support.transition = transitionEnd();

        if (!$.support.transition) return;

        $.event.special.bsTransitionEnd = {
          bindType: $.support.transition.end,
          delegateType: $.support.transition.end,
          handle: function (e) {
            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
          }
        };
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: alert.js v3.3.7
     * http://getbootstrap.com/javascript/#alerts
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // ALERT CLASS DEFINITION
      // ======================

      var dismiss = '[data-dismiss="alert"]';
      var Alert = function (el) {
        $(el).on('click', dismiss, this.close);
      };

      Alert.VERSION = '3.3.7';

      Alert.TRANSITION_DURATION = 150;

      Alert.prototype.close = function (e) {
        var $this = $(this);
        var selector = $this.attr('data-target');

        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
        }

        var $parent = $(selector === '#' ? [] : selector);

        if (e) e.preventDefault();

        if (!$parent.length) {
          $parent = $this.closest('.alert');
        }

        $parent.trigger(e = $.Event('close.bs.alert'));

        if (e.isDefaultPrevented()) return;

        $parent.removeClass('in');

        function removeElement() {
          // detach from parent, fire event then clean up data
          $parent.detach().trigger('closed.bs.alert').remove();
        }

        $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
      };

      // ALERT PLUGIN DEFINITION
      // =======================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.alert');

          if (!data) $this.data('bs.alert', data = new Alert(this));
          if (typeof option == 'string') data[option].call($this);
        });
      }

      var old = $.fn.alert;

      $.fn.alert = Plugin;
      $.fn.alert.Constructor = Alert;

      // ALERT NO CONFLICT
      // =================

      $.fn.alert.noConflict = function () {
        $.fn.alert = old;
        return this;
      };

      // ALERT DATA-API
      // ==============

      $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
    }(jQuery);

    /* ========================================================================
     * Bootstrap: button.js v3.3.7
     * http://getbootstrap.com/javascript/#buttons
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // BUTTON PUBLIC CLASS DEFINITION
      // ==============================

      var Button = function (element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
      };

      Button.VERSION = '3.3.7';

      Button.DEFAULTS = {
        loadingText: 'loading...'
      };

      Button.prototype.setState = function (state) {
        var d = 'disabled';
        var $el = this.$element;
        var val = $el.is('input') ? 'val' : 'html';
        var data = $el.data();

        state += 'Text';

        if (data.resetText == null) $el.data('resetText', $el[val]());

        // push to event loop to allow forms to submit
        setTimeout($.proxy(function () {
          $el[val](data[state] == null ? this.options[state] : data[state]);

          if (state == 'loadingText') {
            this.isLoading = true;
            $el.addClass(d).attr(d, d).prop(d, true);
          } else if (this.isLoading) {
            this.isLoading = false;
            $el.removeClass(d).removeAttr(d).prop(d, false);
          }
        }, this), 0);
      };

      Button.prototype.toggle = function () {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');

        if ($parent.length) {
          var $input = this.$element.find('input');
          if ($input.prop('type') == 'radio') {
            if ($input.prop('checked')) changed = false;
            $parent.find('.active').removeClass('active');
            this.$element.addClass('active');
          } else if ($input.prop('type') == 'checkbox') {
            if ($input.prop('checked') !== this.$element.hasClass('active')) changed = false;
            this.$element.toggleClass('active');
          }
          $input.prop('checked', this.$element.hasClass('active'));
          if (changed) $input.trigger('change');
        } else {
          this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
          this.$element.toggleClass('active');
        }
      };

      // BUTTON PLUGIN DEFINITION
      // ========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.button');
          var options = typeof option == 'object' && option;

          if (!data) $this.data('bs.button', data = new Button(this, options));

          if (option == 'toggle') data.toggle();else if (option) data.setState(option);
        });
      }

      var old = $.fn.button;

      $.fn.button = Plugin;
      $.fn.button.Constructor = Button;

      // BUTTON NO CONFLICT
      // ==================

      $.fn.button.noConflict = function () {
        $.fn.button = old;
        return this;
      };

      // BUTTON DATA-API
      // ===============

      $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
        var $btn = $(e.target).closest('.btn');
        Plugin.call($btn, 'toggle');
        if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
          // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
          e.preventDefault();
          // The target component still receive the focus
          if ($btn.is('input,button')) $btn.trigger('focus');else $btn.find('input:visible,button:visible').first().trigger('focus');
        }
      }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
        $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: carousel.js v3.3.7
     * http://getbootstrap.com/javascript/#carousel
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // CAROUSEL CLASS DEFINITION
      // =========================

      var Carousel = function (element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find('.carousel-indicators');
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;

        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));

        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
      };

      Carousel.VERSION = '3.3.7';

      Carousel.TRANSITION_DURATION = 600;

      Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true,
        keyboard: true
      };

      Carousel.prototype.keydown = function (e) {
        if (/input|textarea/i.test(e.target.tagName)) return;
        switch (e.which) {
          case 37:
            this.prev();break;
          case 39:
            this.next();break;
          default:
            return;
        }

        e.preventDefault();
      };

      Carousel.prototype.cycle = function (e) {
        e || (this.paused = false);

        this.interval && clearInterval(this.interval);

        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));

        return this;
      };

      Carousel.prototype.getItemIndex = function (item) {
        this.$items = item.parent().children('.item');
        return this.$items.index(item || this.$active);
      };

      Carousel.prototype.getItemForDirection = function (direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = direction == 'prev' && activeIndex === 0 || direction == 'next' && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap) return active;
        var delta = direction == 'prev' ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
      };

      Carousel.prototype.to = function (pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));

        if (pos > this.$items.length - 1 || pos < 0) return;

        if (this.sliding) return this.$element.one('slid.bs.carousel', function () {
          that.to(pos);
        }); // yes, "slid"
        if (activeIndex == pos) return this.pause().cycle();

        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
      };

      Carousel.prototype.pause = function (e) {
        e || (this.paused = true);

        if (this.$element.find('.next, .prev').length && $.support.transition) {
          this.$element.trigger($.support.transition.end);
          this.cycle(true);
        }

        this.interval = clearInterval(this.interval);

        return this;
      };

      Carousel.prototype.next = function () {
        if (this.sliding) return;
        return this.slide('next');
      };

      Carousel.prototype.prev = function () {
        if (this.sliding) return;
        return this.slide('prev');
      };

      Carousel.prototype.slide = function (type, next) {
        var $active = this.$element.find('.item.active');
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == 'next' ? 'left' : 'right';
        var that = this;

        if ($next.hasClass('active')) return this.sliding = false;

        var relatedTarget = $next[0];
        var slideEvent = $.Event('slide.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented()) return;

        this.sliding = true;

        isCycling && this.pause();

        if (this.$indicators.length) {
          this.$indicators.find('.active').removeClass('active');
          var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
          $nextIndicator && $nextIndicator.addClass('active');
        }

        var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }); // yes, "slid"
        if ($.support.transition && this.$element.hasClass('slide')) {
          $next.addClass(type);
          $next[0].offsetWidth; // force reflow
          $active.addClass(direction);
          $next.addClass(direction);
          $active.one('bsTransitionEnd', function () {
            $next.removeClass([type, direction].join(' ')).addClass('active');
            $active.removeClass(['active', direction].join(' '));
            that.sliding = false;
            setTimeout(function () {
              that.$element.trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
          $active.removeClass('active');
          $next.addClass('active');
          this.sliding = false;
          this.$element.trigger(slidEvent);
        }

        isCycling && this.cycle();

        return this;
      };

      // CAROUSEL PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.carousel');
          var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option);
          var action = typeof option == 'string' ? option : options.slide;

          if (!data) $this.data('bs.carousel', data = new Carousel(this, options));
          if (typeof option == 'number') data.to(option);else if (action) data[action]();else if (options.interval) data.pause().cycle();
        });
      }

      var old = $.fn.carousel;

      $.fn.carousel = Plugin;
      $.fn.carousel.Constructor = Carousel;

      // CAROUSEL NO CONFLICT
      // ====================

      $.fn.carousel.noConflict = function () {
        $.fn.carousel = old;
        return this;
      };

      // CAROUSEL DATA-API
      // =================

      var clickHandler = function (e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
        if (!$target.hasClass('carousel')) return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr('data-slide-to');
        if (slideIndex) options.interval = false;

        Plugin.call($target, options);

        if (slideIndex) {
          $target.data('bs.carousel').to(slideIndex);
        }

        e.preventDefault();
      };

      $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);

      $(window).on('load', function () {
        $('[data-ride="carousel"]').each(function () {
          var $carousel = $(this);
          Plugin.call($carousel, $carousel.data());
        });
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: collapse.js v3.3.7
     * http://getbootstrap.com/javascript/#collapse
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    /* jshint latedef: false */

    +function ($) {
      'use strict';

      // COLLAPSE PUBLIC CLASS DEFINITION
      // ================================

      var Collapse = function (element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;

        if (this.options.parent) {
          this.$parent = this.getParent();
        } else {
          this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }

        if (this.options.toggle) this.toggle();
      };

      Collapse.VERSION = '3.3.7';

      Collapse.TRANSITION_DURATION = 350;

      Collapse.DEFAULTS = {
        toggle: true
      };

      Collapse.prototype.dimension = function () {
        var hasWidth = this.$element.hasClass('width');
        return hasWidth ? 'width' : 'height';
      };

      Collapse.prototype.show = function () {
        if (this.transitioning || this.$element.hasClass('in')) return;

        var activesData;
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');

        if (actives && actives.length) {
          activesData = actives.data('bs.collapse');
          if (activesData && activesData.transitioning) return;
        }

        var startEvent = $.Event('show.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;

        if (actives && actives.length) {
          Plugin.call(actives, 'hide');
          activesData || actives.data('bs.collapse', null);
        }

        var dimension = this.dimension();

        this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);

        this.$trigger.removeClass('collapsed').attr('aria-expanded', true);

        this.transitioning = 1;

        var complete = function () {
          this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
          this.transitioning = 0;
          this.$element.trigger('shown.bs.collapse');
        };

        if (!$.support.transition) return complete.call(this);

        var scrollSize = $.camelCase(['scroll', dimension].join('-'));

        this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
      };

      Collapse.prototype.hide = function () {
        if (this.transitioning || !this.$element.hasClass('in')) return;

        var startEvent = $.Event('hide.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;

        var dimension = this.dimension();

        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;

        this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);

        this.$trigger.addClass('collapsed').attr('aria-expanded', false);

        this.transitioning = 1;

        var complete = function () {
          this.transitioning = 0;
          this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
        };

        if (!$.support.transition) return complete.call(this);

        this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
      };

      Collapse.prototype.toggle = function () {
        this[this.$element.hasClass('in') ? 'hide' : 'show']();
      };

      Collapse.prototype.getParent = function () {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) {
          var $element = $(element);
          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
      };

      Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
        var isOpen = $element.hasClass('in');

        $element.attr('aria-expanded', isOpen);
        $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
      };

      function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

        return $(target);
      }

      // COLLAPSE PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.collapse');
          var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option);

          if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
          if (!data) $this.data('bs.collapse', data = new Collapse(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.collapse;

      $.fn.collapse = Plugin;
      $.fn.collapse.Constructor = Collapse;

      // COLLAPSE NO CONFLICT
      // ====================

      $.fn.collapse.noConflict = function () {
        $.fn.collapse = old;
        return this;
      };

      // COLLAPSE DATA-API
      // =================

      $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
        var $this = $(this);

        if (!$this.attr('data-target')) e.preventDefault();

        var $target = getTargetFromTrigger($this);
        var data = $target.data('bs.collapse');
        var option = data ? 'toggle' : $this.data();

        Plugin.call($target, option);
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: dropdown.js v3.3.7
     * http://getbootstrap.com/javascript/#dropdowns
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // DROPDOWN CLASS DEFINITION
      // =========================

      var backdrop = '.dropdown-backdrop';
      var toggle = '[data-toggle="dropdown"]';
      var Dropdown = function (element) {
        $(element).on('click.bs.dropdown', this.toggle);
      };

      Dropdown.VERSION = '3.3.7';

      function getParent($this) {
        var selector = $this.attr('data-target');

        if (!selector) {
          selector = $this.attr('href');
          selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
        }

        var $parent = selector && $(selector);

        return $parent && $parent.length ? $parent : $this.parent();
      }

      function clearMenus(e) {
        if (e && e.which === 3) return;
        $(backdrop).remove();
        $(toggle).each(function () {
          var $this = $(this);
          var $parent = getParent($this);
          var relatedTarget = { relatedTarget: this };

          if (!$parent.hasClass('open')) return;

          if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;

          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));

          if (e.isDefaultPrevented()) return;

          $this.attr('aria-expanded', 'false');
          $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));
        });
      }

      Dropdown.prototype.toggle = function (e) {
        var $this = $(this);

        if ($this.is('.disabled, :disabled')) return;

        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');

        clearMenus();

        if (!isActive) {
          if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
            // if mobile we use a backdrop because click events don't delegate
            $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);
          }

          var relatedTarget = { relatedTarget: this };
          $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));

          if (e.isDefaultPrevented()) return;

          $this.trigger('focus').attr('aria-expanded', 'true');

          $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));
        }

        return false;
      };

      Dropdown.prototype.keydown = function (e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;

        var $this = $(this);

        e.preventDefault();
        e.stopPropagation();

        if ($this.is('.disabled, :disabled')) return;

        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');

        if (!isActive && e.which != 27 || isActive && e.which == 27) {
          if (e.which == 27) $parent.find(toggle).trigger('focus');
          return $this.trigger('click');
        }

        var desc = ' li:not(.disabled):visible a';
        var $items = $parent.find('.dropdown-menu' + desc);

        if (!$items.length) return;

        var index = $items.index(e.target);

        if (e.which == 38 && index > 0) index--; // up
        if (e.which == 40 && index < $items.length - 1) index++; // down
        if (!~index) index = 0;

        $items.eq(index).trigger('focus');
      };

      // DROPDOWN PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.dropdown');

          if (!data) $this.data('bs.dropdown', data = new Dropdown(this));
          if (typeof option == 'string') data[option].call($this);
        });
      }

      var old = $.fn.dropdown;

      $.fn.dropdown = Plugin;
      $.fn.dropdown.Constructor = Dropdown;

      // DROPDOWN NO CONFLICT
      // ====================

      $.fn.dropdown.noConflict = function () {
        $.fn.dropdown = old;
        return this;
      };

      // APPLY TO STANDARD DROPDOWN ELEMENTS
      // ===================================

      $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {
        e.stopPropagation();
      }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);
    }(jQuery);

    /* ========================================================================
     * Bootstrap: modal.js v3.3.7
     * http://getbootstrap.com/javascript/#modals
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // MODAL CLASS DEFINITION
      // ======================

      var Modal = function (element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find('.modal-dialog');
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;

        if (this.options.remote) {
          this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
            this.$element.trigger('loaded.bs.modal');
          }, this));
        }
      };

      Modal.VERSION = '3.3.7';

      Modal.TRANSITION_DURATION = 300;
      Modal.BACKDROP_TRANSITION_DURATION = 150;

      Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
      };

      Modal.prototype.toggle = function (_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
      };

      Modal.prototype.show = function (_relatedTarget) {
        var that = this;
        var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget });

        this.$element.trigger(e);

        if (this.isShown || e.isDefaultPrevented()) return;

        this.isShown = true;

        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass('modal-open');

        this.escape();
        this.resize();

        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));

        this.$dialog.on('mousedown.dismiss.bs.modal', function () {
          that.$element.one('mouseup.dismiss.bs.modal', function (e) {
            if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
          });
        });

        this.backdrop(function () {
          var transition = $.support.transition && that.$element.hasClass('fade');

          if (!that.$element.parent().length) {
            that.$element.appendTo(that.$body); // don't move modals dom position
          }

          that.$element.show().scrollTop(0);

          that.adjustDialog();

          if (transition) {
            that.$element[0].offsetWidth; // force reflow
          }

          that.$element.addClass('in');

          that.enforceFocus();

          var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });

          transition ? that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e);
          }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
        });
      };

      Modal.prototype.hide = function (e) {
        if (e) e.preventDefault();

        e = $.Event('hide.bs.modal');

        this.$element.trigger(e);

        if (!this.isShown || e.isDefaultPrevented()) return;

        this.isShown = false;

        this.escape();
        this.resize();

        $(document).off('focusin.bs.modal');

        this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');

        this.$dialog.off('mousedown.dismiss.bs.modal');

        $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
      };

      Modal.prototype.enforceFocus = function () {
        $(document).off('focusin.bs.modal') // guard against infinite focus loop
        .on('focusin.bs.modal', $.proxy(function (e) {
          if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
            this.$element.trigger('focus');
          }
        }, this));
      };

      Modal.prototype.escape = function () {
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
            e.which == 27 && this.hide();
          }, this));
        } else if (!this.isShown) {
          this.$element.off('keydown.dismiss.bs.modal');
        }
      };

      Modal.prototype.resize = function () {
        if (this.isShown) {
          $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
        } else {
          $(window).off('resize.bs.modal');
        }
      };

      Modal.prototype.hideModal = function () {
        var that = this;
        this.$element.hide();
        this.backdrop(function () {
          that.$body.removeClass('modal-open');
          that.resetAdjustments();
          that.resetScrollbar();
          that.$element.trigger('hidden.bs.modal');
        });
      };

      Modal.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
      };

      Modal.prototype.backdrop = function (callback) {
        var that = this;
        var animate = this.$element.hasClass('fade') ? 'fade' : '';

        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate;

          this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);

          this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
            if (this.ignoreBackdropClick) {
              this.ignoreBackdropClick = false;
              return;
            }
            if (e.target !== e.currentTarget) return;
            this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
          }, this));

          if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

          this.$backdrop.addClass('in');

          if (!callback) return;

          doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in');

          var callbackRemove = function () {
            that.removeBackdrop();
            callback && callback();
          };
          $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
          callback();
        }
      };

      // these following methods are used to handle overflowing modals

      Modal.prototype.handleUpdate = function () {
        this.adjustDialog();
      };

      Modal.prototype.adjustDialog = function () {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;

        this.$element.css({
          paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
          paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
        });
      };

      Modal.prototype.resetAdjustments = function () {
        this.$element.css({
          paddingLeft: '',
          paddingRight: ''
        });
      };

      Modal.prototype.checkScrollbar = function () {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
          // workaround for missing window.innerWidth in IE8
          var documentElementRect = document.documentElement.getBoundingClientRect();
          fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
      };

      Modal.prototype.setScrollbar = function () {
        var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || '';
        if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
      };

      Modal.prototype.resetScrollbar = function () {
        this.$body.css('padding-right', this.originalBodyPad);
      };

      Modal.prototype.measureScrollbar = function () {
        // thx walsh
        var scrollDiv = document.createElement('div');
        scrollDiv.className = 'modal-scrollbar-measure';
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
      };

      // MODAL PLUGIN DEFINITION
      // =======================

      function Plugin(option, _relatedTarget) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.modal');
          var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);

          if (!data) $this.data('bs.modal', data = new Modal(this, options));
          if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
        });
      }

      var old = $.fn.modal;

      $.fn.modal = Plugin;
      $.fn.modal.Constructor = Modal;

      // MODAL NO CONFLICT
      // =================

      $.fn.modal.noConflict = function () {
        $.fn.modal = old;
        return this;
      };

      // MODAL DATA-API
      // ==============

      $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
        var $this = $(this);
        var href = $this.attr('href');
        var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
        var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());

        if ($this.is('a')) e.preventDefault();

        $target.one('show.bs.modal', function (showEvent) {
          if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown
          $target.one('hidden.bs.modal', function () {
            $this.is(':visible') && $this.trigger('focus');
          });
        });
        Plugin.call($target, option, this);
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: tooltip.js v3.3.7
     * http://getbootstrap.com/javascript/#tooltip
     * Inspired by the original jQuery.tipsy by Jason Frame
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // TOOLTIP PUBLIC CLASS DEFINITION
      // ===============================

      var Tooltip = function (element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;

        this.init('tooltip', element, options);
      };

      Tooltip.VERSION = '3.3.7';

      Tooltip.TRANSITION_DURATION = 150;

      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      };

      Tooltip.prototype.init = function (type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
        this.inState = { click: false, hover: false, focus: false };

        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
          throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
        }

        var triggers = this.options.trigger.split(' ');

        for (var i = triggers.length; i--;) {
          var trigger = triggers[i];

          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
          } else if (trigger != 'manual') {
            var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';

            this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
          }
        }

        this.options.selector ? this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' }) : this.fixTitle();
      };

      Tooltip.prototype.getDefaults = function () {
        return Tooltip.DEFAULTS;
      };

      Tooltip.prototype.getOptions = function (options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);

        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          };
        }

        return options;
      };

      Tooltip.prototype.getDelegateOptions = function () {
        var options = {};
        var defaults = this.getDefaults();

        this._options && $.each(this._options, function (key, value) {
          if (defaults[key] != value) options[key] = value;
        });

        return options;
      };

      Tooltip.prototype.enter = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;
        }

        if (self.tip().hasClass('in') || self.hoverState == 'in') {
          self.hoverState = 'in';
          return;
        }

        clearTimeout(self.timeout);

        self.hoverState = 'in';

        if (!self.options.delay || !self.options.delay.show) return self.show();

        self.timeout = setTimeout(function () {
          if (self.hoverState == 'in') self.show();
        }, self.options.delay.show);
      };

      Tooltip.prototype.isInStateTrue = function () {
        for (var key in this.inState) {
          if (this.inState[key]) return true;
        }

        return false;
      };

      Tooltip.prototype.leave = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;
        }

        if (self.isInStateTrue()) return;

        clearTimeout(self.timeout);

        self.hoverState = 'out';

        if (!self.options.delay || !self.options.delay.hide) return self.hide();

        self.timeout = setTimeout(function () {
          if (self.hoverState == 'out') self.hide();
        }, self.options.delay.hide);
      };

      Tooltip.prototype.show = function () {
        var e = $.Event('show.bs.' + this.type);

        if (this.hasContent() && this.enabled) {
          this.$element.trigger(e);

          var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
          if (e.isDefaultPrevented() || !inDom) return;
          var that = this;

          var $tip = this.tip();

          var tipId = this.getUID(this.type);

          this.setContent();
          $tip.attr('id', tipId);
          this.$element.attr('aria-describedby', tipId);

          if (this.options.animation) $tip.addClass('fade');

          var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;

          var autoToken = /\s?auto?\s?/i;
          var autoPlace = autoToken.test(placement);
          if (autoPlace) placement = placement.replace(autoToken, '') || 'top';

          $tip.detach().css({ top: 0, left: 0, display: 'block' }).addClass(placement).data('bs.' + this.type, this);

          this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
          this.$element.trigger('inserted.bs.' + this.type);

          var pos = this.getPosition();
          var actualWidth = $tip[0].offsetWidth;
          var actualHeight = $tip[0].offsetHeight;

          if (autoPlace) {
            var orgPlacement = placement;
            var viewportDim = this.getPosition(this.$viewport);

            placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;

            $tip.removeClass(orgPlacement).addClass(placement);
          }

          var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);

          this.applyPlacement(calculatedOffset, placement);

          var complete = function () {
            var prevHoverState = that.hoverState;
            that.$element.trigger('shown.bs.' + that.type);
            that.hoverState = null;

            if (prevHoverState == 'out') that.leave(that);
          };

          $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
      };

      Tooltip.prototype.applyPlacement = function (offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;

        // manually read margins because getBoundingClientRect includes difference
        var marginTop = parseInt($tip.css('margin-top'), 10);
        var marginLeft = parseInt($tip.css('margin-left'), 10);

        // we must check for NaN for ie 8/9
        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;

        offset.top += marginTop;
        offset.left += marginLeft;

        // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0
        $.offset.setOffset($tip[0], $.extend({
          using: function (props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            });
          }
        }, offset), 0);

        $tip.addClass('in');

        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;

        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight;
        }

        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);

        if (delta.left) offset.left += delta.left;else offset.top += delta.top;

        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';

        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
      };

      Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
        this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
      };

      Tooltip.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();

        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
        $tip.removeClass('fade in top bottom left right');
      };

      Tooltip.prototype.hide = function (callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event('hide.bs.' + this.type);

        function complete() {
          if (that.hoverState != 'in') $tip.detach();
          if (that.$element) {
            // TODO: Check whether guarding this code with this `if` is really necessary.
            that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
          }
          callback && callback();
        }

        this.$element.trigger(e);

        if (e.isDefaultPrevented()) return;

        $tip.removeClass('in');

        $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();

        this.hoverState = null;

        return this;
      };

      Tooltip.prototype.fixTitle = function () {
        var $e = this.$element;
        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
        }
      };

      Tooltip.prototype.hasContent = function () {
        return this.getTitle();
      };

      Tooltip.prototype.getPosition = function ($element) {
        $element = $element || this.$element;

        var el = $element[0];
        var isBody = el.tagName == 'BODY';

        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
          // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
          elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });
        }
        var isSvg = window.SVGElement && el instanceof window.SVGElement;
        // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
        // See https://github.com/twbs/bootstrap/issues/20280
        var elOffset = isBody ? { top: 0, left: 0 } : isSvg ? null : $element.offset();
        var scroll = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() };
        var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null;

        return $.extend({}, elRect, scroll, outerDims, elOffset);
      };

      Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? { top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'top' ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'left' ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */{ top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width };
      };

      Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
        var delta = { top: 0, left: 0 };
        if (!this.$viewport) return delta;

        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);

        if (/right|left/.test(placement)) {
          var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
          if (topEdgeOffset < viewportDimensions.top) {
            // top overflow
            delta.top = viewportDimensions.top - topEdgeOffset;
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
            // bottom overflow
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
          }
        } else {
          var leftEdgeOffset = pos.left - viewportPadding;
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
          if (leftEdgeOffset < viewportDimensions.left) {
            // left overflow
            delta.left = viewportDimensions.left - leftEdgeOffset;
          } else if (rightEdgeOffset > viewportDimensions.right) {
            // right overflow
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
          }
        }

        return delta;
      };

      Tooltip.prototype.getTitle = function () {
        var title;
        var $e = this.$element;
        var o = this.options;

        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);

        return title;
      };

      Tooltip.prototype.getUID = function (prefix) {
        do prefix += ~~(Math.random() * 1000000); while (document.getElementById(prefix));
        return prefix;
      };

      Tooltip.prototype.tip = function () {
        if (!this.$tip) {
          this.$tip = $(this.options.template);
          if (this.$tip.length != 1) {
            throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');
          }
        }
        return this.$tip;
      };

      Tooltip.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
      };

      Tooltip.prototype.enable = function () {
        this.enabled = true;
      };

      Tooltip.prototype.disable = function () {
        this.enabled = false;
      };

      Tooltip.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled;
      };

      Tooltip.prototype.toggle = function (e) {
        var self = this;
        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type);
          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions());
            $(e.currentTarget).data('bs.' + this.type, self);
          }
        }

        if (e) {
          self.inState.click = !self.inState.click;
          if (self.isInStateTrue()) self.enter(self);else self.leave(self);
        } else {
          self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
        }
      };

      Tooltip.prototype.destroy = function () {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function () {
          that.$element.off('.' + that.type).removeData('bs.' + that.type);
          if (that.$tip) {
            that.$tip.detach();
          }
          that.$tip = null;
          that.$arrow = null;
          that.$viewport = null;
          that.$element = null;
        });
      };

      // TOOLTIP PLUGIN DEFINITION
      // =========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.tooltip');
          var options = typeof option == 'object' && option;

          if (!data && /destroy|hide/.test(option)) return;
          if (!data) $this.data('bs.tooltip', data = new Tooltip(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.tooltip;

      $.fn.tooltip = Plugin;
      $.fn.tooltip.Constructor = Tooltip;

      // TOOLTIP NO CONFLICT
      // ===================

      $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old;
        return this;
      };
    }(jQuery);

    /* ========================================================================
     * Bootstrap: popover.js v3.3.7
     * http://getbootstrap.com/javascript/#popovers
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // POPOVER PUBLIC CLASS DEFINITION
      // ===============================

      var Popover = function (element, options) {
        this.init('popover', element, options);
      };

      if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');

      Popover.VERSION = '3.3.7';

      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      });

      // NOTE: POPOVER EXTENDS tooltip.js
      // ================================

      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);

      Popover.prototype.constructor = Popover;

      Popover.prototype.getDefaults = function () {
        return Popover.DEFAULTS;
      };

      Popover.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();

        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
        $tip.find('.popover-content').children().detach().end()[// we use append for html objects to maintain js events
        this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);

        $tip.removeClass('fade top bottom left right in');

        // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();
      };

      Popover.prototype.hasContent = function () {
        return this.getTitle() || this.getContent();
      };

      Popover.prototype.getContent = function () {
        var $e = this.$element;
        var o = this.options;

        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
      };

      Popover.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.arrow');
      };

      // POPOVER PLUGIN DEFINITION
      // =========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.popover');
          var options = typeof option == 'object' && option;

          if (!data && /destroy|hide/.test(option)) return;
          if (!data) $this.data('bs.popover', data = new Popover(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.popover;

      $.fn.popover = Plugin;
      $.fn.popover.Constructor = Popover;

      // POPOVER NO CONFLICT
      // ===================

      $.fn.popover.noConflict = function () {
        $.fn.popover = old;
        return this;
      };
    }(jQuery);

    /* ========================================================================
     * Bootstrap: scrollspy.js v3.3.7
     * http://getbootstrap.com/javascript/#scrollspy
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // SCROLLSPY CLASS DEFINITION
      // ==========================

      function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || '') + ' .nav li > a';
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;

        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
        this.refresh();
        this.process();
      }

      ScrollSpy.VERSION = '3.3.7';

      ScrollSpy.DEFAULTS = {
        offset: 10
      };

      ScrollSpy.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
      };

      ScrollSpy.prototype.refresh = function () {
        var that = this;
        var offsetMethod = 'offset';
        var offsetBase = 0;

        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();

        if (!$.isWindow(this.$scrollElement[0])) {
          offsetMethod = 'position';
          offsetBase = this.$scrollElement.scrollTop();
        }

        this.$body.find(this.selector).map(function () {
          var $el = $(this);
          var href = $el.data('target') || $el.attr('href');
          var $href = /^#./.test(href) && $(href);

          return $href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]] || null;
        }).sort(function (a, b) {
          return a[0] - b[0];
        }).each(function () {
          that.offsets.push(this[0]);
          that.targets.push(this[1]);
        });
      };

      ScrollSpy.prototype.process = function () {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;

        if (this.scrollHeight != scrollHeight) {
          this.refresh();
        }

        if (scrollTop >= maxScroll) {
          return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }

        if (activeTarget && scrollTop < offsets[0]) {
          this.activeTarget = null;
          return this.clear();
        }

        for (i = offsets.length; i--;) {
          activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
      };

      ScrollSpy.prototype.activate = function (target) {
        this.activeTarget = target;

        this.clear();

        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';

        var active = $(selector).parents('li').addClass('active');

        if (active.parent('.dropdown-menu').length) {
          active = active.closest('li.dropdown').addClass('active');
        }

        active.trigger('activate.bs.scrollspy');
      };

      ScrollSpy.prototype.clear = function () {
        $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
      };

      // SCROLLSPY PLUGIN DEFINITION
      // ===========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.scrollspy');
          var options = typeof option == 'object' && option;

          if (!data) $this.data('bs.scrollspy', data = new ScrollSpy(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.scrollspy;

      $.fn.scrollspy = Plugin;
      $.fn.scrollspy.Constructor = ScrollSpy;

      // SCROLLSPY NO CONFLICT
      // =====================

      $.fn.scrollspy.noConflict = function () {
        $.fn.scrollspy = old;
        return this;
      };

      // SCROLLSPY DATA-API
      // ==================

      $(window).on('load.bs.scrollspy.data-api', function () {
        $('[data-spy="scroll"]').each(function () {
          var $spy = $(this);
          Plugin.call($spy, $spy.data());
        });
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: tab.js v3.3.7
     * http://getbootstrap.com/javascript/#tabs
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // TAB CLASS DEFINITION
      // ====================

      var Tab = function (element) {
        // jscs:disable requireDollarBeforejQueryAssignment
        this.element = $(element);
        // jscs:enable requireDollarBeforejQueryAssignment
      };

      Tab.VERSION = '3.3.7';

      Tab.TRANSITION_DURATION = 150;

      Tab.prototype.show = function () {
        var $this = this.element;
        var $ul = $this.closest('ul:not(.dropdown-menu)');
        var selector = $this.data('target');

        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
        }

        if ($this.parent('li').hasClass('active')) return;

        var $previous = $ul.find('.active:last a');
        var hideEvent = $.Event('hide.bs.tab', {
          relatedTarget: $this[0]
        });
        var showEvent = $.Event('show.bs.tab', {
          relatedTarget: $previous[0]
        });

        $previous.trigger(hideEvent);
        $this.trigger(showEvent);

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;

        var $target = $(selector);

        this.activate($this.closest('li'), $ul);
        this.activate($target, $target.parent(), function () {
          $previous.trigger({
            type: 'hidden.bs.tab',
            relatedTarget: $this[0]
          });
          $this.trigger({
            type: 'shown.bs.tab',
            relatedTarget: $previous[0]
          });
        });
      };

      Tab.prototype.activate = function (element, container, callback) {
        var $active = container.find('> .active');
        var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);

        function next() {
          $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);

          element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);

          if (transition) {
            element[0].offsetWidth; // reflow for transition
            element.addClass('in');
          } else {
            element.removeClass('fade');
          }

          if (element.parent('.dropdown-menu').length) {
            element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
          }

          callback && callback();
        }

        $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();

        $active.removeClass('in');
      };

      // TAB PLUGIN DEFINITION
      // =====================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.tab');

          if (!data) $this.data('bs.tab', data = new Tab(this));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.tab;

      $.fn.tab = Plugin;
      $.fn.tab.Constructor = Tab;

      // TAB NO CONFLICT
      // ===============

      $.fn.tab.noConflict = function () {
        $.fn.tab = old;
        return this;
      };

      // TAB DATA-API
      // ============

      var clickHandler = function (e) {
        e.preventDefault();
        Plugin.call($(this), 'show');
      };

      $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
    }(jQuery);

    /* ========================================================================
     * Bootstrap: affix.js v3.3.7
     * http://getbootstrap.com/javascript/#affix
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // AFFIX CLASS DEFINITION
      // ======================

      var Affix = function (element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);

        this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));

        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;

        this.checkPosition();
      };

      Affix.VERSION = '3.3.7';

      Affix.RESET = 'affix affix-top affix-bottom';

      Affix.DEFAULTS = {
        offset: 0,
        target: window
      };

      Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();

        if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false;

        if (this.affixed == 'bottom') {
          if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : 'bottom';
          return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : 'bottom';
        }

        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;

        if (offsetTop != null && scrollTop <= offsetTop) return 'top';
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return 'bottom';

        return false;
      };

      Affix.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass('affix');
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
      };

      Affix.prototype.checkPositionWithEventLoop = function () {
        setTimeout($.proxy(this.checkPosition, this), 1);
      };

      Affix.prototype.checkPosition = function () {
        if (!this.$element.is(':visible')) return;

        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());

        if (typeof offset != 'object') offsetBottom = offsetTop = offset;
        if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element);

        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);

        if (this.affixed != affix) {
          if (this.unpin != null) this.$element.css('top', '');

          var affixType = 'affix' + (affix ? '-' + affix : '');
          var e = $.Event(affixType + '.bs.affix');

          this.$element.trigger(e);

          if (e.isDefaultPrevented()) return;

          this.affixed = affix;
          this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;

          this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
        }

        if (affix == 'bottom') {
          this.$element.offset({
            top: scrollHeight - height - offsetBottom
          });
        }
      };

      // AFFIX PLUGIN DEFINITION
      // =======================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.affix');
          var options = typeof option == 'object' && option;

          if (!data) $this.data('bs.affix', data = new Affix(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.affix;

      $.fn.affix = Plugin;
      $.fn.affix.Constructor = Affix;

      // AFFIX NO CONFLICT
      // =================

      $.fn.affix.noConflict = function () {
        $.fn.affix = old;
        return this;
      };

      // AFFIX DATA-API
      // ==============

      $(window).on('load', function () {
        $('[data-spy="affix"]').each(function () {
          var $spy = $(this);
          var data = $spy.data();

          data.offset = data.offset || {};

          if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
          if (data.offsetTop != null) data.offset.top = data.offsetTop;

          Plugin.call($spy, data);
        });
      });
    }(jQuery);
  })(this);

  return _retrieveGlobal();
});
System.registerDynamic("npm:jquery@2.2.4.json", [], true, function() {
  return {
    "main": "dist/jquery.js",
    "format": "amd",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

/*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */

(function (global, factory) {

	if (typeof module === "object" && typeof module.exports === "object") {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ? factory(global, true) : function (w) {
			if (!w.document) {
				throw new Error("jQuery requires a window with a document");
			}
			return factory(w);
		};
	} else {
		factory(global);
	}

	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};

	var version = "2.2.4",


	// Define a local copy of jQuery
	jQuery = function (selector, context) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init(selector, context);
	},


	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	    rdashAlpha = /-([\da-z])/gi,


	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
		return letter.toUpperCase();
	};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function () {
			return slice.call(this);
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function (num) {
			return num != null ?

			// Return just the one element from the set
			num < 0 ? this[num + this.length] : this[num] :

			// Return all the elements in a clean array
			slice.call(this);
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function (elems) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function (callback) {
			return jQuery.each(this, callback);
		},

		map: function (callback) {
			return this.pushStack(jQuery.map(this, function (elem, i) {
				return callback.call(elem, i, elem);
			}));
		},

		slice: function () {
			return this.pushStack(slice.apply(this, arguments));
		},

		first: function () {
			return this.eq(0);
		},

		last: function () {
			return this.eq(-1);
		},

		eq: function (i) {
			var len = this.length,
			    j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},

		end: function () {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options,
		    name,
		    src,
		    copy,
		    copyIsArray,
		    clone,
		    target = arguments[0] || {},
		    i = 1,
		    length = arguments.length,
		    deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !jQuery.isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {

			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {

				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {

						if (copyIsArray) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function (msg) {
			throw new Error(msg);
		},

		noop: function () {},

		isFunction: function (obj) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function (obj) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function (obj) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
		},

		isPlainObject: function (obj) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for (key in obj) {}

			return key === undefined || hasOwn.call(obj, key);
		},

		isEmptyObject: function (obj) {
			var name;
			for (name in obj) {
				return false;
			}
			return true;
		},

		type: function (obj) {
			if (obj == null) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function (code) {
			var script,
			    indirect = eval;

			code = jQuery.trim(code);

			if (code) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if (code.indexOf("use strict") === 1) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild(script).parentNode.removeChild(script);
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect(code);
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function (string) {
			return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
		},

		nodeName: function (elem, name) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function (obj, callback) {
			var length,
			    i = 0;

			if (isArrayLike(obj)) {
				length = obj.length;
				for (; i < length; i++) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function (text) {
			return text == null ? "" : (text + "").replace(rtrim, "");
		},

		// results is for internal usage only
		makeArray: function (arr, results) {
			var ret = results || [];

			if (arr != null) {
				if (isArrayLike(Object(arr))) {
					jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					push.call(ret, arr);
				}
			}

			return ret;
		},

		inArray: function (elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},

		merge: function (first, second) {
			var len = +second.length,
			    j = 0,
			    i = first.length;

			for (; j < len; j++) {
				first[i++] = second[j];
			}

			first.length = i;

			return first;
		},

		grep: function (elems, callback, invert) {
			var callbackInverse,
			    matches = [],
			    i = 0,
			    length = elems.length,
			    callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for (; i < length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function (elems, callback, arg) {
			var length,
			    value,
			    i = 0,
			    ret = [];

			// Go through the array, translating each of the items to their new values
			if (isArrayLike(elems)) {
				length = elems.length;
				for (; i < length; i++) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}

				// Go through every key on the object,
			} else {
				for (i in elems) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply([], ret);
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function (fn, context) {
			var tmp, args, proxy;

			if (typeof context === "string") {
				tmp = fn[context];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if (!jQuery.isFunction(fn)) {
				return undefined;
			}

			// Simulated bind
			args = slice.call(arguments, 2);
			proxy = function () {
				return fn.apply(context || this, args.concat(slice.call(arguments)));
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if (typeof Symbol === "function") {
		jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
		class2type["[object " + name + "]"] = name.toLowerCase();
	});

	function isArrayLike(obj) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
		    type = jQuery.type(obj);

		if (type === "function" || jQuery.isWindow(obj)) {
			return false;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	}
	var Sizzle =
	/*!
  * Sizzle CSS Selector Engine v2.2.1
  * http://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2015-10-17
  */
	function (window) {

		var i,
		    support,
		    Expr,
		    getText,
		    isXML,
		    tokenize,
		    compile,
		    select,
		    outermostContext,
		    sortInput,
		    hasDuplicate,


		// Local document vars
		setDocument,
		    document,
		    docElem,
		    documentIsHTML,
		    rbuggyQSA,
		    rbuggyMatches,
		    matches,
		    contains,


		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		    preferredDoc = window.document,
		    dirruns = 0,
		    done = 0,
		    classCache = createCache(),
		    tokenCache = createCache(),
		    compilerCache = createCache(),
		    sortOrder = function (a, b) {
			if (a === b) {
				hasDuplicate = true;
			}
			return 0;
		},


		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,


		// Instance methods
		hasOwn = {}.hasOwnProperty,
		    arr = [],
		    pop = arr.pop,
		    push_native = arr.push,
		    push = arr.push,
		    slice = arr.slice,

		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function (list, elem) {
			var i = 0,
			    len = list.length;
			for (; i < len; i++) {
				if (list[i] === elem) {
					return i;
				}
			}
			return -1;
		},
		    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",


		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",


		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
		    pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" + ")\\)|)",


		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp(whitespace + "+", "g"),
		    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
		    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
		    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
		    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
		    rpseudo = new RegExp(pseudos),
		    ridentifier = new RegExp("^" + identifier + "$"),
		    matchExpr = {
			"ID": new RegExp("^#(" + identifier + ")"),
			"CLASS": new RegExp("^\\.(" + identifier + ")"),
			"TAG": new RegExp("^(" + identifier + "|[*])"),
			"ATTR": new RegExp("^" + attributes),
			"PSEUDO": new RegExp("^" + pseudos),
			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
		},
		    rinputs = /^(?:input|select|textarea|button)$/i,
		    rheader = /^h\d$/i,
		    rnative = /^[^{]+\{\s*\[native \w/,


		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		    rsibling = /[+~]/,
		    rescape = /'|\\/g,


		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
		    funescape = function (_, escaped, escapedWhitespace) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ? escaped : high < 0 ?
			// BMP codepoint
			String.fromCharCode(high + 0x10000) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
		},


		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function () {
			setDocument();
		};

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
			// Support: Android<4.0
			// Detect silently failing push.apply
			arr[preferredDoc.childNodes.length].nodeType;
		} catch (e) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function (target, els) {
					push_native.apply(target, slice.call(els));
				} :

				// Support: IE<9
				// Otherwise append directly
				function (target, els) {
					var j = target.length,
					    i = 0;
					// Can't trust NodeList.length
					while (target[j++] = els[i++]) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle(selector, context, results, seed) {
			var m,
			    i,
			    elem,
			    nid,
			    nidselect,
			    match,
			    groups,
			    newSelector,
			    newContext = context && context.ownerDocument,


			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if (!seed) {

				if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
					setDocument(context);
				}
				context = context || document;

				if (documentIsHTML) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

						// ID selector
						if (m = match[1]) {

							// Document context
							if (nodeType === 9) {
								if (elem = context.getElementById(m)) {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (elem.id === m) {
										results.push(elem);
										return results;
									}
								} else {
									return results;
								}

								// Element context
							} else {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {

									results.push(elem);
									return results;
								}
							}

							// Type selector
						} else if (match[2]) {
							push.apply(results, context.getElementsByTagName(selector));
							return results;

							// Class selector
						} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {

							push.apply(results, context.getElementsByClassName(m));
							return results;
						}
					}

					// Take advantage of querySelectorAll
					if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {

						if (nodeType !== 1) {
							newContext = context;
							newSelector = selector;

							// qSA looks outside Element context, which is not what we want
							// Thanks to Andrew Dupont for this workaround technique
							// Support: IE <=8
							// Exclude object elements
						} else if (context.nodeName.toLowerCase() !== "object") {

							// Capture the context ID, setting it first if necessary
							if (nid = context.getAttribute("id")) {
								nid = nid.replace(rescape, "\\$&");
							} else {
								context.setAttribute("id", nid = expando);
							}

							// Prefix every selector in the list
							groups = tokenize(selector);
							i = groups.length;
							nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
							while (i--) {
								groups[i] = nidselect + " " + toSelector(groups[i]);
							}
							newSelector = groups.join(",");

							// Expand context for sibling selectors
							newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
						}

						if (newSelector) {
							try {
								push.apply(results, newContext.querySelectorAll(newSelector));
								return results;
							} catch (qsaError) {} finally {
								if (nid === expando) {
									context.removeAttribute("id");
								}
							}
						}
					}
				}
			}

			// All others
			return select(selector.replace(rtrim, "$1"), context, results, seed);
		}

		/**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
		function createCache() {
			var keys = [];

			function cache(key, value) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if (keys.push(key + " ") > Expr.cacheLength) {
					// Only keep the most recent entries
					delete cache[keys.shift()];
				}
				return cache[key + " "] = value;
			}
			return cache;
		}

		/**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
		function markFunction(fn) {
			fn[expando] = true;
			return fn;
		}

		/**
   * Support testing using an element
   * @param {Function} fn Passed the created div and expects a boolean result
   */
		function assert(fn) {
			var div = document.createElement("div");

			try {
				return !!fn(div);
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if (div.parentNode) {
					div.parentNode.removeChild(div);
				}
				// release memory in IE
				div = null;
			}
		}

		/**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
		function addHandle(attrs, handler) {
			var arr = attrs.split("|"),
			    i = arr.length;

			while (i--) {
				Expr.attrHandle[arr[i]] = handler;
			}
		}

		/**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
		function siblingCheck(a, b) {
			var cur = b && a,
			    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

			// Use IE sourceIndex if available on both nodes
			if (diff) {
				return diff;
			}

			// Check if b follows a
			if (cur) {
				while (cur = cur.nextSibling) {
					if (cur === b) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
		function createInputPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
		function createButtonPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
		function createPositionalPseudo(fn) {
			return markFunction(function (argument) {
				argument = +argument;
				return markFunction(function (seed, matches) {
					var j,
					    matchIndexes = fn([], seed.length, argument),
					    i = matchIndexes.length;

					// Match elements found at the specified indexes
					while (i--) {
						if (seed[j = matchIndexes[i]]) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
		function testContext(context) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
		isXML = Sizzle.isXML = function (elem) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem && (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
		setDocument = Sizzle.setDocument = function (node) {
			var hasCompare,
			    parent,
			    doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
				return document;
			}

			// Update global variables
			document = doc;
			docElem = document.documentElement;
			documentIsHTML = !isXML(document);

			// Support: IE 9-11, Edge
			// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
			if ((parent = document.defaultView) && parent.top !== parent) {
				// Support: IE 11
				if (parent.addEventListener) {
					parent.addEventListener("unload", unloadHandler, false);

					// Support: IE 9 - 10 only
				} else if (parent.attachEvent) {
					parent.attachEvent("onunload", unloadHandler);
				}
			}

			/* Attributes
   ---------------------------------------------------------------------- */

			// Support: IE<8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function (div) {
				div.className = "i";
				return !div.getAttribute("className");
			});

			/* getElement(s)By*
   ---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function (div) {
				div.appendChild(document.createComment(""));
				return !div.getElementsByTagName("*").length;
			});

			// Support: IE<9
			support.getElementsByClassName = rnative.test(document.getElementsByClassName);

			// Support: IE<10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function (div) {
				docElem.appendChild(div).id = expando;
				return !document.getElementsByName || !document.getElementsByName(expando).length;
			});

			// ID find and filter
			if (support.getById) {
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var m = context.getElementById(id);
						return m ? [m] : [];
					}
				};
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						return elem.getAttribute("id") === attrId;
					};
				};
			} else {
				// Support: IE6/7
				// getElementById is not reliable as a find shortcut
				delete Expr.find["ID"];

				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
						return node && node.value === attrId;
					};
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
				if (typeof context.getElementsByTagName !== "undefined") {
					return context.getElementsByTagName(tag);

					// DocumentFragment nodes don't have gEBTN
				} else if (support.qsa) {
					return context.querySelectorAll(tag);
				}
			} : function (tag, context) {
				var elem,
				    tmp = [],
				    i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName(tag);

				// Filter out possible comments
				if (tag === "*") {
					while (elem = results[i++]) {
						if (elem.nodeType === 1) {
							tmp.push(elem);
						}
					}

					return tmp;
				}
				return results;
			};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
				if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
					return context.getElementsByClassName(className);
				}
			};

			/* QSA/matchesSelector
   ---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See http://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if (support.qsa = rnative.test(document.querySelectorAll)) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function (div) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// http://bugs.jquery.com/ticket/12359
					docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if (div.querySelectorAll("[msallowcapture^='']").length) {
						rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if (!div.querySelectorAll("[selected]").length) {
						rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
					}

					// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
					if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":checked").length) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibing-combinator selector` fails
					if (!div.querySelectorAll("a#" + expando + "+*").length) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function (div) {
					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = document.createElement("input");
					input.setAttribute("type", "hidden");
					div.appendChild(input).setAttribute("name", "D");

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if (div.querySelectorAll("[name=d]").length) {
						rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":enabled").length) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					div.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

				assert(function (div) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call(div, "div");

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call(div, "[s!='']:x");
					rbuggyMatches.push("!=", pseudos);
				});
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
			rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

			/* Contains
   ---------------------------------------------------------------------- */
			hasCompare = rnative.test(docElem.compareDocumentPosition);

			// Element contains another
			// Purposefully self-exclusive
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
				    bup = b && b.parentNode;
				return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
			} : function (a, b) {
				if (b) {
					while (b = b.parentNode) {
						if (b === a) {
							return true;
						}
					}
				}
				return false;
			};

			/* Sorting
   ---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ? function (a, b) {

				// Flag for duplicate removal
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

				// Otherwise we know they are disconnected
				1;

				// Disconnected nodes
				if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

					// Choose the first element that is related to our preferred document
					if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
						return -1;
					}
					if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
						return 1;
					}

					// Maintain original order
					return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
				}

				return compare & 4 ? -1 : 1;
			} : function (a, b) {
				// Exit early if the nodes are identical
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
				    i = 0,
				    aup = a.parentNode,
				    bup = b.parentNode,
				    ap = [a],
				    bp = [b];

				// Parentless nodes are either documents or disconnected
				if (!aup || !bup) {
					return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

					// If the nodes are siblings, we can do a quick check
				} else if (aup === bup) {
					return siblingCheck(a, b);
				}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while (cur = cur.parentNode) {
					ap.unshift(cur);
				}
				cur = b;
				while (cur = cur.parentNode) {
					bp.unshift(cur);
				}

				// Walk down the tree looking for a discrepancy
				while (ap[i] === bp[i]) {
					i++;
				}

				return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck(ap[i], bp[i]) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
			};

			return document;
		};

		Sizzle.matches = function (expr, elements) {
			return Sizzle(expr, null, null, elements);
		};

		Sizzle.matchesSelector = function (elem, expr) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace(rattributeQuotes, "='$1']");

			if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

				try {
					var ret = matches.call(elem, expr);

					// IE 9's matchesSelector returns false on disconnected nodes
					if (ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle(expr, document, null, [elem]).length > 0;
		};

		Sizzle.contains = function (context, elem) {
			// Set document vars if needed
			if ((context.ownerDocument || context) !== document) {
				setDocument(context);
			}
			return contains(context, elem);
		};

		Sizzle.attr = function (elem, name) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			var fn = Expr.attrHandle[name.toLowerCase()],

			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

			return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
		};

		Sizzle.error = function (msg) {
			throw new Error("Syntax error, unrecognized expression: " + msg);
		};

		/**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
		Sizzle.uniqueSort = function (results) {
			var elem,
			    duplicates = [],
			    j = 0,
			    i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable && results.slice(0);
			results.sort(sortOrder);

			if (hasDuplicate) {
				while (elem = results[i++]) {
					if (elem === results[i]) {
						j = duplicates.push(i);
					}
				}
				while (j--) {
					results.splice(duplicates[j], 1);
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
		getText = Sizzle.getText = function (elem) {
			var node,
			    ret = "",
			    i = 0,
			    nodeType = elem.nodeType;

			if (!nodeType) {
				// If no nodeType, this is expected to be an array
				while (node = elem[i++]) {
					// Do not traverse comment nodes
					ret += getText(node);
				}
			} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if (typeof elem.textContent === "string") {
					return elem.textContent;
				} else {
					// Traverse its children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						ret += getText(elem);
					}
				}
			} else if (nodeType === 3 || nodeType === 4) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function (match) {
					match[1] = match[1].replace(runescape, funescape);

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

					if (match[2] === "~=") {
						match[3] = " " + match[3] + " ";
					}

					return match.slice(0, 4);
				},

				"CHILD": function (match) {
					/* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
					match[1] = match[1].toLowerCase();

					if (match[1].slice(0, 3) === "nth") {
						// nth-* requires argument
						if (!match[3]) {
							Sizzle.error(match[0]);
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
						match[5] = +(match[7] + match[8] || match[3] === "odd");

						// other types prohibit arguments
					} else if (match[3]) {
						Sizzle.error(match[0]);
					}

					return match;
				},

				"PSEUDO": function (match) {
					var excess,
					    unquoted = !match[6] && match[2];

					if (matchExpr["CHILD"].test(match[0])) {
						return null;
					}

					// Accept quoted arguments as-is
					if (match[3]) {
						match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
					} else if (unquoted && rpseudo.test(unquoted) && (
					// Get excess from tokenize (recursively)
					excess = tokenize(unquoted, true)) && (
					// advance to the next closing parenthesis
					excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

						// excess is a negative index
						match[0] = match[0].slice(0, excess);
						match[2] = unquoted.slice(0, excess);
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice(0, 3);
				}
			},

			filter: {

				"TAG": function (nodeNameSelector) {
					var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
					return nodeNameSelector === "*" ? function () {
						return true;
					} : function (elem) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
				},

				"CLASS": function (className) {
					var pattern = classCache[className + " "];

					return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
						return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
					});
				},

				"ATTR": function (name, operator, check) {
					return function (elem) {
						var result = Sizzle.attr(elem, name);

						if (result == null) {
							return operator === "!=";
						}
						if (!operator) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
					};
				},

				"CHILD": function (type, what, argument, first, last) {
					var simple = type.slice(0, 3) !== "nth",
					    forward = type.slice(-4) !== "last",
					    ofType = what === "of-type";

					return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function (elem) {
						return !!elem.parentNode;
					} : function (elem, context, xml) {
						var cache,
						    uniqueCache,
						    outerCache,
						    node,
						    nodeIndex,
						    start,
						    dir = simple !== forward ? "nextSibling" : "previousSibling",
						    parent = elem.parentNode,
						    name = ofType && elem.nodeName.toLowerCase(),
						    useCache = !xml && !ofType,
						    diff = false;

						if (parent) {

							// :(first|last|only)-(child|of-type)
							if (simple) {
								while (dir) {
									node = elem;
									while (node = node[dir]) {
										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [forward ? parent.firstChild : parent.lastChild];

							// non-xml :nth-child(...) stores cache data on `parent`
							if (forward && useCache) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[expando] || (node[expando] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

								cache = uniqueCache[type] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = nodeIndex && cache[2];
								node = nodeIndex && parent.childNodes[nodeIndex];

								while (node = ++nodeIndex && node && node[dir] || (

								// Fallback to seeking `elem` from the start
								diff = nodeIndex = 0) || start.pop()) {

									// When found, cache indexes on `parent` and break
									if (node.nodeType === 1 && ++diff && node === elem) {
										uniqueCache[type] = [dirruns, nodeIndex, diff];
										break;
									}
								}
							} else {
								// Use previously-cached element index if available
								if (useCache) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[expando] || (node[expando] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

									cache = uniqueCache[type] || [];
									nodeIndex = cache[0] === dirruns && cache[1];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if (diff === false) {
									// Use the same loop as above to seek `elem` from the start
									while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

										if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {

											// Cache the index of each encountered element
											if (useCache) {
												outerCache = node[expando] || (node[expando] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

												uniqueCache[type] = [dirruns, diff];
											}

											if (node === elem) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || diff % first === 0 && diff / first >= 0;
						}
					};
				},

				"PSEUDO": function (pseudo, argument) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
					    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if (fn[expando]) {
						return fn(argument);
					}

					// But maintain support for old signatures
					if (fn.length > 1) {
						args = [pseudo, pseudo, "", argument];
						return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
							var idx,
							    matched = fn(seed, argument),
							    i = matched.length;
							while (i--) {
								idx = indexOf(seed, matched[i]);
								seed[idx] = !(matches[idx] = matched[i]);
							}
						}) : function (elem) {
							return fn(elem, 0, args);
						};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function (selector) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
					    results = [],
					    matcher = compile(selector.replace(rtrim, "$1"));

					return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
						var elem,
						    unmatched = matcher(seed, null, xml, []),
						    i = seed.length;

						// Match elements unmatched by `matcher`
						while (i--) {
							if (elem = unmatched[i]) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) : function (elem, context, xml) {
						input[0] = elem;
						matcher(input, null, xml, results);
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
				}),

				"has": markFunction(function (selector) {
					return function (elem) {
						return Sizzle(selector, elem).length > 0;
					};
				}),

				"contains": markFunction(function (text) {
					text = text.replace(runescape, funescape);
					return function (elem) {
						return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction(function (lang) {
					// lang value must be a valid identifier
					if (!ridentifier.test(lang || "")) {
						Sizzle.error("unsupported lang: " + lang);
					}
					lang = lang.replace(runescape, funescape).toLowerCase();
					return function (elem) {
						var elemLang;
						do {
							if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
							}
						} while ((elem = elem.parentNode) && elem.nodeType === 1);
						return false;
					};
				}),

				// Miscellaneous
				"target": function (elem) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice(1) === elem.id;
				},

				"root": function (elem) {
					return elem === docElem;
				},

				"focus": function (elem) {
					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": function (elem) {
					return elem.disabled === false;
				},

				"disabled": function (elem) {
					return elem.disabled === true;
				},

				"checked": function (elem) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
				},

				"selected": function (elem) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if (elem.parentNode) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function (elem) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						if (elem.nodeType < 6) {
							return false;
						}
					}
					return true;
				},

				"parent": function (elem) {
					return !Expr.pseudos["empty"](elem);
				},

				// Element/input types
				"header": function (elem) {
					return rheader.test(elem.nodeName);
				},

				"input": function (elem) {
					return rinputs.test(elem.nodeName);
				},

				"button": function (elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === "button" || name === "button";
				},

				"text": function (elem) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
				},

				// Position-in-collection
				"first": createPositionalPseudo(function () {
					return [0];
				}),

				"last": createPositionalPseudo(function (matchIndexes, length) {
					return [length - 1];
				}),

				"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
					return [argument < 0 ? argument + length : argument];
				}),

				"even": createPositionalPseudo(function (matchIndexes, length) {
					var i = 0;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function (matchIndexes, length) {
					var i = 1;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; --i >= 0;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; ++i < length;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
			Expr.pseudos[i] = createInputPseudo(i);
		}
		for (i in { submit: true, reset: true }) {
			Expr.pseudos[i] = createButtonPseudo(i);
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function (selector, parseOnly) {
			var matched,
			    match,
			    tokens,
			    type,
			    soFar,
			    groups,
			    preFilters,
			    cached = tokenCache[selector + " "];

			if (cached) {
				return parseOnly ? 0 : cached.slice(0);
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while (soFar) {

				// Comma and first run
				if (!matched || (match = rcomma.exec(soFar))) {
					if (match) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice(match[0].length) || soFar;
					}
					groups.push(tokens = []);
				}

				matched = false;

				// Combinators
				if (match = rcombinators.exec(soFar)) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace(rtrim, " ")
					});
					soFar = soFar.slice(matched.length);
				}

				// Filters
				for (type in Expr.filter) {
					if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice(matched.length);
					}
				}

				if (!matched) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
			// Cache the tokens
			tokenCache(selector, groups).slice(0);
		};

		function toSelector(tokens) {
			var i = 0,
			    len = tokens.length,
			    selector = "";
			for (; i < len; i++) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator(matcher, combinator, base) {
			var dir = combinator.dir,
			    checkNonElements = base && dir === "parentNode",
			    doneName = done++;

			return combinator.first ?
			// Check against closest ancestor/preceding element
			function (elem, context, xml) {
				while (elem = elem[dir]) {
					if (elem.nodeType === 1 || checkNonElements) {
						return matcher(elem, context, xml);
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function (elem, context, xml) {
				var oldCache,
				    uniqueCache,
				    outerCache,
				    newCache = [dirruns, doneName];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if (xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							if (matcher(elem, context, xml)) {
								return true;
							}
						}
					}
				} else {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							outerCache = elem[expando] || (elem[expando] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

							if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

								// Assign to newCache so results back-propagate to previous elements
								return newCache[2] = oldCache[2];
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[dir] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if (newCache[2] = matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					}
				}
			};
		}

		function elementMatcher(matchers) {
			return matchers.length > 1 ? function (elem, context, xml) {
				var i = matchers.length;
				while (i--) {
					if (!matchers[i](elem, context, xml)) {
						return false;
					}
				}
				return true;
			} : matchers[0];
		}

		function multipleContexts(selector, contexts, results) {
			var i = 0,
			    len = contexts.length;
			for (; i < len; i++) {
				Sizzle(selector, contexts[i], results);
			}
			return results;
		}

		function condense(unmatched, map, filter, context, xml) {
			var elem,
			    newUnmatched = [],
			    i = 0,
			    len = unmatched.length,
			    mapped = map != null;

			for (; i < len; i++) {
				if (elem = unmatched[i]) {
					if (!filter || filter(elem, context, xml)) {
						newUnmatched.push(elem);
						if (mapped) {
							map.push(i);
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
			if (postFilter && !postFilter[expando]) {
				postFilter = setMatcher(postFilter);
			}
			if (postFinder && !postFinder[expando]) {
				postFinder = setMatcher(postFinder, postSelector);
			}
			return markFunction(function (seed, results, context, xml) {
				var temp,
				    i,
				    elem,
				    preMap = [],
				    postMap = [],
				    preexisting = results.length,


				// Get initial elements from seed or context
				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
				    matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results : matcherIn;

				// Find primary matches
				if (matcher) {
					matcher(matcherIn, matcherOut, context, xml);
				}

				// Apply postFilter
				if (postFilter) {
					temp = condense(matcherOut, postMap);
					postFilter(temp, [], context, xml);

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while (i--) {
						if (elem = temp[i]) {
							matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
						}
					}
				}

				if (seed) {
					if (postFinder || preFilter) {
						if (postFinder) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while (i--) {
								if (elem = matcherOut[i]) {
									// Restore matcherIn since elem is not yet a final match
									temp.push(matcherIn[i] = elem);
								}
							}
							postFinder(null, matcherOut = [], temp, xml);
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while (i--) {
							if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

					// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
					if (postFinder) {
						postFinder(null, results, matcherOut, xml);
					} else {
						push.apply(results, matcherOut);
					}
				}
			});
		}

		function matcherFromTokens(tokens) {
			var checkContext,
			    matcher,
			    j,
			    len = tokens.length,
			    leadingRelative = Expr.relative[tokens[0].type],
			    implicitRelative = leadingRelative || Expr.relative[" "],
			    i = leadingRelative ? 1 : 0,


			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator(function (elem) {
				return elem === checkContext;
			}, implicitRelative, true),
			    matchAnyContext = addCombinator(function (elem) {
				return indexOf(checkContext, elem) > -1;
			}, implicitRelative, true),
			    matchers = [function (elem, context, xml) {
				var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			}];

			for (; i < len; i++) {
				if (matcher = Expr.relative[tokens[i].type]) {
					matchers = [addCombinator(elementMatcher(matchers), matcher)];
				} else {
					matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

					// Return special upon seeing a positional matcher
					if (matcher[expando]) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for (; j < len; j++) {
							if (Expr.relative[tokens[j].type]) {
								break;
							}
						}
						return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
					}
					matchers.push(matcher);
				}
			}

			return elementMatcher(matchers);
		}

		function matcherFromGroupMatchers(elementMatchers, setMatchers) {
			var bySet = setMatchers.length > 0,
			    byElement = elementMatchers.length > 0,
			    superMatcher = function (seed, context, xml, results, outermost) {
				var elem,
				    j,
				    matcher,
				    matchedCount = 0,
				    i = "0",
				    unmatched = seed && [],
				    setMatched = [],
				    contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]("*", outermost),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
				    len = elems.length;

				if (outermost) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for (; i !== len && (elem = elems[i]) != null; i++) {
					if (byElement && elem) {
						j = 0;
						if (!context && elem.ownerDocument !== document) {
							setDocument(elem);
							xml = !documentIsHTML;
						}
						while (matcher = elementMatchers[j++]) {
							if (matcher(elem, context || document, xml)) {
								results.push(elem);
								break;
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if (bySet) {
						// They will have gone through all possible matchers
						if (elem = !matcher && elem) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if (seed) {
							unmatched.push(elem);
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if (bySet && i !== matchedCount) {
					j = 0;
					while (matcher = setMatchers[j++]) {
						matcher(unmatched, setMatched, context, xml);
					}

					if (seed) {
						// Reintegrate element matches to eliminate the need for sorting
						if (matchedCount > 0) {
							while (i--) {
								if (!(unmatched[i] || setMatched[i])) {
									setMatched[i] = pop.call(results);
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense(setMatched);
					}

					// Add matches to results
					push.apply(results, setMatched);

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

						Sizzle.uniqueSort(results);
					}
				}

				// Override manipulation of globals by nested matchers
				if (outermost) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

			return bySet ? markFunction(superMatcher) : superMatcher;
		}

		compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
			var i,
			    setMatchers = [],
			    elementMatchers = [],
			    cached = compilerCache[selector + " "];

			if (!cached) {
				// Generate a function of recursive functions that can be used to check each element
				if (!match) {
					match = tokenize(selector);
				}
				i = match.length;
				while (i--) {
					cached = matcherFromTokens(match[i]);
					if (cached[expando]) {
						setMatchers.push(cached);
					} else {
						elementMatchers.push(cached);
					}
				}

				// Cache the compiled function
				cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
		select = Sizzle.select = function (selector, context, results, seed) {
			var i,
			    tokens,
			    token,
			    type,
			    find,
			    compiled = typeof selector === "function" && selector,
			    match = !seed && tokenize(selector = compiled.selector || selector);

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if (match.length === 1) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[0] = match[0].slice(0);
				if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

					context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
					if (!context) {
						return results;

						// Precompiled matchers will still verify ancestry, so step up a level
					} else if (compiled) {
						context = context.parentNode;
					}

					selector = selector.slice(tokens.shift().value.length);
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
				while (i--) {
					token = tokens[i];

					// Abort if we hit a combinator
					if (Expr.relative[type = token.type]) {
						break;
					}
					if (find = Expr.find[type]) {
						// Search, expanding context for leading sibling combinators
						if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice(i, 1);
							selector = seed.length && toSelector(tokens);
							if (!selector) {
								push.apply(results, seed);
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function (div1) {
			// Should return 1, but returns 4 (following)
			return div1.compareDocumentPosition(document.createElement("div")) & 1;
		});

		// Support: IE<8
		// Prevent attribute/property "interpolation"
		// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if (!assert(function (div) {
			div.innerHTML = "<a href='#'></a>";
			return div.firstChild.getAttribute("href") === "#";
		})) {
			addHandle("type|href|height|width", function (elem, name, isXML) {
				if (!isXML) {
					return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
				}
			});
		}

		// Support: IE<9
		// Use defaultValue in place of getAttribute("value")
		if (!support.attributes || !assert(function (div) {
			div.innerHTML = "<input/>";
			div.firstChild.setAttribute("value", "");
			return div.firstChild.getAttribute("value") === "";
		})) {
			addHandle("value", function (elem, name, isXML) {
				if (!isXML && elem.nodeName.toLowerCase() === "input") {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE<9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if (!assert(function (div) {
			return div.getAttribute("disabled") == null;
		})) {
			addHandle(booleans, function (elem, name, isXML) {
				var val;
				if (!isXML) {
					return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
				}
			});
		}

		return Sizzle;
	}(window);

	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;

	var dir = function (elem, dir, until) {
		var matched = [],
		    truncate = until !== undefined;

		while ((elem = elem[dir]) && elem.nodeType !== 9) {
			if (elem.nodeType === 1) {
				if (truncate && jQuery(elem).is(until)) {
					break;
				}
				matched.push(elem);
			}
		}
		return matched;
	};

	var siblings = function (n, elem) {
		var matched = [];

		for (; n; n = n.nextSibling) {
			if (n.nodeType === 1 && n !== elem) {
				matched.push(n);
			}
		}

		return matched;
	};

	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;

	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (jQuery.isFunction(qualifier)) {
			return jQuery.grep(elements, function (elem, i) {
				/* jshint -W018 */
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}

		if (qualifier.nodeType) {
			return jQuery.grep(elements, function (elem) {
				return elem === qualifier !== not;
			});
		}

		if (typeof qualifier === "string") {
			if (risSimple.test(qualifier)) {
				return jQuery.filter(qualifier, elements, not);
			}

			qualifier = jQuery.filter(qualifier, elements);
		}

		return jQuery.grep(elements, function (elem) {
			return indexOf.call(qualifier, elem) > -1 !== not;
		});
	}

	jQuery.filter = function (expr, elems, not) {
		var elem = elems[0];

		if (not) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
			return elem.nodeType === 1;
		}));
	};

	jQuery.fn.extend({
		find: function (selector) {
			var i,
			    len = this.length,
			    ret = [],
			    self = this;

			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function () {
					for (i = 0; i < len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}

			for (i = 0; i < len; i++) {
				jQuery.find(selector, self[i], ret);
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function (selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function (selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function (selector) {
			return !!winnow(this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
		}
	});

	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,


	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	    init = jQuery.fn.init = function (selector, context, root) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [null, selector, null];
			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match && (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
						for (match in context) {

							// Properties of context are called as methods if possible
							if (jQuery.isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
								this.attr(match, context[match]);
							}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
					elem = document.getElementById(match[2]);

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if (elem && elem.parentNode) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
				return (context || root).find(selector);

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor(context).find(selector);
			}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

			// HANDLE: $(function)
			// Shortcut for document ready
		} else if (jQuery.isFunction(selector)) {
			return root.ready !== undefined ? root.ready(selector) :

			// Execute immediately if ready is not present
			selector(jQuery);
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray(selector, this);
	};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery(document);

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,


	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

	jQuery.fn.extend({
		has: function (target) {
			var targets = jQuery(target, this),
			    l = targets.length;

			return this.filter(function () {
				var i = 0;
				for (; i < l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},

		closest: function (selectors, context) {
			var cur,
			    i = 0,
			    l = this.length,
			    matched = [],
			    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

			for (; i < l; i++) {
				for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

					// Always skip document fragments
					if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

						matched.push(cur);
						break;
					}
				}
			}

			return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
		},

		// Determine the position of an element within the set
		index: function (elem) {

			// No argument, return index in parent
			if (!elem) {
				return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}

			// Locate the position of the desired element
			return indexOf.call(this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem);
		},

		add: function (selector, context) {
			return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
		},

		addBack: function (selector) {
			return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) && cur.nodeType !== 1) {}
		return cur;
	}

	jQuery.each({
		parent: function (elem) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function (elem) {
			return dir(elem, "parentNode");
		},
		parentsUntil: function (elem, i, until) {
			return dir(elem, "parentNode", until);
		},
		next: function (elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function (elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function (elem) {
			return dir(elem, "nextSibling");
		},
		prevAll: function (elem) {
			return dir(elem, "previousSibling");
		},
		nextUntil: function (elem, i, until) {
			return dir(elem, "nextSibling", until);
		},
		prevUntil: function (elem, i, until) {
			return dir(elem, "previousSibling", until);
		},
		siblings: function (elem) {
			return siblings((elem.parentNode || {}).firstChild, elem);
		},
		children: function (elem) {
			return siblings(elem.firstChild);
		},
		contents: function (elem) {
			return elem.contentDocument || jQuery.merge([], elem.childNodes);
		}
	}, function (name, fn) {
		jQuery.fn[name] = function (until, selector) {
			var matched = jQuery.map(this, fn, until);

			if (name.slice(-5) !== "Until") {
				selector = until;
			}

			if (selector && typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}

			if (this.length > 1) {

				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.uniqueSort(matched);
				}

				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}

			return this.pushStack(matched);
		};
	});
	var rnotwhite = /\S+/g;

	// Convert String-formatted options into Object-formatted ones
	function createOptions(options) {
		var object = {};
		jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
			object[flag] = true;
		});
		return object;
	}

	/*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
	jQuery.Callbacks = function (options) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

		var // Flag to know if list is currently firing
		firing,


		// Last fire value for non-forgettable lists
		memory,


		// Flag to know if list was already fired
		fired,


		// Flag to prevent firing
		locked,


		// Actual callback list
		list = [],


		// Queue of execution data for repeatable lists
		queue = [],


		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,


		// Fire callbacks
		fire = function () {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for (; queue.length; firingIndex = -1) {
				memory = queue.shift();
				while (++firingIndex < list.length) {

					// Run callback and check for early termination
					if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if (!options.memory) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if (locked) {

				// Keep an empty list if we have data for future add calls
				if (memory) {
					list = [];

					// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},


		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function () {
				if (list) {

					// If we have memory from a past run, we should fire after adding
					if (memory && !firing) {
						firingIndex = list.length - 1;
						queue.push(memory);
					}

					(function add(args) {
						jQuery.each(args, function (_, arg) {
							if (jQuery.isFunction(arg)) {
								if (!options.unique || !self.has(arg)) {
									list.push(arg);
								}
							} else if (arg && arg.length && jQuery.type(arg) !== "string") {

								// Inspect recursively
								add(arg);
							}
						});
					})(arguments);

					if (memory && !firing) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function () {
				jQuery.each(arguments, function (_, arg) {
					var index;
					while ((index = jQuery.inArray(arg, list, index)) > -1) {
						list.splice(index, 1);

						// Handle firing indexes
						if (index <= firingIndex) {
							firingIndex--;
						}
					}
				});
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function (fn) {
				return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function () {
				if (list) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function () {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function () {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function () {
				locked = queue = [];
				if (!memory) {
					list = memory = "";
				}
				return this;
			},
			locked: function () {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function (context, args) {
				if (!locked) {
					args = args || [];
					args = [context, args.slice ? args.slice() : args];
					queue.push(args);
					if (!firing) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function () {
				self.fireWith(this, arguments);
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function () {
				return !!fired;
			}
		};

		return self;
	};

	jQuery.extend({

		Deferred: function (func) {
			var tuples = [

			// action, add listener, listener list, final state
			["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
			    state = "pending",
			    promise = {
				state: function () {
					return state;
				},
				always: function () {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				then: function () /* fnDone, fnFail, fnProgress */{
					var fns = arguments;
					return jQuery.Deferred(function (newDefer) {
						jQuery.each(tuples, function (i, tuple) {
							var fn = jQuery.isFunction(fns[i]) && fns[i];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[tuple[1]](function () {
								var returned = fn && fn.apply(this, arguments);
								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
								} else {
									newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function (obj) {
					return obj != null ? jQuery.extend(obj, promise) : promise;
				}
			},
			    deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list = tuple[2],
				    stateString = tuple[3];

				// promise[ done | fail | progress ] = list.add
				promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {

						// state = [ resolved | rejected ]
						state = stateString;

						// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
				}

				// deferred[ resolve | reject | notify ]
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
					return this;
				};
				deferred[tuple[0] + "With"] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function (subordinate /* , ..., subordinateN */) {
			var i = 0,
			    resolveValues = slice.call(arguments),
			    length = resolveValues.length,


			// the count of uncompleted subordinates
			remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,


			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),


			// Update function for both resolve and progress values
			updateFunc = function (i, contexts, values) {
				return function (value) {
					contexts[i] = this;
					values[i] = arguments.length > 1 ? slice.call(arguments) : value;
					if (values === progressValues) {
						deferred.notifyWith(contexts, values);
					} else if (! --remaining) {
						deferred.resolveWith(contexts, values);
					}
				};
			},
			    progressValues,
			    progressContexts,
			    resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if (length > 1) {
				progressValues = new Array(length);
				progressContexts = new Array(length);
				resolveContexts = new Array(length);
				for (; i < length; i++) {
					if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
						resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if (!remaining) {
				deferred.resolveWith(resolveContexts, resolveValues);
			}

			return deferred.promise();
		}
	});

	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function (fn) {

		// Add the callback
		jQuery.ready.promise().done(fn);

		return this;
	};

	jQuery.extend({

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function (hold) {
			if (hold) {
				jQuery.readyWait++;
			} else {
				jQuery.ready(true);
			}
		},

		// Handle when the DOM is ready
		ready: function (wait) {

			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true && --jQuery.readyWait > 0) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);

			// Trigger any bound ready events
			if (jQuery.fn.triggerHandler) {
				jQuery(document).triggerHandler("ready");
				jQuery(document).off("ready");
			}
		}
	});

	/**
  * The ready event handler and self cleanup method
  */
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed);
		window.removeEventListener("load", completed);
		jQuery.ready();
	}

	jQuery.ready.promise = function (obj) {
		if (!readyList) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout(jQuery.ready);
			} else {

				// Use the handy event callback
				document.addEventListener("DOMContentLoaded", completed);

				// A fallback to window.onload, that will always work
				window.addEventListener("load", completed);
			}
		}
		return readyList.promise(obj);
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
		    len = elems.length,
		    bulk = key == null;

		// Sets many values
		if (jQuery.type(key) === "object") {
			chainable = true;
			for (i in key) {
				access(elems, fn, i, key[i], true, emptyGet, raw);
			}

			// Sets one value
		} else if (value !== undefined) {
			chainable = true;

			if (!jQuery.isFunction(value)) {
				raw = true;
			}

			if (bulk) {

				// Bulk operations run against the entire set
				if (raw) {
					fn.call(elems, value);
					fn = null;

					// ...except when executing function values
				} else {
					bulk = fn;
					fn = function (elem, key, value) {
						return bulk.call(jQuery(elem), value);
					};
				}
			}

			if (fn) {
				for (; i < len; i++) {
					fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
				}
			}
		}

		return chainable ? elems :

		// Gets
		bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
	};
	var acceptData = function (owner) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	};

	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function (owner, initial) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if (owner.nodeType) {
				owner[this.expando] = value;

				// Otherwise secure it in a non-enumerable, non-writable property
				// configurability must be true to allow the property to be
				// deleted with the delete operator
			} else {
				Object.defineProperty(owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				});
			}
			return owner[this.expando];
		},
		cache: function (owner) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if (!acceptData(owner)) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[this.expando];

			// If not, create one
			if (!value) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (acceptData(owner)) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if (owner.nodeType) {
						owner[this.expando] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
					} else {
						Object.defineProperty(owner, this.expando, {
							value: value,
							configurable: true
						});
					}
				}
			}

			return value;
		},
		set: function (owner, data, value) {
			var prop,
			    cache = this.cache(owner);

			// Handle: [ owner, key, value ] args
			if (typeof data === "string") {
				cache[data] = value;

				// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for (prop in data) {
					cache[prop] = data[prop];
				}
			}
			return cache;
		},
		get: function (owner, key) {
			return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
		},
		access: function (owner, key, value) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined || key && typeof key === "string" && value === undefined) {

				stored = this.get(owner, key);

				return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function (owner, key) {
			var i,
			    name,
			    camel,
			    cache = owner[this.expando];

			if (cache === undefined) {
				return;
			}

			if (key === undefined) {
				this.register(owner);
			} else {

				// Support array or space separated string of keys
				if (jQuery.isArray(key)) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat(key.map(jQuery.camelCase));
				} else {
					camel = jQuery.camelCase(key);

					// Try the string as a key before any manipulation
					if (key in cache) {
						name = [key, camel];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ? [name] : name.match(rnotwhite) || [];
					}
				}

				i = name.length;

				while (i--) {
					delete cache[name[i]];
				}
			}

			// Remove the expando if there's no more data
			if (key === undefined || jQuery.isEmptyObject(cache)) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if (owner.nodeType) {
					owner[this.expando] = undefined;
				} else {
					delete owner[this.expando];
				}
			}
		},
		hasData: function (owner) {
			var cache = owner[this.expando];
			return cache !== undefined && !jQuery.isEmptyObject(cache);
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	    rmultiDash = /[A-Z]/g;

	function dataAttr(elem, key, data) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined && elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
			data = elem.getAttribute(name);

			if (typeof data === "string") {
				try {
					data = data === "true" ? true : data === "false" ? false : data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
				} catch (e) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function (elem) {
			return dataUser.hasData(elem) || dataPriv.hasData(elem);
		},

		data: function (elem, name, data) {
			return dataUser.access(elem, name, data);
		},

		removeData: function (elem, name) {
			dataUser.remove(elem, name);
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function (elem, name, data) {
			return dataPriv.access(elem, name, data);
		},

		_removeData: function (elem, name) {
			dataPriv.remove(elem, name);
		}
	});

	jQuery.fn.extend({
		data: function (key, value) {
			var i,
			    name,
			    data,
			    elem = this[0],
			    attrs = elem && elem.attributes;

			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = dataUser.get(elem);

					if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = jQuery.camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						dataPriv.set(elem, "hasDataAttrs", true);
					}
				}

				return data;
			}

			// Sets multiple values
			if (typeof key === "object") {
				return this.each(function () {
					dataUser.set(this, key);
				});
			}

			return access(this, function (value) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem && value === undefined) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get(elem, key) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());

					if (data !== undefined) {
						return data;
					}

					camelKey = jQuery.camelCase(key);

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get(elem, camelKey);
					if (data !== undefined) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, camelKey, undefined);
					if (data !== undefined) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase(key);
				this.each(function () {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get(this, camelKey);

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set(this, camelKey, value);

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if (key.indexOf("-") > -1 && data !== undefined) {
						dataUser.set(this, key, value);
					}
				});
			}, null, value, arguments.length > 1, null, true);
		},

		removeData: function (key) {
			return this.each(function () {
				dataUser.remove(this, key);
			});
		}
	});

	jQuery.extend({
		queue: function (elem, type, data) {
			var queue;

			if (elem) {
				type = (type || "fx") + "queue";
				queue = dataPriv.get(elem, type);

				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || jQuery.isArray(data)) {
						queue = dataPriv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},

		dequeue: function (elem, type) {
			type = type || "fx";

			var queue = jQuery.queue(elem, type),
			    startLength = queue.length,
			    fn = queue.shift(),
			    hooks = jQuery._queueHooks(elem, type),
			    next = function () {
				jQuery.dequeue(elem, type);
			};

			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}

			if (fn) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}

			if (!startLength && hooks) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function (elem, type) {
			var key = type + "queueHooks";
			return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function () {
					dataPriv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function (type, data) {
			var setter = 2;

			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}

			if (arguments.length < setter) {
				return jQuery.queue(this[0], type);
			}

			return data === undefined ? this : this.each(function () {
				var queue = jQuery.queue(this, type, data);

				// Ensure a hooks for this queue
				jQuery._queueHooks(this, type);

				if (type === "fx" && queue[0] !== "inprogress") {
					jQuery.dequeue(this, type);
				}
			});
		},
		dequeue: function (type) {
			return this.each(function () {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function (type) {
			return this.queue(type || "fx", []);
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function (type, obj) {
			var tmp,
			    count = 1,
			    defer = jQuery.Deferred(),
			    elements = this,
			    i = this.length,
			    resolve = function () {
				if (! --count) {
					defer.resolveWith(elements, [elements]);
				}
			};

			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while (i--) {
				tmp = dataPriv.get(elements[i], type + "queueHooks");
				if (tmp && tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

	var cssExpand = ["Top", "Right", "Bottom", "Left"];

	var isHidden = function (elem, el) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
	};

	function adjustCSS(elem, prop, valueParts, tween) {
		var adjusted,
		    scale = 1,
		    maxIterations = 20,
		    currentValue = tween ? function () {
			return tween.cur();
		} : function () {
			return jQuery.css(elem, prop, "");
		},
		    initial = currentValue(),
		    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


		// Starting value computation is required for potential unit mismatches
		initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

		if (initialInUnit && initialInUnit[3] !== unit) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[3];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style(elem, prop, initialInUnit + unit);

				// Update scale, tolerating zero or NaN from tween.cur()
				// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
		}

		if (valueParts) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
			if (tween) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = /^(?:checkbox|radio)$/i;

	var rtagName = /<([\w:-]+)/;

	var rscriptType = /^$|\/(?:java|ecma)script/i;

	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [1, "<select multiple='multiple'>", "</select>"],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

		_default: [0, "", ""]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	function getAll(context, tag) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];

		return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
		}
	}

	var rhtml = /<|&#?\w+;/;

	function buildFragment(elems, context, scripts, selection, ignored) {
		var elem,
		    tmp,
		    tag,
		    wrap,
		    contains,
		    j,
		    fragment = context.createDocumentFragment(),
		    nodes = [],
		    i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			elem = elems[i];

			if (elem || elem === 0) {

				// Add nodes directly
				if (jQuery.type(elem) === "object") {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

					// Convert non-html into a text node
				} else if (!rhtml.test(elem)) {
					nodes.push(context.createTextNode(elem));

					// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild(context.createElement("div"));

					// Deserialize a standard representation
					tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
					wrap = wrapMap[tag] || wrapMap._default;
					tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while (j--) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, tmp.childNodes);

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while (elem = nodes[i++]) {

			// Skip elements already in the context collection (trac-4087)
			if (selection && jQuery.inArray(elem, selection) > -1) {
				if (ignored) {
					ignored.push(elem);
				}
				continue;
			}

			contains = jQuery.contains(elem.ownerDocument, elem);

			// Append to fragment
			tmp = getAll(fragment.appendChild(elem), "script");

			// Preserve script evaluation history
			if (contains) {
				setGlobalEval(tmp);
			}

			// Capture executables
			if (scripts) {
				j = 0;
				while (elem = tmp[j++]) {
					if (rscriptType.test(elem.type || "")) {
						scripts.push(elem);
					}
				}
			}
		}

		return fragment;
	}

	(function () {
		var fragment = document.createDocumentFragment(),
		    div = fragment.appendChild(document.createElement("div")),
		    input = document.createElement("input");

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");

		div.appendChild(input);

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	})();

	var rkeyEvent = /^key/,
	    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	function on(elem, types, selector, data, fn, one) {
		var origFn, type;

		// Types can be a map of types/handlers
		if (typeof types === "object") {

			// ( types-Object, selector, data )
			if (typeof selector !== "string") {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for (type in types) {
				on(elem, type, selector, data, types[type], one);
			}
			return elem;
		}

		if (data == null && fn == null) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if (fn == null) {
			if (typeof selector === "string") {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if (fn === false) {
			fn = returnFalse;
		} else if (!fn) {
			return elem;
		}

		if (one === 1) {
			origFn = fn;
			fn = function (event) {

				// Can use an empty set, since event contains the info
				jQuery().off(event);
				return origFn.apply(this, arguments);
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
		}
		return elem.each(function () {
			jQuery.event.add(this, types, fn, data, selector);
		});
	}

	/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
	jQuery.event = {

		global: {},

		add: function (elem, types, handler, data, selector) {

			var handleObjIn,
			    eventHandle,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle);
						}
					}
				}

				if (special.add) {
					special.add.call(elem, handleObj);

					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},

		// Detach an event or set of events from an element
		remove: function (elem, types, handler, selector, mappedTypes) {

			var j,
			    origCount,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

						jQuery.removeEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove data and the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				dataPriv.remove(elem, "handle events");
			}
		},

		dispatch: function (event) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix(event);

			var i,
			    j,
			    ret,
			    matched,
			    handleObj,
			    handlerQueue = [],
			    args = slice.call(arguments),
			    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
			    special = jQuery.event.special[event.type] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch && special.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function (event, handlers) {
			var i,
			    matches,
			    sel,
			    handleObj,
			    handlerQueue = [],
			    delegateCount = handlers.delegateCount,
			    cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
						matches = [];
						for (i = 0; i < delegateCount; i++) {
							handleObj = handlers[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if (matches[sel] === undefined) {
								matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
							}
							if (matches[sel]) {
								matches.push(handleObj);
							}
						}
						if (matches.length) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if (delegateCount < handlers.length) {
				handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function (event, original) {

				// Add which for key events
				if (event.which == null) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
			filter: function (event, original) {
				var eventDoc,
				    doc,
				    body,
				    button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if (event.pageX == null && original.clientX != null) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
					event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if (!event.which && button !== undefined) {
					event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
				}

				return event;
			}
		},

		fix: function (event) {
			if (event[jQuery.expando]) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i,
			    prop,
			    copy,
			    type = event.type,
			    originalEvent = event,
			    fixHook = this.fixHooks[type];

			if (!fixHook) {
				this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
			}
			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

			event = new jQuery.Event(originalEvent);

			i = copy.length;
			while (i--) {
				prop = copy[i];
				event[prop] = originalEvent[prop];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if (!event.target) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if (event.target.nodeType === 3) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function () {
					if (this !== safeActiveElement() && this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function () {
					if (this === safeActiveElement() && this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function () {
					if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function (event) {
					return jQuery.nodeName(event.target, "a");
				}
			},

			beforeunload: {
				postDispatch: function (event) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined && event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function (elem, type, handle) {

		// This "if" is needed for plain objects
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle);
		}
	};

	jQuery.Event = function (src, props) {

		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}

		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&

			// Support: Android<4.0
			src.returnValue === false ? returnTrue : returnFalse;

			// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[jQuery.expando] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function () {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e && !this.isSimulated) {
				e.preventDefault();
			}
		},
		stopPropagation: function () {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e && !this.isSimulated) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function () {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if (e && !this.isSimulated) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,

			handle: function (event) {
				var ret,
				    target = this,
				    related = event.relatedTarget,
				    handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || related !== target && !jQuery.contains(target, related)) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});

	jQuery.fn.extend({
		on: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn);
		},
		one: function (types, selector, data, fn) {
			return on(this, types, selector, data, fn, 1);
		},
		off: function (types, selector, fn) {
			var handleObj, type;
			if (types && types.preventDefault && types.handleObj) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
				return this;
			}
			if (typeof types === "object") {

				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function () {
				jQuery.event.remove(this, types, fn, selector);
			});
		}
	});

	var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,


	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,


	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	    rscriptTypeMasked = /^true\/(.*)/,
	    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget(elem, content) {
		return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript(elem) {
		var match = rscriptTypeMasked.exec(elem.type);

		if (match) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if (dest.nodeType !== 1) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if (dataPriv.hasData(src)) {
			pdataOld = dataPriv.access(src);
			pdataCur = dataPriv.set(dest, pdataOld);
			events = pdataOld.events;

			if (events) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for (type in events) {
					for (i = 0, l = events[type].length; i < l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}

		// 2. Copy user data
		if (dataUser.hasData(src)) {
			udataOld = dataUser.access(src);
			udataCur = jQuery.extend({}, udataOld);

			dataUser.set(dest, udataCur);
		}
	}

	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" && rcheckableType.test(src.type)) {
			dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip(collection, args, callback, ignored) {

		// Flatten any nested arrays
		args = concat.apply([], args);

		var fragment,
		    first,
		    scripts,
		    hasScripts,
		    node,
		    doc,
		    i = 0,
		    l = collection.length,
		    iNoClone = l - 1,
		    value = args[0],
		    isFunction = jQuery.isFunction(value);

		// We can't cloneNode fragments that contain checked, in WebKit
		if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
			return collection.each(function (index) {
				var self = collection.eq(index);
				if (isFunction) {
					args[0] = value.call(this, index, self.html());
				}
				domManip(self, args, callback, ignored);
			});
		}

		if (l) {
			fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
			first = fragment.firstChild;

			if (fragment.childNodes.length === 1) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if (first || ignored) {
				scripts = jQuery.map(getAll(fragment, "script"), disableScript);
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for (; i < l; i++) {
					node = fragment;

					if (i !== iNoClone) {
						node = jQuery.clone(node, true, true);

						// Keep references to cloned scripts for later restoration
						if (hasScripts) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(scripts, getAll(node, "script"));
						}
					}

					callback.call(collection[i], node, i);
				}

				if (hasScripts) {
					doc = scripts[scripts.length - 1].ownerDocument;

					// Reenable scripts
					jQuery.map(scripts, restoreScript);

					// Evaluate executable scripts on first document insertion
					for (i = 0; i < hasScripts; i++) {
						node = scripts[i];
						if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {

							if (node.src) {

								// Optional AJAX dependency, but won't run scripts if not present
								if (jQuery._evalUrl) {
									jQuery._evalUrl(node.src);
								}
							} else {
								jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove(elem, selector, keepData) {
		var node,
		    nodes = selector ? jQuery.filter(selector, elem) : elem,
		    i = 0;

		for (; (node = nodes[i]) != null; i++) {
			if (!keepData && node.nodeType === 1) {
				jQuery.cleanData(getAll(node));
			}

			if (node.parentNode) {
				if (keepData && jQuery.contains(node.ownerDocument, node)) {
					setGlobalEval(getAll(node, "script"));
				}
				node.parentNode.removeChild(node);
			}
		}

		return elem;
	}

	jQuery.extend({
		htmlPrefilter: function (html) {
			return html.replace(rxhtmlTag, "<$1></$2>");
		},

		clone: function (elem, dataAndEvents, deepDataAndEvents) {
			var i,
			    l,
			    srcElements,
			    destElements,
			    clone = elem.cloneNode(true),
			    inPage = jQuery.contains(elem.ownerDocument, elem);

			// Fix IE cloning issues
			if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);

				for (i = 0, l = srcElements.length; i < l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}

			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);

					for (i = 0, l = srcElements.length; i < l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}

			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage && getAll(elem, "script"));
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function (elems) {
			var data,
			    elem,
			    type,
			    special = jQuery.event.special,
			    i = 0;

			for (; (elem = elems[i]) !== undefined; i++) {
				if (acceptData(elem)) {
					if (data = elem[dataPriv.expando]) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);

									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent(elem, type, data.handle);
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataPriv.expando] = undefined;
					}
					if (elem[dataUser.expando]) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataUser.expando] = undefined;
					}
				}
			}
		}
	});

	jQuery.fn.extend({

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function (selector) {
			return remove(this, selector, true);
		},

		remove: function (selector) {
			return remove(this, selector);
		},

		text: function (value) {
			return access(this, function (value) {
				return value === undefined ? jQuery.text(this) : this.empty().each(function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
			}, null, value, arguments.length);
		},

		append: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},

		prepend: function () {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},

		before: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},

		after: function () {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},

		empty: function () {
			var elem,
			    i = 0;

			for (; (elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {

					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function (dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function () {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},

		html: function (value) {
			return access(this, function (value) {
				var elem = this[0] || {},
				    i = 0,
				    l = this.length;

				if (value === undefined && elem.nodeType === 1) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

					value = jQuery.htmlPrefilter(value);

					try {
						for (; i < l; i++) {
							elem = this[i] || {};

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}

						elem = 0;

						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}

				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},

		replaceWith: function () {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip(this, arguments, function (elem) {
				var parent = this.parentNode;

				if (jQuery.inArray(this, ignored) < 0) {
					jQuery.cleanData(getAll(this));
					if (parent) {
						parent.replaceChild(elem, this);
					}
				}

				// Force callback invocation
			}, ignored);
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (name, original) {
		jQuery.fn[name] = function (selector) {
			var elems,
			    ret = [],
			    insert = jQuery(selector),
			    last = insert.length - 1,
			    i = 0;

			for (; i <= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply(ret, elems.get());
			}

			return this.pushStack(ret);
		};
	});

	var iframe,
	    elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

	/**
  * Retrieve the actual display of a element
  * @param {String} name nodeName of the element
  * @param {Object} doc Document object
  */

	// Called only from within defaultDisplay
	function actualDisplay(name, doc) {
		var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
		    display = jQuery.css(elem[0], "display");

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
  * Try to determine the default display value of an element
  * @param {String} nodeName
  */
	function defaultDisplay(nodeName) {
		var doc = document,
		    display = elemdisplay[nodeName];

		if (!display) {
			display = actualDisplay(nodeName, doc);

			// If the simple way fails, read from inside an iframe
			if (display === "none" || !display) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[0].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay(nodeName, doc);
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[nodeName] = display;
		}

		return display;
	}
	var rmargin = /^margin/;

	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	var getStyles = function (elem) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if (!view || !view.opener) {
			view = window;
		}

		return view.getComputedStyle(elem);
	};

	var swap = function (elem, options, callback, args) {
		var ret,
		    name,
		    old = {};

		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}

		ret = callback.apply(elem, args || []);

		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}

		return ret;
	};

	var documentElement = document.documentElement;

	(function () {
		var pixelPositionVal,
		    boxSizingReliableVal,
		    pixelMarginRightVal,
		    reliableMarginLeftVal,
		    container = document.createElement("div"),
		    div = document.createElement("div");

		// Finish early in limited (non-browser) environments
		if (!div.style) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
		container.appendChild(div);

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild(container);

			var divStyle = window.getComputedStyle(div);
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild(container);
		}

		jQuery.extend(support, {
			pixelPosition: function () {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function () {
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function () {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function () {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function () {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
				    marginDiv = div.appendChild(document.createElement("div"));

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild(container);

				ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);

				documentElement.removeChild(container);
				div.removeChild(marginDiv);

				return ret;
			}
		});
	})();

	function curCSS(elem, name, computed) {
		var width,
		    minWidth,
		    maxWidth,
		    ret,
		    style = elem.style;

		computed = computed || getStyles(elem);
		ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
			ret = jQuery.style(elem, name);
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if (computed) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" : ret;
	}

	function addGetHookIf(conditionFn, hookFn) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function () {
				if (conditionFn()) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}

	var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	    cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},
	    cssPrefixes = ["Webkit", "O", "Moz", "ms"],
	    emptyStyle = document.createElement("div").style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(name) {

		// Shortcut for names that are not vendor prefixed
		if (name in emptyStyle) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
		    i = cssPrefixes.length;

		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in emptyStyle) {
				return name;
			}
		}
	}

	function setPositiveNumber(elem, value, subtract) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec(value);
		return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	}

	function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
		var i = extra === (isBorderBox ? "border" : "content") ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,
		    val = 0;

		for (; i < 4; i += 2) {

			// Both box models exclude margin, so add it if we want it
			if (extra === "margin") {
				val += jQuery.css(elem, extra + cssExpand[i], true, styles);
			}

			if (isBorderBox) {

				// border-box includes padding, so remove it if we want content
				if (extra === "content") {
					val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}

				// At this point, extra isn't border nor margin, so remove border
				if (extra !== "margin") {
					val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

				// At this point, extra isn't content nor padding, so add border
				if (extra !== "padding") {
					val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}

		return val;
	}

	function getWidthOrHeight(elem, name, extra) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
		    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		    styles = getStyles(elem),
		    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if (val <= 0 || val == null) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS(elem, name, styles);
			if (val < 0 || val == null) {
				val = elem.style[name];
			}

			// Computed unit is not pixels. Stop here and return.
			if (rnumnonpx.test(val)) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

			// Normalize "", auto, and prepare for extra
			val = parseFloat(val) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	}

	function showHide(elements, show) {
		var display,
		    elem,
		    hidden,
		    values = [],
		    index = 0,
		    length = elements.length;

		for (; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}

			values[index] = dataPriv.get(elem, "olddisplay");
			display = elem.style.display;
			if (show) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if (!values[index] && display === "none") {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if (elem.style.display === "" && isHidden(elem)) {
					values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
				}
			} else {
				hidden = isHidden(elem);

				if (display !== "none" || !hidden) {
					dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for (index = 0; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}
			if (!show || elem.style.display === "none" || elem.style.display === "") {
				elem.style.display = show ? values[index] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function (elem, computed) {
					if (computed) {

						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function (elem, name, value, extra) {

			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}

			// Make sure that we're working with the right name
			var ret,
			    type,
			    hooks,
			    origName = jQuery.camelCase(name),
			    style = elem.style;

			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
					value = adjustCSS(elem, name, ret);

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if (type === "number") {
					value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
					style[name] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

					style[name] = value;
				}
			} else {

				// If a hook was provided get the non-computed value from there
				if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[name];
			}
		},

		css: function (elem, name, extra, styles) {
			var val,
			    num,
			    hooks,
			    origName = jQuery.camelCase(name);

			// Make sure that we're working with the right name
			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// If a hook was provided get the computed value from there
			if (hooks && "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}

			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}

			// Convert "normal" to computed value
			if (val === "normal" && name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || isFinite(num) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each(["height", "width"], function (i, name) {
		jQuery.cssHooks[name] = {
			get: function (elem, computed, extra) {
				if (computed) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function () {
						return getWidthOrHeight(elem, name, extra);
					}) : getWidthOrHeight(elem, name, extra);
				}
			},

			set: function (elem, value, extra) {
				var matches,
				    styles = extra && getStyles(elem),
				    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

				// Convert to pixels if value adjustment is needed
				if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {

					elem.style[name] = value;
					value = jQuery.css(elem, name);
				}

				return setPositiveNumber(elem, value, subtract);
			}
		};
	});

	jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
		if (computed) {
			return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
				return elem.getBoundingClientRect().left;
			})) + "px";
		}
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
		if (computed) {
			return swap(elem, { "display": "inline-block" }, curCSS, [elem, "marginRight"]);
		}
	});

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function (value) {
				var i = 0,
				    expanded = {},


				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value];

				for (; i < 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
				}

				return expanded;
			}
		};

		if (!rmargin.test(prefix)) {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function (name, value) {
			return access(this, function (elem, name, value) {
				var styles,
				    len,
				    map = {},
				    i = 0;

				if (jQuery.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;

					for (; i < len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}

					return map;
				}

				return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		},
		show: function () {
			return showHide(this, true);
		},
		hide: function () {
			return showHide(this);
		},
		toggle: function (state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}

			return this.each(function () {
				if (isHidden(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function (elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function () {
			var hooks = Tween.propHooks[this.prop];

			return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
		},
		run: function (percent) {
			var eased,
			    hooks = Tween.propHooks[this.prop];

			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;

			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}

			if (hooks && hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function (tween) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
					return tween.elem[tween.prop];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function (tween) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function (tween) {
			if (tween.elem.nodeType && tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function (p) {
			return p;
		},
		swing: function (p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};

	var fxNow,
	    timerId,
	    rfxtypes = /^(?:toggle|show|hide)$/,
	    rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout(function () {
			fxNow = undefined;
		});
		return fxNow = jQuery.now();
	}

	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
		    i = 0,
		    attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i < 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}

		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
		    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
		    index = 0,
		    length = collection.length;
		for (; index < length; index++) {
			if (tween = collection[index].call(animation, prop, value)) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		/* jshint validthis: true */
		var prop,
		    value,
		    toggle,
		    tween,
		    hooks,
		    oldfire,
		    display,
		    checkDisplay,
		    anim = this,
		    orig = {},
		    style = elem.style,
		    hidden = elem.nodeType && isHidden(elem),
		    dataShow = dataPriv.get(elem, "fxshow");

		// Handle queue: false promises
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function () {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function () {

				// Ensure the complete handler is called before this completes
				anim.always(function () {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if (elem.nodeType === 1 && ("height" in props || "width" in props)) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css(elem, "display");

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

			if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
				style.display = "inline-block";
			}
		}

		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function () {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}

		// show/hide pass
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.exec(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if (value === "show" && dataShow && dataShow[prop] !== undefined) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

				// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if (!jQuery.isEmptyObject(orig)) {
			if (dataShow) {
				if ("hidden" in dataShow) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access(elem, "fxshow", {});
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if (toggle) {
				dataShow.hidden = !hidden;
			}
			if (hidden) {
				jQuery(elem).show();
			} else {
				anim.done(function () {
					jQuery(elem).hide();
				});
			}
			anim.done(function () {
				var prop;

				dataPriv.remove(elem, "fxshow");
				for (prop in orig) {
					jQuery.style(elem, prop, orig[prop]);
				}
			});
			for (prop in orig) {
				tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

				if (!(prop in dataShow)) {
					dataShow[prop] = tween.start;
					if (hidden) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

			// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
			style.display = display;
		}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = jQuery.camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (jQuery.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}

			if (index !== name) {
				props[name] = value;
				delete props[index];
			}

			hooks = jQuery.cssHooks[name];
			if (hooks && "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
		    stopped,
		    index = 0,
		    length = Animation.prefilters.length,
		    deferred = jQuery.Deferred().always(function () {

			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		    tick = function () {
			if (stopped) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
			    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),


			// Support: Android 2.3
			// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
			temp = remaining / animation.duration || 0,
			    percent = 1 - temp,
			    index = 0,
			    length = animation.tweens.length;

			for (; index < length; index++) {
				animation.tweens[index].run(percent);
			}

			deferred.notifyWith(elem, [animation, percent, remaining]);

			if (percent < 1 && length) {
				return remaining;
			} else {
				deferred.resolveWith(elem, [animation]);
				return false;
			}
		},
		    animation = deferred.promise({
			elem: elem,
			props: jQuery.extend({}, properties),
			opts: jQuery.extend(true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function (prop, end) {
				var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
				animation.tweens.push(tween);
				return tween;
			},
			stop: function (gotoEnd) {
				var index = 0,


				// If we are going to the end, we want to run all the tweens
				// otherwise we skip this part
				length = gotoEnd ? animation.tweens.length : 0;
				if (stopped) {
					return this;
				}
				stopped = true;
				for (; index < length; index++) {
					animation.tweens[index].run(1);
				}

				// Resolve when we played the last frame; otherwise, reject
				if (gotoEnd) {
					deferred.notifyWith(elem, [animation, 1, 0]);
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} else {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				return this;
			}
		}),
		    props = animation.props;

		propFilter(props, animation.opts.specialEasing);

		for (; index < length; index++) {
			result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				if (jQuery.isFunction(result.stop)) {
					jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
				}
				return result;
			}
		}

		jQuery.map(props, createTween, animation);

		if (jQuery.isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}

		jQuery.fx.timer(jQuery.extend(tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		}));

		// attach callbacks from options
		return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	}

	jQuery.Animation = jQuery.extend(Animation, {
		tweeners: {
			"*": [function (prop, value) {
				var tween = this.createTween(prop, value);
				adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
				return tween;
			}]
		},

		tweener: function (props, callback) {
			if (jQuery.isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.match(rnotwhite);
			}

			var prop,
			    index = 0,
			    length = props.length;

			for (; index < length; index++) {
				prop = props[index];
				Animation.tweeners[prop] = Animation.tweeners[prop] || [];
				Animation.tweeners[prop].unshift(callback);
			}
		},

		prefilters: [defaultPrefilter],

		prefilter: function (callback, prepend) {
			if (prepend) {
				Animation.prefilters.unshift(callback);
			} else {
				Animation.prefilters.push(callback);
			}
		}
	});

	jQuery.speed = function (speed, easing, fn) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function () {
			if (jQuery.isFunction(opt.old)) {
				opt.old.call(this);
			}

			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function (speed, to, easing, callback) {

			// Show any hidden elements after setting opacity to 0
			return this.filter(isHidden).css("opacity", 0).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
		},
		animate: function (prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
			    optall = jQuery.speed(speed, easing, callback),
			    doAnimation = function () {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Empty animations, or finishing resolves immediately
				if (empty || dataPriv.get(this, "finish")) {
					anim.stop(true);
				}
			};
			doAnimation.finish = doAnimation;

			return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
		},
		stop: function (type, clearQueue, gotoEnd) {
			var stopQueue = function (hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};

			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue && type !== false) {
				this.queue(type || "fx", []);
			}

			return this.each(function () {
				var dequeue = true,
				    index = type != null && type + "queueHooks",
				    timers = jQuery.timers,
				    data = dataPriv.get(this);

				if (index) {
					if (data[index] && data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] && data[index].stop && rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}

				for (index = timers.length; index--;) {
					if (timers[index].elem === this && (type == null || timers[index].queue === type)) {

						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function (type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function () {
				var index,
				    data = dataPriv.get(this),
				    queue = data[type + "queue"],
				    hooks = data[type + "queueHooks"],
				    timers = jQuery.timers,
				    length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue(this, type, []);

				if (hooks && hooks.stop) {
					hooks.stop.call(this, true);
				}

				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this && timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}

				// Look for any animations in the old queue and finish them
				for (index = 0; index < length; index++) {
					if (queue[index] && queue[index].finish) {
						queue[index].finish.call(this);
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each(["toggle", "show", "hide"], function (i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function (speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function (name, props) {
		jQuery.fn[name] = function (speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function () {
		var timer,
		    i = 0,
		    timers = jQuery.timers;

		fxNow = jQuery.now();

		for (; i < timers.length; i++) {
			timer = timers[i];

			// Checks the timer has not already been removed
			if (!timer() && timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}

		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function (timer) {
		jQuery.timers.push(timer);
		if (timer()) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function () {
		if (!timerId) {
			timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
		}
	};

	jQuery.fx.stop = function () {
		window.clearInterval(timerId);

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function (time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue(type, function (next, hooks) {
			var timeout = window.setTimeout(next, time);
			hooks.stop = function () {
				window.clearTimeout(timeout);
			};
		});
	};

	(function () {
		var input = document.createElement("input"),
		    select = document.createElement("select"),
		    opt = select.appendChild(document.createElement("option"));

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();

	var boolHook,
	    attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function (name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},

		removeAttr: function (name) {
			return this.each(function () {
				jQuery.removeAttr(this, name);
			});
		}
	});

	jQuery.extend({
		attr: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if (typeof elem.getAttribute === "undefined") {
				return jQuery.prop(elem, name, value);
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
			}

			if (value !== undefined) {
				if (value === null) {
					jQuery.removeAttr(elem, name);
					return;
				}

				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				elem.setAttribute(name, value + "");
				return value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			ret = jQuery.find.attr(elem, name);

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function (elem, value) {
					if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function (elem, value) {
			var name,
			    propName,
			    i = 0,
			    attrNames = value && value.match(rnotwhite);

			if (attrNames && elem.nodeType === 1) {
				while (name = attrNames[i++]) {
					propName = jQuery.propFix[name] || name;

					// Boolean attributes get special treatment (#10870)
					if (jQuery.expr.match.bool.test(name)) {

						// Set corresponding property to false
						elem[propName] = false;
					}

					elem.removeAttribute(name);
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function (elem, value, name) {
			if (value === false) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};
	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;

		attrHandle[name] = function (elem, name, isXML) {
			var ret, handle;
			if (!isXML) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[name];
				attrHandle[name] = ret;
				ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
				attrHandle[name] = handle;
			}
			return ret;
		};
	});

	var rfocusable = /^(?:input|select|textarea|button)$/i,
	    rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend({
		prop: function (name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},

		removeProp: function (name) {
			return this.each(function () {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});

	jQuery.extend({
		prop: function (elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}

			if (value !== undefined) {
				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				return elem[name] = value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			return elem[name];
		},

		propHooks: {
			tabIndex: {
				get: function (elem) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr(elem, "tabindex");

					return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function (elem) {
				var parent = elem.parentNode;
				if (parent && parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function (elem) {
				var parent = elem.parentNode;
				if (parent) {
					parent.selectedIndex;

					if (parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		jQuery.propFix[this.toLowerCase()] = this;
	});

	var rclass = /[\t\r\n\f]/g;

	function getClass(elem) {
		return elem.getAttribute && elem.getAttribute("class") || "";
	}

	jQuery.fn.extend({
		addClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).addClass(value.call(this, j, getClass(this)));
				});
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							if (cur.indexOf(" " + clazz + " ") < 0) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		removeClass: function (value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).removeClass(value.call(this, j, getClass(this)));
				});
			}

			if (!arguments.length) {
				return this.attr("class", "");
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {

							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") > -1) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		toggleClass: function (value, stateVal) {
			var type = typeof value;

			if (typeof stateVal === "boolean" && type === "string") {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}

			if (jQuery.isFunction(value)) {
				return this.each(function (i) {
					jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
				});
			}

			return this.each(function () {
				var className, i, self, classNames;

				if (type === "string") {

					// Toggle individual class names
					i = 0;
					self = jQuery(this);
					classNames = value.match(rnotwhite) || [];

					while (className = classNames[i++]) {

						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}

					// Toggle whole class name
				} else if (value === undefined || type === "boolean") {
					className = getClass(this);
					if (className) {

						// Store className if set
						dataPriv.set(this, "__className__", className);
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if (this.setAttribute) {
						this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
					}
				}
			});
		},

		hasClass: function (selector) {
			var className,
			    elem,
			    i = 0;

			className = " " + selector + " ";
			while (elem = this[i++]) {
				if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
					return true;
				}
			}

			return false;
		}
	});

	var rreturn = /\r/g,
	    rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend({
		val: function (value) {
			var hooks,
			    ret,
			    isFunction,
			    elem = this[0];

			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

					if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace(rreturn, "") :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction(value);

			return this.each(function (i) {
				var val;

				if (this.nodeType !== 1) {
					return;
				}

				if (isFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (jQuery.isArray(val)) {
					val = jQuery.map(val, function (value) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function (elem) {

					var val = jQuery.find.attr(elem, "value");
					return val != null ? val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
				}
			},
			select: {
				get: function (elem) {
					var value,
					    option,
					    options = elem.options,
					    index = elem.selectedIndex,
					    one = elem.type === "select-one" || index < 0,
					    values = one ? null : [],
					    max = one ? index + 1 : options.length,
					    i = index < 0 ? max : one ? index : 0;

					// Loop through all the selected options
					for (; i < max; i++) {
						option = options[i];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) && (

						// Don't return options that are disabled or in a disabled optgroup
						support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if (one) {
								return value;
							}

							// Multi-Selects return an array
							values.push(value);
						}
					}

					return values;
				},

				set: function (elem, value) {
					var optionSet,
					    option,
					    options = elem.options,
					    values = jQuery.makeArray(value),
					    i = options.length;

					while (i--) {
						option = options[i];
						if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function () {
		jQuery.valHooks[this] = {
			set: function (elem, value) {
				if (jQuery.isArray(value)) {
					return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function (elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});

	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend(jQuery.event, {

		trigger: function (event, data, elem, onlyHandlers) {

			var i,
			    cur,
			    tmp,
			    bubbleType,
			    ontype,
			    handle,
			    special,
			    eventPath = [elem || document],
			    type = hasOwn.call(event, "type") ? event.type : event,
			    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}

			if (type.indexOf(".") > -1) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : jQuery.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

				event.type = i > 1 ? bubbleType : special.bindType || type;

				// jQuery handler
				handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype && cur[ontype];
				if (handle && handle.apply && acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {

				if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[type]();
						jQuery.event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function (type, elem, event) {
			var e = jQuery.extend(new jQuery.Event(), event, {
				type: type,
				isSimulated: true
			});

			jQuery.event.trigger(e, null, elem);
		}

	});

	jQuery.fn.extend({

		trigger: function (type, data) {
			return this.each(function () {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function (type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});

	jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

		// Handle event binding
		jQuery.fn[name] = function (data, fn) {
			return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
		};
	});

	jQuery.fn.extend({
		hover: function (fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		}
	});

	support.focusin = "onfocusin" in window;

	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if (!support.focusin) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function (event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
			};

			jQuery.event.special[fix] = {
				setup: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix);

					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					dataPriv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function () {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix) - 1;

					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						dataPriv.remove(doc, fix);
					} else {
						dataPriv.access(doc, fix, attaches);
					}
				}
			};
		});
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = /\?/;

	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function (data) {
		return JSON.parse(data + "");
	};

	// Cross-browser xml parsing
	jQuery.parseXML = function (data) {
		var xml;
		if (!data || typeof data !== "string") {
			return null;
		}

		// Support: IE9
		try {
			xml = new window.DOMParser().parseFromString(data, "text/xml");
		} catch (e) {
			xml = undefined;
		}

		if (!xml || xml.getElementsByTagName("parsererror").length) {
			jQuery.error("Invalid XML: " + data);
		}
		return xml;
	};

	var rhash = /#.*$/,
	    rts = /([?&])_=[^&]*/,
	    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,


	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	    rnoContent = /^(?:GET|HEAD)$/,
	    rprotocol = /^\/\//,


	/* Prefilters
  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  * 2) These are called:
  *    - BEFORE asking for a transport
  *    - AFTER param serialization (s.data is a string if s.processData is true)
  * 3) key is the dataType
  * 4) the catchall symbol "*" can be used
  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  */
	prefilters = {},


	/* Transports bindings
  * 1) key is the dataType
  * 2) the catchall symbol "*" can be used
  * 3) selection will start with transport dataType and THEN go to "*" if needed
  */
	transports = {},


	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*"),


	// Anchor tag for parsing the document origin
	originAnchor = document.createElement("a");
	originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {

		// dataTypeExpression is optional and defaults to "*"
		return function (dataTypeExpression, func) {

			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
			    i = 0,
			    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

			if (jQuery.isFunction(func)) {

				// For each dataType in the dataTypeExpression
				while (dataType = dataTypes[i++]) {

					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);

						// Otherwise append
					} else {
						(structure[dataType] = structure[dataType] || []).push(func);
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

		var inspected = {},
		    seekingTransport = structure === transports;

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {

					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}

		return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key,
		    deep,
		    flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}

		return target;
	}

	/* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
	function ajaxHandleResponses(s, jqXHR, responses) {

		var ct,
		    type,
		    finalDataType,
		    firstDataType,
		    contents = s.contents,
		    dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] && contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {

			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}

	/* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2,
		    current,
		    conv,
		    tmp,
		    prev,
		    converters = {},


		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while (current) {

			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}

			// Apply the dataFilter if provided
			if (!prev && isSuccess && s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}

			prev = current;
			current = dataTypes.shift();

			if (current) {

				// There's only work to do if current dataType is non-auto
				if (current === "*") {

					current = prev;

					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" && prev !== current) {

					// Seek a direct converter
					conv = converters[prev + " " + current] || converters["* " + current];

					// If none found, seek a pair
					if (!conv) {
						for (conv2 in converters) {

							// If conv2 outputs current
							tmp = conv2.split(" ");
							if (tmp[1] === current) {

								// If prev can be converted to accepted input
								conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
								if (conv) {

									// Condense equivalence converters
									if (conv === true) {
										conv = converters[conv2];

										// Otherwise, insert the intermediate dataType
									} else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if (conv !== true) {

						// Unless errors are allowed to bubble, catch and return them
						if (conv && s.throws) {
							response = conv(response);
						} else {
							try {
								response = conv(response);
							} catch (e) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test(location.protocol),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function (target, settings) {
			return settings ?

			// Building a settings object
			ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

			// Extending ajaxSettings
			ajaxExtend(jQuery.ajaxSettings, target);
		},

		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),

		// Main method
		ajax: function (url, options) {

			// If url is an object, simulate pre-1.5 signature
			if (typeof url === "object") {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,


			// URL without anti-cache param
			cacheURL,


			// Response headers
			responseHeadersString,
			    responseHeaders,


			// timeout handle
			timeoutTimer,


			// Url cleanup var
			urlAnchor,


			// To know if global events are to be dispatched
			fireGlobals,


			// Loop variable
			i,


			// Create the final options object
			s = jQuery.ajaxSetup({}, options),


			// Callbacks context
			callbackContext = s.context || s,


			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,


			// Deferreds
			deferred = jQuery.Deferred(),
			    completeDeferred = jQuery.Callbacks("once memory"),


			// Status-dependent callbacks
			statusCode = s.statusCode || {},


			// Headers (they are sent all at once)
			requestHeaders = {},
			    requestHeadersNames = {},


			// The jqXHR state
			state = 0,


			// Default abort message
			strAbort = "canceled",


			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function (key) {
					var match;
					if (state === 2) {
						if (!responseHeaders) {
							responseHeaders = {};
							while (match = rheaders.exec(responseHeadersString)) {
								responseHeaders[match[1].toLowerCase()] = match[2];
							}
						}
						match = responseHeaders[key.toLowerCase()];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function () {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function (name, value) {
					var lname = name.toLowerCase();
					if (!state) {
						name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
						requestHeaders[name] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function (type) {
					if (!state) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function (map) {
					var code;
					if (map) {
						if (state < 2) {
							for (code in map) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[code] = [statusCode[code], map[code]];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always(map[jqXHR.status]);
						}
					}
					return this;
				},

				// Cancel the request
				abort: function (statusText) {
					var finalText = statusText || strAbort;
					if (transport) {
						transport.abort(finalText);
					}
					done(0, finalText);
					return this;
				}
			};

			// Attach deferreds
			deferred.promise(jqXHR).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if (s.crossDomain == null) {
				urlAnchor = document.createElement("a");

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
				} catch (e) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if (s.data && s.processData && typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}

			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

			// If request was aborted inside a prefilter, stop there
			if (state === 2) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if (fireGlobals && jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if (!s.hasContent) {

				// If data is available, append data to url
				if (s.data) {
					cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if (s.cache === false) {
					s.url = rts.test(cacheURL) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace(rts, "$1_=" + nonce++) :

					// Otherwise add one to the end
					cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}

			// Set the correct header, if data is being sent
			if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}

			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for (i in { success: 1, error: 1, complete: 1 }) {
				jqXHR[i](s[i]);
			}

			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}

				// If request was aborted inside ajaxSend, stop there
				if (state === 2) {
					return jqXHR;
				}

				// Timeout
				if (s.async && s.timeout > 0) {
					timeoutTimer = window.setTimeout(function () {
						jqXHR.abort("timeout");
					}, s.timeout);
				}

				try {
					state = 1;
					transport.send(requestHeaders, done);
				} catch (e) {

					// Propagate exception as error if not done
					if (state < 2) {
						done(-1, e);

						// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess,
				    success,
				    error,
				    response,
				    modified,
				    statusText = nativeStatusText;

				// Called once
				if (state === 2) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if (timeoutTimer) {
					window.clearTimeout(timeoutTimer);
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);

				// If successful, handle type chaining
				if (isSuccess) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}

					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";

						// if not modified
					} else if (status === 304) {
						statusText = "notmodified";

						// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status < 0) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";

				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}

				// Status-dependent callbacks
				jqXHR.statusCode(statusCode);
				statusCode = undefined;

				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
				}

				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

					// Handle the global AJAX counter
					if (! --jQuery.active) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function (url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},

		getScript: function (url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});

	jQuery.each(["get", "post"], function (i, method) {
		jQuery[method] = function (url, data, callback, type) {

			// Shift arguments if data argument was omitted
			if (jQuery.isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax(jQuery.extend({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject(url) && url));
		};
	});

	jQuery._evalUrl = function (url) {
		return jQuery.ajax({
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};

	jQuery.fn.extend({
		wrapAll: function (html) {
			var wrap;

			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapAll(html.call(this, i));
				});
			}

			if (this[0]) {

				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}

				wrap.map(function () {
					var elem = this;

					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append(this);
			}

			return this;
		},

		wrapInner: function (html) {
			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}

			return this.each(function () {
				var self = jQuery(this),
				    contents = self.contents();

				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},

		wrap: function (html) {
			var isFunction = jQuery.isFunction(html);

			return this.each(function (i) {
				jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
			});
		},

		unwrap: function () {
			return this.parent().each(function () {
				if (!jQuery.nodeName(this, "body")) {
					jQuery(this).replaceWith(this.childNodes);
				}
			}).end();
		}
	});

	jQuery.expr.filters.hidden = function (elem) {
		return !jQuery.expr.filters.visible(elem);
	};
	jQuery.expr.filters.visible = function (elem) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};

	var r20 = /%20/g,
	    rbracket = /\[\]$/,
	    rCRLF = /\r?\n/g,
	    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	    rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;

		if (jQuery.isArray(obj)) {

			// Serialize array item.
			jQuery.each(obj, function (i, v) {
				if (traditional || rbracket.test(prefix)) {

					// Treat each array item as a scalar.
					add(prefix, v);
				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
				}
			});
		} else if (!traditional && jQuery.type(obj) === "object") {

			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {

			// Serialize scalar item.
			add(prefix, obj);
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function (a, traditional) {
		var prefix,
		    s = [],
		    add = function (key, value) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
			s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
		};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if (traditional === undefined) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {

			// Serialize the form elements
			jQuery.each(a, function () {
				add(this.name, this.value);
			});
		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}

		// Return the resulting serialization
		return s.join("&").replace(r20, "+");
	};

	jQuery.fn.extend({
		serialize: function () {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function () {
			return this.map(function () {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function () {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
			}).map(function (i, elem) {
				var val = jQuery(this).val();

				return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
					return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
				}) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
			}).get();
		}
	});

	jQuery.ajaxSettings.xhr = function () {
		try {
			return new window.XMLHttpRequest();
		} catch (e) {}
	};

	var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	    xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function (options) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported && !options.crossDomain) {
			return {
				send: function (headers, complete) {
					var i,
					    xhr = options.xhr();

					xhr.open(options.type, options.url, options.async, options.username, options.password);

					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}

					// Override mime type if needed
					if (options.mimeType && xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain && !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}

					// Callback
					callback = function (type) {
						return function () {
							if (callback) {
								callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if (typeof xhr.status !== "number") {
										complete(0, "error");
									} else {
										complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status, xhr.statusText);
									}
								} else {
									complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback("error");

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if (xhr.onabort !== undefined) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function () {

							// Check readyState before timeout as it changes
							if (xhr.readyState === 4) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout(function () {
									if (callback) {
										errorCallback();
									}
								});
							}
						};
					}

					// Create the abort callback
					callback = callback("abort");

					try {

						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent && options.data || null);
					} catch (e) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (callback) {
							throw e;
						}
					}
				},

				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function (text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function (s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function (s) {

		// This transport only deals with cross domain requests
		if (s.crossDomain) {
			var script, callback;
			return {
				send: function (_, complete) {
					script = jQuery("<script>").prop({
						charset: s.scriptCharset,
						src: s.url
					}).on("load error", callback = function (evt) {
						script.remove();
						callback = null;
						if (evt) {
							complete(evt.type === "error" ? 404 : 200, evt.type);
						}
					});

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild(script[0]);
				},
				abort: function () {
					if (callback) {
						callback();
					}
				}
			};
		}
	});

	var oldCallbacks = [],
	    rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function () {
			var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
			this[callback] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

		var callbackName,
		    overwritten,
		    responseContainer,
		    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function () {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};

			// Force json dataType
			s.dataTypes[0] = "json";

			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function () {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function () {

				// If previous value didn't exist - remove it
				if (overwritten === undefined) {
					jQuery(window).removeProp(callbackName);

					// Otherwise restore preexisting value
				} else {
					window[callbackName] = overwritten;
				}

				// Save back as free
				if (s[callbackName]) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push(callbackName);
				}

				// Call if it was a function and we have a response
				if (responseContainer && jQuery.isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});

	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function (data, context, keepScripts) {
		if (!data || typeof data !== "string") {
			return null;
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec(data),
		    scripts = !keepScripts && [];

		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}

		parsed = buildFragment([data], context, scripts);

		if (scripts && scripts.length) {
			jQuery(scripts).remove();
		}

		return jQuery.merge([], parsed.childNodes);
	};

	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
  * Load a url into a page
  */
	jQuery.fn.load = function (url, params, callback) {
		if (typeof url !== "string" && _load) {
			return _load.apply(this, arguments);
		}

		var selector,
		    type,
		    response,
		    self = this,
		    off = url.indexOf(" ");

		if (off > -1) {
			selector = jQuery.trim(url.slice(off));
			url = url.slice(0, off);
		}

		// If it's a function
		if (jQuery.isFunction(params)) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

			// Otherwise, build a param string
		} else if (params && typeof params === "object") {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			}).done(function (responseText) {

				// Save response for use in complete callback
				response = arguments;

				self.html(selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

				// Otherwise use the full result
				responseText);

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
			}).always(callback && function (jqXHR, status) {
				self.each(function () {
					callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
				});
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
		jQuery.fn[type] = function (fn) {
			return this.on(type, fn);
		};
	});

	jQuery.expr.filters.animated = function (elem) {
		return jQuery.grep(jQuery.timers, function (fn) {
			return elem === fn.elem;
		}).length;
	};

	/**
  * Gets a window from an element
  */
	function getWindow(elem) {
		return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function (elem, options, i) {
			var curPosition,
			    curLeft,
			    curCSSTop,
			    curTop,
			    curOffset,
			    curCSSLeft,
			    calculatePosition,
			    position = jQuery.css(elem, "position"),
			    curElem = jQuery(elem),
			    props = {};

			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}

			if (jQuery.isFunction(options)) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call(elem, i, jQuery.extend({}, curOffset));
			}

			if (options.top != null) {
				props.top = options.top - curOffset.top + curTop;
			}
			if (options.left != null) {
				props.left = options.left - curOffset.left + curLeft;
			}

			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};

	jQuery.fn.extend({
		offset: function (options) {
			if (arguments.length) {
				return options === undefined ? this : this.each(function (i) {
					jQuery.offset.setOffset(this, options, i);
				});
			}

			var docElem,
			    win,
			    elem = this[0],
			    box = { top: 0, left: 0 },
			    doc = elem && elem.ownerDocument;

			if (!doc) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if (!jQuery.contains(docElem, elem)) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow(doc);
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function () {
			if (!this[0]) {
				return;
			}

			var offsetParent,
			    offset,
			    elem = this[0],
			    parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if (jQuery.css(elem, "position") === "fixed") {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if (!jQuery.nodeName(offsetParent[0], "html")) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
				parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function () {
			return this.map(function () {
				var offsetParent = this.offsetParent;

				while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
		var top = "pageYOffset" === prop;

		jQuery.fn[method] = function (val) {
			return access(this, function (elem, method, val) {
				var win = getWindow(elem);

				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}

				if (win) {
					win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length);
		};
	});

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function (i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
			if (computed) {
				computed = curCSS(elem, prop);

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
			}
		});
	});

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
		jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function (margin, value) {
				var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
				    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

				return access(this, function (elem, type, value) {
					var doc;

					if (jQuery.isWindow(elem)) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement["client" + name];
					}

					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
					}

					return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, extra) :

					// Set width or height on the element
					jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable, null);
			};
		});
	});

	jQuery.fn.extend({

		bind: function (types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function (types, fn) {
			return this.off(types, null, fn);
		},

		delegate: function (selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function (selector, types, fn) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
		},
		size: function () {
			return this.length;
		}
	});

	jQuery.fn.andSelf = jQuery.fn.addBack;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ("function" === "function" && true) {
		System.registerDynamic("npm:jquery@2.2.4/dist/jquery.js", [], false, function ($__require, $__exports, $__module) {
			return (function () {
				return jQuery;
			}).call(this);
		});
	}

	var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,


	// Map over the $ in case of overwrite
	_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if (!noGlobal) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
});
System.registerDynamic("github:twitter/typeahead.js@0.11.1.json", [], true, function() {
  return {
    "main": "dist/typeahead.bundle.js",
    "meta": {
      "dist/typeahead.bundle.js": {
        "deps": [
          "jquery"
        ],
        "format": "global"
      }
    }
  };
});

System.registerDynamic("github:twitter/typeahead.js@0.11.1/dist/typeahead.bundle.js", ["jquery"], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = System.registry.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        /*!
         * typeahead.js 0.11.1
         * https://github.com/twitter/typeahead.js
         * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
         */

        (function (root, factory) {
            if (typeof define === "function" && define.amd) {
                define("bloodhound", ["jquery"], function (a0) {
                    return root["Bloodhound"] = factory(a0);
                });
            } else if (typeof exports === "object") {
                module.exports = factory(require("jquery"));
            } else {
                root["Bloodhound"] = factory(jQuery);
            }
        })(this, function ($) {
            var _ = function () {
                "use strict";

                return {
                    isMsie: function () {
                        return (/(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false
                        );
                    },
                    isBlankString: function (str) {
                        return !str || /^\s*$/.test(str);
                    },
                    escapeRegExChars: function (str) {
                        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
                    },
                    isString: function (obj) {
                        return typeof obj === "string";
                    },
                    isNumber: function (obj) {
                        return typeof obj === "number";
                    },
                    isArray: $.isArray,
                    isFunction: $.isFunction,
                    isObject: $.isPlainObject,
                    isUndefined: function (obj) {
                        return typeof obj === "undefined";
                    },
                    isElement: function (obj) {
                        return !!(obj && obj.nodeType === 1);
                    },
                    isJQuery: function (obj) {
                        return obj instanceof $;
                    },
                    toStr: function toStr(s) {
                        return _.isUndefined(s) || s === null ? "" : s + "";
                    },
                    bind: $.proxy,
                    each: function (collection, cb) {
                        $.each(collection, reverseArgs);
                        function reverseArgs(index, value) {
                            return cb(value, index);
                        }
                    },
                    map: $.map,
                    filter: $.grep,
                    every: function (obj, test) {
                        var result = true;
                        if (!obj) {
                            return result;
                        }
                        $.each(obj, function (key, val) {
                            if (!(result = test.call(null, val, key, obj))) {
                                return false;
                            }
                        });
                        return !!result;
                    },
                    some: function (obj, test) {
                        var result = false;
                        if (!obj) {
                            return result;
                        }
                        $.each(obj, function (key, val) {
                            if (result = test.call(null, val, key, obj)) {
                                return false;
                            }
                        });
                        return !!result;
                    },
                    mixin: $.extend,
                    identity: function (x) {
                        return x;
                    },
                    clone: function (obj) {
                        return $.extend(true, {}, obj);
                    },
                    getIdGenerator: function () {
                        var counter = 0;
                        return function () {
                            return counter++;
                        };
                    },
                    templatify: function templatify(obj) {
                        return $.isFunction(obj) ? obj : template;
                        function template() {
                            return String(obj);
                        }
                    },
                    defer: function (fn) {
                        setTimeout(fn, 0);
                    },
                    debounce: function (func, wait, immediate) {
                        var timeout, result;
                        return function () {
                            var context = this,
                                args = arguments,
                                later,
                                callNow;
                            later = function () {
                                timeout = null;
                                if (!immediate) {
                                    result = func.apply(context, args);
                                }
                            };
                            callNow = immediate && !timeout;
                            clearTimeout(timeout);
                            timeout = setTimeout(later, wait);
                            if (callNow) {
                                result = func.apply(context, args);
                            }
                            return result;
                        };
                    },
                    throttle: function (func, wait) {
                        var context, args, timeout, result, previous, later;
                        previous = 0;
                        later = function () {
                            previous = new Date();
                            timeout = null;
                            result = func.apply(context, args);
                        };
                        return function () {
                            var now = new Date(),
                                remaining = wait - (now - previous);
                            context = this;
                            args = arguments;
                            if (remaining <= 0) {
                                clearTimeout(timeout);
                                timeout = null;
                                previous = now;
                                result = func.apply(context, args);
                            } else if (!timeout) {
                                timeout = setTimeout(later, remaining);
                            }
                            return result;
                        };
                    },
                    stringify: function (val) {
                        return _.isString(val) ? val : JSON.stringify(val);
                    },
                    noop: function () {}
                };
            }();
            var VERSION = "0.11.1";
            var tokenizers = function () {
                "use strict";

                return {
                    nonword: nonword,
                    whitespace: whitespace,
                    obj: {
                        nonword: getObjTokenizer(nonword),
                        whitespace: getObjTokenizer(whitespace)
                    }
                };
                function whitespace(str) {
                    str = _.toStr(str);
                    return str ? str.split(/\s+/) : [];
                }
                function nonword(str) {
                    str = _.toStr(str);
                    return str ? str.split(/\W+/) : [];
                }
                function getObjTokenizer(tokenizer) {
                    return function setKey(keys) {
                        keys = _.isArray(keys) ? keys : [].slice.call(arguments, 0);
                        return function tokenize(o) {
                            var tokens = [];
                            _.each(keys, function (k) {
                                tokens = tokens.concat(tokenizer(_.toStr(o[k])));
                            });
                            return tokens;
                        };
                    };
                }
            }();
            var LruCache = function () {
                "use strict";

                function LruCache(maxSize) {
                    this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
                    this.reset();
                    if (this.maxSize <= 0) {
                        this.set = this.get = $.noop;
                    }
                }
                _.mixin(LruCache.prototype, {
                    set: function set(key, val) {
                        var tailItem = this.list.tail,
                            node;
                        if (this.size >= this.maxSize) {
                            this.list.remove(tailItem);
                            delete this.hash[tailItem.key];
                            this.size--;
                        }
                        if (node = this.hash[key]) {
                            node.val = val;
                            this.list.moveToFront(node);
                        } else {
                            node = new Node(key, val);
                            this.list.add(node);
                            this.hash[key] = node;
                            this.size++;
                        }
                    },
                    get: function get(key) {
                        var node = this.hash[key];
                        if (node) {
                            this.list.moveToFront(node);
                            return node.val;
                        }
                    },
                    reset: function reset() {
                        this.size = 0;
                        this.hash = {};
                        this.list = new List();
                    }
                });
                function List() {
                    this.head = this.tail = null;
                }
                _.mixin(List.prototype, {
                    add: function add(node) {
                        if (this.head) {
                            node.next = this.head;
                            this.head.prev = node;
                        }
                        this.head = node;
                        this.tail = this.tail || node;
                    },
                    remove: function remove(node) {
                        node.prev ? node.prev.next = node.next : this.head = node.next;
                        node.next ? node.next.prev = node.prev : this.tail = node.prev;
                    },
                    moveToFront: function (node) {
                        this.remove(node);
                        this.add(node);
                    }
                });
                function Node(key, val) {
                    this.key = key;
                    this.val = val;
                    this.prev = this.next = null;
                }
                return LruCache;
            }();
            var PersistentStorage = function () {
                "use strict";

                var LOCAL_STORAGE;
                try {
                    LOCAL_STORAGE = window.localStorage;
                    LOCAL_STORAGE.setItem("~~~", "!");
                    LOCAL_STORAGE.removeItem("~~~");
                } catch (err) {
                    LOCAL_STORAGE = null;
                }
                function PersistentStorage(namespace, override) {
                    this.prefix = ["__", namespace, "__"].join("");
                    this.ttlKey = "__ttl__";
                    this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
                    this.ls = override || LOCAL_STORAGE;
                    !this.ls && this._noop();
                }
                _.mixin(PersistentStorage.prototype, {
                    _prefix: function (key) {
                        return this.prefix + key;
                    },
                    _ttlKey: function (key) {
                        return this._prefix(key) + this.ttlKey;
                    },
                    _noop: function () {
                        this.get = this.set = this.remove = this.clear = this.isExpired = _.noop;
                    },
                    _safeSet: function (key, val) {
                        try {
                            this.ls.setItem(key, val);
                        } catch (err) {
                            if (err.name === "QuotaExceededError") {
                                this.clear();
                                this._noop();
                            }
                        }
                    },
                    get: function (key) {
                        if (this.isExpired(key)) {
                            this.remove(key);
                        }
                        return decode(this.ls.getItem(this._prefix(key)));
                    },
                    set: function (key, val, ttl) {
                        if (_.isNumber(ttl)) {
                            this._safeSet(this._ttlKey(key), encode(now() + ttl));
                        } else {
                            this.ls.removeItem(this._ttlKey(key));
                        }
                        return this._safeSet(this._prefix(key), encode(val));
                    },
                    remove: function (key) {
                        this.ls.removeItem(this._ttlKey(key));
                        this.ls.removeItem(this._prefix(key));
                        return this;
                    },
                    clear: function () {
                        var i,
                            keys = gatherMatchingKeys(this.keyMatcher);
                        for (i = keys.length; i--;) {
                            this.remove(keys[i]);
                        }
                        return this;
                    },
                    isExpired: function (key) {
                        var ttl = decode(this.ls.getItem(this._ttlKey(key)));
                        return _.isNumber(ttl) && now() > ttl ? true : false;
                    }
                });
                return PersistentStorage;
                function now() {
                    return new Date().getTime();
                }
                function encode(val) {
                    return JSON.stringify(_.isUndefined(val) ? null : val);
                }
                function decode(val) {
                    return $.parseJSON(val);
                }
                function gatherMatchingKeys(keyMatcher) {
                    var i,
                        key,
                        keys = [],
                        len = LOCAL_STORAGE.length;
                    for (i = 0; i < len; i++) {
                        if ((key = LOCAL_STORAGE.key(i)).match(keyMatcher)) {
                            keys.push(key.replace(keyMatcher, ""));
                        }
                    }
                    return keys;
                }
            }();
            var Transport = function () {
                "use strict";

                var pendingRequestsCount = 0,
                    pendingRequests = {},
                    maxPendingRequests = 6,
                    sharedCache = new LruCache(10);
                function Transport(o) {
                    o = o || {};
                    this.cancelled = false;
                    this.lastReq = null;
                    this._send = o.transport;
                    this._get = o.limiter ? o.limiter(this._get) : this._get;
                    this._cache = o.cache === false ? new LruCache(0) : sharedCache;
                }
                Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
                    maxPendingRequests = num;
                };
                Transport.resetCache = function resetCache() {
                    sharedCache.reset();
                };
                _.mixin(Transport.prototype, {
                    _fingerprint: function fingerprint(o) {
                        o = o || {};
                        return o.url + o.type + $.param(o.data || {});
                    },
                    _get: function (o, cb) {
                        var that = this,
                            fingerprint,
                            jqXhr;
                        fingerprint = this._fingerprint(o);
                        if (this.cancelled || fingerprint !== this.lastReq) {
                            return;
                        }
                        if (jqXhr = pendingRequests[fingerprint]) {
                            jqXhr.done(done).fail(fail);
                        } else if (pendingRequestsCount < maxPendingRequests) {
                            pendingRequestsCount++;
                            pendingRequests[fingerprint] = this._send(o).done(done).fail(fail).always(always);
                        } else {
                            this.onDeckRequestArgs = [].slice.call(arguments, 0);
                        }
                        function done(resp) {
                            cb(null, resp);
                            that._cache.set(fingerprint, resp);
                        }
                        function fail() {
                            cb(true);
                        }
                        function always() {
                            pendingRequestsCount--;
                            delete pendingRequests[fingerprint];
                            if (that.onDeckRequestArgs) {
                                that._get.apply(that, that.onDeckRequestArgs);
                                that.onDeckRequestArgs = null;
                            }
                        }
                    },
                    get: function (o, cb) {
                        var resp, fingerprint;
                        cb = cb || $.noop;
                        o = _.isString(o) ? {
                            url: o
                        } : o || {};
                        fingerprint = this._fingerprint(o);
                        this.cancelled = false;
                        this.lastReq = fingerprint;
                        if (resp = this._cache.get(fingerprint)) {
                            cb(null, resp);
                        } else {
                            this._get(o, cb);
                        }
                    },
                    cancel: function () {
                        this.cancelled = true;
                    }
                });
                return Transport;
            }();
            var SearchIndex = window.SearchIndex = function () {
                "use strict";

                var CHILDREN = "c",
                    IDS = "i";
                function SearchIndex(o) {
                    o = o || {};
                    if (!o.datumTokenizer || !o.queryTokenizer) {
                        $.error("datumTokenizer and queryTokenizer are both required");
                    }
                    this.identify = o.identify || _.stringify;
                    this.datumTokenizer = o.datumTokenizer;
                    this.queryTokenizer = o.queryTokenizer;
                    this.reset();
                }
                _.mixin(SearchIndex.prototype, {
                    bootstrap: function bootstrap(o) {
                        this.datums = o.datums;
                        this.trie = o.trie;
                    },
                    add: function (data) {
                        var that = this;
                        data = _.isArray(data) ? data : [data];
                        _.each(data, function (datum) {
                            var id, tokens;
                            that.datums[id = that.identify(datum)] = datum;
                            tokens = normalizeTokens(that.datumTokenizer(datum));
                            _.each(tokens, function (token) {
                                var node, chars, ch;
                                node = that.trie;
                                chars = token.split("");
                                while (ch = chars.shift()) {
                                    node = node[CHILDREN][ch] || (node[CHILDREN][ch] = newNode());
                                    node[IDS].push(id);
                                }
                            });
                        });
                    },
                    get: function get(ids) {
                        var that = this;
                        return _.map(ids, function (id) {
                            return that.datums[id];
                        });
                    },
                    search: function search(query) {
                        var that = this,
                            tokens,
                            matches;
                        tokens = normalizeTokens(this.queryTokenizer(query));
                        _.each(tokens, function (token) {
                            var node, chars, ch, ids;
                            if (matches && matches.length === 0) {
                                return false;
                            }
                            node = that.trie;
                            chars = token.split("");
                            while (node && (ch = chars.shift())) {
                                node = node[CHILDREN][ch];
                            }
                            if (node && chars.length === 0) {
                                ids = node[IDS].slice(0);
                                matches = matches ? getIntersection(matches, ids) : ids;
                            } else {
                                matches = [];
                                return false;
                            }
                        });
                        return matches ? _.map(unique(matches), function (id) {
                            return that.datums[id];
                        }) : [];
                    },
                    all: function all() {
                        var values = [];
                        for (var key in this.datums) {
                            values.push(this.datums[key]);
                        }
                        return values;
                    },
                    reset: function reset() {
                        this.datums = {};
                        this.trie = newNode();
                    },
                    serialize: function serialize() {
                        return {
                            datums: this.datums,
                            trie: this.trie
                        };
                    }
                });
                return SearchIndex;
                function normalizeTokens(tokens) {
                    tokens = _.filter(tokens, function (token) {
                        return !!token;
                    });
                    tokens = _.map(tokens, function (token) {
                        return token.toLowerCase();
                    });
                    return tokens;
                }
                function newNode() {
                    var node = {};
                    node[IDS] = [];
                    node[CHILDREN] = {};
                    return node;
                }
                function unique(array) {
                    var seen = {},
                        uniques = [];
                    for (var i = 0, len = array.length; i < len; i++) {
                        if (!seen[array[i]]) {
                            seen[array[i]] = true;
                            uniques.push(array[i]);
                        }
                    }
                    return uniques;
                }
                function getIntersection(arrayA, arrayB) {
                    var ai = 0,
                        bi = 0,
                        intersection = [];
                    arrayA = arrayA.sort();
                    arrayB = arrayB.sort();
                    var lenArrayA = arrayA.length,
                        lenArrayB = arrayB.length;
                    while (ai < lenArrayA && bi < lenArrayB) {
                        if (arrayA[ai] < arrayB[bi]) {
                            ai++;
                        } else if (arrayA[ai] > arrayB[bi]) {
                            bi++;
                        } else {
                            intersection.push(arrayA[ai]);
                            ai++;
                            bi++;
                        }
                    }
                    return intersection;
                }
            }();
            var Prefetch = function () {
                "use strict";

                var keys;
                keys = {
                    data: "data",
                    protocol: "protocol",
                    thumbprint: "thumbprint"
                };
                function Prefetch(o) {
                    this.url = o.url;
                    this.ttl = o.ttl;
                    this.cache = o.cache;
                    this.prepare = o.prepare;
                    this.transform = o.transform;
                    this.transport = o.transport;
                    this.thumbprint = o.thumbprint;
                    this.storage = new PersistentStorage(o.cacheKey);
                }
                _.mixin(Prefetch.prototype, {
                    _settings: function settings() {
                        return {
                            url: this.url,
                            type: "GET",
                            dataType: "json"
                        };
                    },
                    store: function store(data) {
                        if (!this.cache) {
                            return;
                        }
                        this.storage.set(keys.data, data, this.ttl);
                        this.storage.set(keys.protocol, location.protocol, this.ttl);
                        this.storage.set(keys.thumbprint, this.thumbprint, this.ttl);
                    },
                    fromCache: function fromCache() {
                        var stored = {},
                            isExpired;
                        if (!this.cache) {
                            return null;
                        }
                        stored.data = this.storage.get(keys.data);
                        stored.protocol = this.storage.get(keys.protocol);
                        stored.thumbprint = this.storage.get(keys.thumbprint);
                        isExpired = stored.thumbprint !== this.thumbprint || stored.protocol !== location.protocol;
                        return stored.data && !isExpired ? stored.data : null;
                    },
                    fromNetwork: function (cb) {
                        var that = this,
                            settings;
                        if (!cb) {
                            return;
                        }
                        settings = this.prepare(this._settings());
                        this.transport(settings).fail(onError).done(onResponse);
                        function onError() {
                            cb(true);
                        }
                        function onResponse(resp) {
                            cb(null, that.transform(resp));
                        }
                    },
                    clear: function clear() {
                        this.storage.clear();
                        return this;
                    }
                });
                return Prefetch;
            }();
            var Remote = function () {
                "use strict";

                function Remote(o) {
                    this.url = o.url;
                    this.prepare = o.prepare;
                    this.transform = o.transform;
                    this.transport = new Transport({
                        cache: o.cache,
                        limiter: o.limiter,
                        transport: o.transport
                    });
                }
                _.mixin(Remote.prototype, {
                    _settings: function settings() {
                        return {
                            url: this.url,
                            type: "GET",
                            dataType: "json"
                        };
                    },
                    get: function get(query, cb) {
                        var that = this,
                            settings;
                        if (!cb) {
                            return;
                        }
                        query = query || "";
                        settings = this.prepare(query, this._settings());
                        return this.transport.get(settings, onResponse);
                        function onResponse(err, resp) {
                            err ? cb([]) : cb(that.transform(resp));
                        }
                    },
                    cancelLastRequest: function cancelLastRequest() {
                        this.transport.cancel();
                    }
                });
                return Remote;
            }();
            var oParser = function () {
                "use strict";

                return function parse(o) {
                    var defaults, sorter;
                    defaults = {
                        initialize: true,
                        identify: _.stringify,
                        datumTokenizer: null,
                        queryTokenizer: null,
                        sufficient: 5,
                        sorter: null,
                        local: [],
                        prefetch: null,
                        remote: null
                    };
                    o = _.mixin(defaults, o || {});
                    !o.datumTokenizer && $.error("datumTokenizer is required");
                    !o.queryTokenizer && $.error("queryTokenizer is required");
                    sorter = o.sorter;
                    o.sorter = sorter ? function (x) {
                        return x.sort(sorter);
                    } : _.identity;
                    o.local = _.isFunction(o.local) ? o.local() : o.local;
                    o.prefetch = parsePrefetch(o.prefetch);
                    o.remote = parseRemote(o.remote);
                    return o;
                };
                function parsePrefetch(o) {
                    var defaults;
                    if (!o) {
                        return null;
                    }
                    defaults = {
                        url: null,
                        ttl: 24 * 60 * 60 * 1e3,
                        cache: true,
                        cacheKey: null,
                        thumbprint: "",
                        prepare: _.identity,
                        transform: _.identity,
                        transport: null
                    };
                    o = _.isString(o) ? {
                        url: o
                    } : o;
                    o = _.mixin(defaults, o);
                    !o.url && $.error("prefetch requires url to be set");
                    o.transform = o.filter || o.transform;
                    o.cacheKey = o.cacheKey || o.url;
                    o.thumbprint = VERSION + o.thumbprint;
                    o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
                    return o;
                }
                function parseRemote(o) {
                    var defaults;
                    if (!o) {
                        return;
                    }
                    defaults = {
                        url: null,
                        cache: true,
                        prepare: null,
                        replace: null,
                        wildcard: null,
                        limiter: null,
                        rateLimitBy: "debounce",
                        rateLimitWait: 300,
                        transform: _.identity,
                        transport: null
                    };
                    o = _.isString(o) ? {
                        url: o
                    } : o;
                    o = _.mixin(defaults, o);
                    !o.url && $.error("remote requires url to be set");
                    o.transform = o.filter || o.transform;
                    o.prepare = toRemotePrepare(o);
                    o.limiter = toLimiter(o);
                    o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
                    delete o.replace;
                    delete o.wildcard;
                    delete o.rateLimitBy;
                    delete o.rateLimitWait;
                    return o;
                }
                function toRemotePrepare(o) {
                    var prepare, replace, wildcard;
                    prepare = o.prepare;
                    replace = o.replace;
                    wildcard = o.wildcard;
                    if (prepare) {
                        return prepare;
                    }
                    if (replace) {
                        prepare = prepareByReplace;
                    } else if (o.wildcard) {
                        prepare = prepareByWildcard;
                    } else {
                        prepare = idenityPrepare;
                    }
                    return prepare;
                    function prepareByReplace(query, settings) {
                        settings.url = replace(settings.url, query);
                        return settings;
                    }
                    function prepareByWildcard(query, settings) {
                        settings.url = settings.url.replace(wildcard, encodeURIComponent(query));
                        return settings;
                    }
                    function idenityPrepare(query, settings) {
                        return settings;
                    }
                }
                function toLimiter(o) {
                    var limiter, method, wait;
                    limiter = o.limiter;
                    method = o.rateLimitBy;
                    wait = o.rateLimitWait;
                    if (!limiter) {
                        limiter = /^throttle$/i.test(method) ? throttle(wait) : debounce(wait);
                    }
                    return limiter;
                    function debounce(wait) {
                        return function debounce(fn) {
                            return _.debounce(fn, wait);
                        };
                    }
                    function throttle(wait) {
                        return function throttle(fn) {
                            return _.throttle(fn, wait);
                        };
                    }
                }
                function callbackToDeferred(fn) {
                    return function wrapper(o) {
                        var deferred = $.Deferred();
                        fn(o, onSuccess, onError);
                        return deferred;
                        function onSuccess(resp) {
                            _.defer(function () {
                                deferred.resolve(resp);
                            });
                        }
                        function onError(err) {
                            _.defer(function () {
                                deferred.reject(err);
                            });
                        }
                    };
                }
            }();
            var Bloodhound = function () {
                "use strict";

                var old;
                old = window && window.Bloodhound;
                function Bloodhound(o) {
                    o = oParser(o);
                    this.sorter = o.sorter;
                    this.identify = o.identify;
                    this.sufficient = o.sufficient;
                    this.local = o.local;
                    this.remote = o.remote ? new Remote(o.remote) : null;
                    this.prefetch = o.prefetch ? new Prefetch(o.prefetch) : null;
                    this.index = new SearchIndex({
                        identify: this.identify,
                        datumTokenizer: o.datumTokenizer,
                        queryTokenizer: o.queryTokenizer
                    });
                    o.initialize !== false && this.initialize();
                }
                Bloodhound.noConflict = function noConflict() {
                    window && (window.Bloodhound = old);
                    return Bloodhound;
                };
                Bloodhound.tokenizers = tokenizers;
                _.mixin(Bloodhound.prototype, {
                    __ttAdapter: function ttAdapter() {
                        var that = this;
                        return this.remote ? withAsync : withoutAsync;
                        function withAsync(query, sync, async) {
                            return that.search(query, sync, async);
                        }
                        function withoutAsync(query, sync) {
                            return that.search(query, sync);
                        }
                    },
                    _loadPrefetch: function loadPrefetch() {
                        var that = this,
                            deferred,
                            serialized;
                        deferred = $.Deferred();
                        if (!this.prefetch) {
                            deferred.resolve();
                        } else if (serialized = this.prefetch.fromCache()) {
                            this.index.bootstrap(serialized);
                            deferred.resolve();
                        } else {
                            this.prefetch.fromNetwork(done);
                        }
                        return deferred.promise();
                        function done(err, data) {
                            if (err) {
                                return deferred.reject();
                            }
                            that.add(data);
                            that.prefetch.store(that.index.serialize());
                            deferred.resolve();
                        }
                    },
                    _initialize: function initialize() {
                        var that = this,
                            deferred;
                        this.clear();
                        (this.initPromise = this._loadPrefetch()).done(addLocalToIndex);
                        return this.initPromise;
                        function addLocalToIndex() {
                            that.add(that.local);
                        }
                    },
                    initialize: function initialize(force) {
                        return !this.initPromise || force ? this._initialize() : this.initPromise;
                    },
                    add: function add(data) {
                        this.index.add(data);
                        return this;
                    },
                    get: function get(ids) {
                        ids = _.isArray(ids) ? ids : [].slice.call(arguments);
                        return this.index.get(ids);
                    },
                    search: function search(query, sync, async) {
                        var that = this,
                            local;
                        local = this.sorter(this.index.search(query));
                        sync(this.remote ? local.slice() : local);
                        if (this.remote && local.length < this.sufficient) {
                            this.remote.get(query, processRemote);
                        } else if (this.remote) {
                            this.remote.cancelLastRequest();
                        }
                        return this;
                        function processRemote(remote) {
                            var nonDuplicates = [];
                            _.each(remote, function (r) {
                                !_.some(local, function (l) {
                                    return that.identify(r) === that.identify(l);
                                }) && nonDuplicates.push(r);
                            });
                            async && async(nonDuplicates);
                        }
                    },
                    all: function all() {
                        return this.index.all();
                    },
                    clear: function clear() {
                        this.index.reset();
                        return this;
                    },
                    clearPrefetchCache: function clearPrefetchCache() {
                        this.prefetch && this.prefetch.clear();
                        return this;
                    },
                    clearRemoteCache: function clearRemoteCache() {
                        Transport.resetCache();
                        return this;
                    },
                    ttAdapter: function ttAdapter() {
                        return this.__ttAdapter();
                    }
                });
                return Bloodhound;
            }();
            return Bloodhound;
        });

        (function (root, factory) {
            if (typeof define === "function" && define.amd) {
                define("typeahead.js", ["jquery"], function (a0) {
                    return factory(a0);
                });
            } else if (typeof exports === "object") {
                module.exports = factory(require("jquery"));
            } else {
                factory(jQuery);
            }
        })(this, function ($) {
            var _ = function () {
                "use strict";

                return {
                    isMsie: function () {
                        return (/(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false
                        );
                    },
                    isBlankString: function (str) {
                        return !str || /^\s*$/.test(str);
                    },
                    escapeRegExChars: function (str) {
                        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
                    },
                    isString: function (obj) {
                        return typeof obj === "string";
                    },
                    isNumber: function (obj) {
                        return typeof obj === "number";
                    },
                    isArray: $.isArray,
                    isFunction: $.isFunction,
                    isObject: $.isPlainObject,
                    isUndefined: function (obj) {
                        return typeof obj === "undefined";
                    },
                    isElement: function (obj) {
                        return !!(obj && obj.nodeType === 1);
                    },
                    isJQuery: function (obj) {
                        return obj instanceof $;
                    },
                    toStr: function toStr(s) {
                        return _.isUndefined(s) || s === null ? "" : s + "";
                    },
                    bind: $.proxy,
                    each: function (collection, cb) {
                        $.each(collection, reverseArgs);
                        function reverseArgs(index, value) {
                            return cb(value, index);
                        }
                    },
                    map: $.map,
                    filter: $.grep,
                    every: function (obj, test) {
                        var result = true;
                        if (!obj) {
                            return result;
                        }
                        $.each(obj, function (key, val) {
                            if (!(result = test.call(null, val, key, obj))) {
                                return false;
                            }
                        });
                        return !!result;
                    },
                    some: function (obj, test) {
                        var result = false;
                        if (!obj) {
                            return result;
                        }
                        $.each(obj, function (key, val) {
                            if (result = test.call(null, val, key, obj)) {
                                return false;
                            }
                        });
                        return !!result;
                    },
                    mixin: $.extend,
                    identity: function (x) {
                        return x;
                    },
                    clone: function (obj) {
                        return $.extend(true, {}, obj);
                    },
                    getIdGenerator: function () {
                        var counter = 0;
                        return function () {
                            return counter++;
                        };
                    },
                    templatify: function templatify(obj) {
                        return $.isFunction(obj) ? obj : template;
                        function template() {
                            return String(obj);
                        }
                    },
                    defer: function (fn) {
                        setTimeout(fn, 0);
                    },
                    debounce: function (func, wait, immediate) {
                        var timeout, result;
                        return function () {
                            var context = this,
                                args = arguments,
                                later,
                                callNow;
                            later = function () {
                                timeout = null;
                                if (!immediate) {
                                    result = func.apply(context, args);
                                }
                            };
                            callNow = immediate && !timeout;
                            clearTimeout(timeout);
                            timeout = setTimeout(later, wait);
                            if (callNow) {
                                result = func.apply(context, args);
                            }
                            return result;
                        };
                    },
                    throttle: function (func, wait) {
                        var context, args, timeout, result, previous, later;
                        previous = 0;
                        later = function () {
                            previous = new Date();
                            timeout = null;
                            result = func.apply(context, args);
                        };
                        return function () {
                            var now = new Date(),
                                remaining = wait - (now - previous);
                            context = this;
                            args = arguments;
                            if (remaining <= 0) {
                                clearTimeout(timeout);
                                timeout = null;
                                previous = now;
                                result = func.apply(context, args);
                            } else if (!timeout) {
                                timeout = setTimeout(later, remaining);
                            }
                            return result;
                        };
                    },
                    stringify: function (val) {
                        return _.isString(val) ? val : JSON.stringify(val);
                    },
                    noop: function () {}
                };
            }();
            var WWW = function () {
                "use strict";

                var defaultClassNames = {
                    wrapper: "twitter-typeahead",
                    input: "tt-input",
                    hint: "tt-hint",
                    menu: "tt-menu",
                    dataset: "tt-dataset",
                    suggestion: "tt-suggestion",
                    selectable: "tt-selectable",
                    empty: "tt-empty",
                    open: "tt-open",
                    cursor: "tt-cursor",
                    highlight: "tt-highlight"
                };
                return build;
                function build(o) {
                    var www, classes;
                    classes = _.mixin({}, defaultClassNames, o);
                    www = {
                        css: buildCss(),
                        classes: classes,
                        html: buildHtml(classes),
                        selectors: buildSelectors(classes)
                    };
                    return {
                        css: www.css,
                        html: www.html,
                        classes: www.classes,
                        selectors: www.selectors,
                        mixin: function (o) {
                            _.mixin(o, www);
                        }
                    };
                }
                function buildHtml(c) {
                    return {
                        wrapper: '<span class="' + c.wrapper + '"></span>',
                        menu: '<div class="' + c.menu + '"></div>'
                    };
                }
                function buildSelectors(classes) {
                    var selectors = {};
                    _.each(classes, function (v, k) {
                        selectors[k] = "." + v;
                    });
                    return selectors;
                }
                function buildCss() {
                    var css = {
                        wrapper: {
                            position: "relative",
                            display: "inline-block"
                        },
                        hint: {
                            position: "absolute",
                            top: "0",
                            left: "0",
                            borderColor: "transparent",
                            boxShadow: "none",
                            opacity: "1"
                        },
                        input: {
                            position: "relative",
                            verticalAlign: "top",
                            backgroundColor: "transparent"
                        },
                        inputWithNoHint: {
                            position: "relative",
                            verticalAlign: "top"
                        },
                        menu: {
                            position: "absolute",
                            top: "100%",
                            left: "0",
                            zIndex: "100",
                            display: "none"
                        },
                        ltr: {
                            left: "0",
                            right: "auto"
                        },
                        rtl: {
                            left: "auto",
                            right: " 0"
                        }
                    };
                    if (_.isMsie()) {
                        _.mixin(css.input, {
                            backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
                        });
                    }
                    return css;
                }
            }();
            var EventBus = function () {
                "use strict";

                var namespace, deprecationMap;
                namespace = "typeahead:";
                deprecationMap = {
                    render: "rendered",
                    cursorchange: "cursorchanged",
                    select: "selected",
                    autocomplete: "autocompleted"
                };
                function EventBus(o) {
                    if (!o || !o.el) {
                        $.error("EventBus initialized without el");
                    }
                    this.$el = $(o.el);
                }
                _.mixin(EventBus.prototype, {
                    _trigger: function (type, args) {
                        var $e;
                        $e = $.Event(namespace + type);
                        (args = args || []).unshift($e);
                        this.$el.trigger.apply(this.$el, args);
                        return $e;
                    },
                    before: function (type) {
                        var args, $e;
                        args = [].slice.call(arguments, 1);
                        $e = this._trigger("before" + type, args);
                        return $e.isDefaultPrevented();
                    },
                    trigger: function (type) {
                        var deprecatedType;
                        this._trigger(type, [].slice.call(arguments, 1));
                        if (deprecatedType = deprecationMap[type]) {
                            this._trigger(deprecatedType, [].slice.call(arguments, 1));
                        }
                    }
                });
                return EventBus;
            }();
            var EventEmitter = function () {
                "use strict";

                var splitter = /\s+/,
                    nextTick = getNextTick();
                return {
                    onSync: onSync,
                    onAsync: onAsync,
                    off: off,
                    trigger: trigger
                };
                function on(method, types, cb, context) {
                    var type;
                    if (!cb) {
                        return this;
                    }
                    types = types.split(splitter);
                    cb = context ? bindContext(cb, context) : cb;
                    this._callbacks = this._callbacks || {};
                    while (type = types.shift()) {
                        this._callbacks[type] = this._callbacks[type] || {
                            sync: [],
                            async: []
                        };
                        this._callbacks[type][method].push(cb);
                    }
                    return this;
                }
                function onAsync(types, cb, context) {
                    return on.call(this, "async", types, cb, context);
                }
                function onSync(types, cb, context) {
                    return on.call(this, "sync", types, cb, context);
                }
                function off(types) {
                    var type;
                    if (!this._callbacks) {
                        return this;
                    }
                    types = types.split(splitter);
                    while (type = types.shift()) {
                        delete this._callbacks[type];
                    }
                    return this;
                }
                function trigger(types) {
                    var type, callbacks, args, syncFlush, asyncFlush;
                    if (!this._callbacks) {
                        return this;
                    }
                    types = types.split(splitter);
                    args = [].slice.call(arguments, 1);
                    while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
                        syncFlush = getFlush(callbacks.sync, this, [type].concat(args));
                        asyncFlush = getFlush(callbacks.async, this, [type].concat(args));
                        syncFlush() && nextTick(asyncFlush);
                    }
                    return this;
                }
                function getFlush(callbacks, context, args) {
                    return flush;
                    function flush() {
                        var cancelled;
                        for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
                            cancelled = callbacks[i].apply(context, args) === false;
                        }
                        return !cancelled;
                    }
                }
                function getNextTick() {
                    var nextTickFn;
                    if (window.setImmediate) {
                        nextTickFn = function nextTickSetImmediate(fn) {
                            setImmediate(function () {
                                fn();
                            });
                        };
                    } else {
                        nextTickFn = function nextTickSetTimeout(fn) {
                            setTimeout(function () {
                                fn();
                            }, 0);
                        };
                    }
                    return nextTickFn;
                }
                function bindContext(fn, context) {
                    return fn.bind ? fn.bind(context) : function () {
                        fn.apply(context, [].slice.call(arguments, 0));
                    };
                }
            }();
            var highlight = function (doc) {
                "use strict";

                var defaults = {
                    node: null,
                    pattern: null,
                    tagName: "strong",
                    className: null,
                    wordsOnly: false,
                    caseSensitive: false
                };
                return function hightlight(o) {
                    var regex;
                    o = _.mixin({}, defaults, o);
                    if (!o.node || !o.pattern) {
                        return;
                    }
                    o.pattern = _.isArray(o.pattern) ? o.pattern : [o.pattern];
                    regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
                    traverse(o.node, hightlightTextNode);
                    function hightlightTextNode(textNode) {
                        var match, patternNode, wrapperNode;
                        if (match = regex.exec(textNode.data)) {
                            wrapperNode = doc.createElement(o.tagName);
                            o.className && (wrapperNode.className = o.className);
                            patternNode = textNode.splitText(match.index);
                            patternNode.splitText(match[0].length);
                            wrapperNode.appendChild(patternNode.cloneNode(true));
                            textNode.parentNode.replaceChild(wrapperNode, patternNode);
                        }
                        return !!match;
                    }
                    function traverse(el, hightlightTextNode) {
                        var childNode,
                            TEXT_NODE_TYPE = 3;
                        for (var i = 0; i < el.childNodes.length; i++) {
                            childNode = el.childNodes[i];
                            if (childNode.nodeType === TEXT_NODE_TYPE) {
                                i += hightlightTextNode(childNode) ? 1 : 0;
                            } else {
                                traverse(childNode, hightlightTextNode);
                            }
                        }
                    }
                };
                function getRegex(patterns, caseSensitive, wordsOnly) {
                    var escapedPatterns = [],
                        regexStr;
                    for (var i = 0, len = patterns.length; i < len; i++) {
                        escapedPatterns.push(_.escapeRegExChars(patterns[i]));
                    }
                    regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
                    return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
                }
            }(window.document);
            var Input = function () {
                "use strict";

                var specialKeyCodeMap;
                specialKeyCodeMap = {
                    9: "tab",
                    27: "esc",
                    37: "left",
                    39: "right",
                    13: "enter",
                    38: "up",
                    40: "down"
                };
                function Input(o, www) {
                    o = o || {};
                    if (!o.input) {
                        $.error("input is missing");
                    }
                    www.mixin(this);
                    this.$hint = $(o.hint);
                    this.$input = $(o.input);
                    this.query = this.$input.val();
                    this.queryWhenFocused = this.hasFocus() ? this.query : null;
                    this.$overflowHelper = buildOverflowHelper(this.$input);
                    this._checkLanguageDirection();
                    if (this.$hint.length === 0) {
                        this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
                    }
                }
                Input.normalizeQuery = function (str) {
                    return _.toStr(str).replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
                };
                _.mixin(Input.prototype, EventEmitter, {
                    _onBlur: function onBlur() {
                        this.resetInputValue();
                        this.trigger("blurred");
                    },
                    _onFocus: function onFocus() {
                        this.queryWhenFocused = this.query;
                        this.trigger("focused");
                    },
                    _onKeydown: function onKeydown($e) {
                        var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                        this._managePreventDefault(keyName, $e);
                        if (keyName && this._shouldTrigger(keyName, $e)) {
                            this.trigger(keyName + "Keyed", $e);
                        }
                    },
                    _onInput: function onInput() {
                        this._setQuery(this.getInputValue());
                        this.clearHintIfInvalid();
                        this._checkLanguageDirection();
                    },
                    _managePreventDefault: function managePreventDefault(keyName, $e) {
                        var preventDefault;
                        switch (keyName) {
                            case "up":
                            case "down":
                                preventDefault = !withModifier($e);
                                break;

                            default:
                                preventDefault = false;
                        }
                        preventDefault && $e.preventDefault();
                    },
                    _shouldTrigger: function shouldTrigger(keyName, $e) {
                        var trigger;
                        switch (keyName) {
                            case "tab":
                                trigger = !withModifier($e);
                                break;

                            default:
                                trigger = true;
                        }
                        return trigger;
                    },
                    _checkLanguageDirection: function checkLanguageDirection() {
                        var dir = (this.$input.css("direction") || "ltr").toLowerCase();
                        if (this.dir !== dir) {
                            this.dir = dir;
                            this.$hint.attr("dir", dir);
                            this.trigger("langDirChanged", dir);
                        }
                    },
                    _setQuery: function setQuery(val, silent) {
                        var areEquivalent, hasDifferentWhitespace;
                        areEquivalent = areQueriesEquivalent(val, this.query);
                        hasDifferentWhitespace = areEquivalent ? this.query.length !== val.length : false;
                        this.query = val;
                        if (!silent && !areEquivalent) {
                            this.trigger("queryChanged", this.query);
                        } else if (!silent && hasDifferentWhitespace) {
                            this.trigger("whitespaceChanged", this.query);
                        }
                    },
                    bind: function () {
                        var that = this,
                            onBlur,
                            onFocus,
                            onKeydown,
                            onInput;
                        onBlur = _.bind(this._onBlur, this);
                        onFocus = _.bind(this._onFocus, this);
                        onKeydown = _.bind(this._onKeydown, this);
                        onInput = _.bind(this._onInput, this);
                        this.$input.on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
                        if (!_.isMsie() || _.isMsie() > 9) {
                            this.$input.on("input.tt", onInput);
                        } else {
                            this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function ($e) {
                                if (specialKeyCodeMap[$e.which || $e.keyCode]) {
                                    return;
                                }
                                _.defer(_.bind(that._onInput, that, $e));
                            });
                        }
                        return this;
                    },
                    focus: function focus() {
                        this.$input.focus();
                    },
                    blur: function blur() {
                        this.$input.blur();
                    },
                    getLangDir: function getLangDir() {
                        return this.dir;
                    },
                    getQuery: function getQuery() {
                        return this.query || "";
                    },
                    setQuery: function setQuery(val, silent) {
                        this.setInputValue(val);
                        this._setQuery(val, silent);
                    },
                    hasQueryChangedSinceLastFocus: function hasQueryChangedSinceLastFocus() {
                        return this.query !== this.queryWhenFocused;
                    },
                    getInputValue: function getInputValue() {
                        return this.$input.val();
                    },
                    setInputValue: function setInputValue(value) {
                        this.$input.val(value);
                        this.clearHintIfInvalid();
                        this._checkLanguageDirection();
                    },
                    resetInputValue: function resetInputValue() {
                        this.setInputValue(this.query);
                    },
                    getHint: function getHint() {
                        return this.$hint.val();
                    },
                    setHint: function setHint(value) {
                        this.$hint.val(value);
                    },
                    clearHint: function clearHint() {
                        this.setHint("");
                    },
                    clearHintIfInvalid: function clearHintIfInvalid() {
                        var val, hint, valIsPrefixOfHint, isValid;
                        val = this.getInputValue();
                        hint = this.getHint();
                        valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
                        isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
                        !isValid && this.clearHint();
                    },
                    hasFocus: function hasFocus() {
                        return this.$input.is(":focus");
                    },
                    hasOverflow: function hasOverflow() {
                        var constraint = this.$input.width() - 2;
                        this.$overflowHelper.text(this.getInputValue());
                        return this.$overflowHelper.width() >= constraint;
                    },
                    isCursorAtEnd: function () {
                        var valueLength, selectionStart, range;
                        valueLength = this.$input.val().length;
                        selectionStart = this.$input[0].selectionStart;
                        if (_.isNumber(selectionStart)) {
                            return selectionStart === valueLength;
                        } else if (document.selection) {
                            range = document.selection.createRange();
                            range.moveStart("character", -valueLength);
                            return valueLength === range.text.length;
                        }
                        return true;
                    },
                    destroy: function destroy() {
                        this.$hint.off(".tt");
                        this.$input.off(".tt");
                        this.$overflowHelper.remove();
                        this.$hint = this.$input = this.$overflowHelper = $("<div>");
                    }
                });
                return Input;
                function buildOverflowHelper($input) {
                    return $('<pre aria-hidden="true"></pre>').css({
                        position: "absolute",
                        visibility: "hidden",
                        whiteSpace: "pre",
                        fontFamily: $input.css("font-family"),
                        fontSize: $input.css("font-size"),
                        fontStyle: $input.css("font-style"),
                        fontVariant: $input.css("font-variant"),
                        fontWeight: $input.css("font-weight"),
                        wordSpacing: $input.css("word-spacing"),
                        letterSpacing: $input.css("letter-spacing"),
                        textIndent: $input.css("text-indent"),
                        textRendering: $input.css("text-rendering"),
                        textTransform: $input.css("text-transform")
                    }).insertAfter($input);
                }
                function areQueriesEquivalent(a, b) {
                    return Input.normalizeQuery(a) === Input.normalizeQuery(b);
                }
                function withModifier($e) {
                    return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
                }
            }();
            var Dataset = function () {
                "use strict";

                var keys, nameGenerator;
                keys = {
                    val: "tt-selectable-display",
                    obj: "tt-selectable-object"
                };
                nameGenerator = _.getIdGenerator();
                function Dataset(o, www) {
                    o = o || {};
                    o.templates = o.templates || {};
                    o.templates.notFound = o.templates.notFound || o.templates.empty;
                    if (!o.source) {
                        $.error("missing source");
                    }
                    if (!o.node) {
                        $.error("missing node");
                    }
                    if (o.name && !isValidName(o.name)) {
                        $.error("invalid dataset name: " + o.name);
                    }
                    www.mixin(this);
                    this.highlight = !!o.highlight;
                    this.name = o.name || nameGenerator();
                    this.limit = o.limit || 5;
                    this.displayFn = getDisplayFn(o.display || o.displayKey);
                    this.templates = getTemplates(o.templates, this.displayFn);
                    this.source = o.source.__ttAdapter ? o.source.__ttAdapter() : o.source;
                    this.async = _.isUndefined(o.async) ? this.source.length > 2 : !!o.async;
                    this._resetLastSuggestion();
                    this.$el = $(o.node).addClass(this.classes.dataset).addClass(this.classes.dataset + "-" + this.name);
                }
                Dataset.extractData = function extractData(el) {
                    var $el = $(el);
                    if ($el.data(keys.obj)) {
                        return {
                            val: $el.data(keys.val) || "",
                            obj: $el.data(keys.obj) || null
                        };
                    }
                    return null;
                };
                _.mixin(Dataset.prototype, EventEmitter, {
                    _overwrite: function overwrite(query, suggestions) {
                        suggestions = suggestions || [];
                        if (suggestions.length) {
                            this._renderSuggestions(query, suggestions);
                        } else if (this.async && this.templates.pending) {
                            this._renderPending(query);
                        } else if (!this.async && this.templates.notFound) {
                            this._renderNotFound(query);
                        } else {
                            this._empty();
                        }
                        this.trigger("rendered", this.name, suggestions, false);
                    },
                    _append: function append(query, suggestions) {
                        suggestions = suggestions || [];
                        if (suggestions.length && this.$lastSuggestion.length) {
                            this._appendSuggestions(query, suggestions);
                        } else if (suggestions.length) {
                            this._renderSuggestions(query, suggestions);
                        } else if (!this.$lastSuggestion.length && this.templates.notFound) {
                            this._renderNotFound(query);
                        }
                        this.trigger("rendered", this.name, suggestions, true);
                    },
                    _renderSuggestions: function renderSuggestions(query, suggestions) {
                        var $fragment;
                        $fragment = this._getSuggestionsFragment(query, suggestions);
                        this.$lastSuggestion = $fragment.children().last();
                        this.$el.html($fragment).prepend(this._getHeader(query, suggestions)).append(this._getFooter(query, suggestions));
                    },
                    _appendSuggestions: function appendSuggestions(query, suggestions) {
                        var $fragment, $lastSuggestion;
                        $fragment = this._getSuggestionsFragment(query, suggestions);
                        $lastSuggestion = $fragment.children().last();
                        this.$lastSuggestion.after($fragment);
                        this.$lastSuggestion = $lastSuggestion;
                    },
                    _renderPending: function renderPending(query) {
                        var template = this.templates.pending;
                        this._resetLastSuggestion();
                        template && this.$el.html(template({
                            query: query,
                            dataset: this.name
                        }));
                    },
                    _renderNotFound: function renderNotFound(query) {
                        var template = this.templates.notFound;
                        this._resetLastSuggestion();
                        template && this.$el.html(template({
                            query: query,
                            dataset: this.name
                        }));
                    },
                    _empty: function empty() {
                        this.$el.empty();
                        this._resetLastSuggestion();
                    },
                    _getSuggestionsFragment: function getSuggestionsFragment(query, suggestions) {
                        var that = this,
                            fragment;
                        fragment = document.createDocumentFragment();
                        _.each(suggestions, function getSuggestionNode(suggestion) {
                            var $el, context;
                            context = that._injectQuery(query, suggestion);
                            $el = $(that.templates.suggestion(context)).data(keys.obj, suggestion).data(keys.val, that.displayFn(suggestion)).addClass(that.classes.suggestion + " " + that.classes.selectable);
                            fragment.appendChild($el[0]);
                        });
                        this.highlight && highlight({
                            className: this.classes.highlight,
                            node: fragment,
                            pattern: query
                        });
                        return $(fragment);
                    },
                    _getFooter: function getFooter(query, suggestions) {
                        return this.templates.footer ? this.templates.footer({
                            query: query,
                            suggestions: suggestions,
                            dataset: this.name
                        }) : null;
                    },
                    _getHeader: function getHeader(query, suggestions) {
                        return this.templates.header ? this.templates.header({
                            query: query,
                            suggestions: suggestions,
                            dataset: this.name
                        }) : null;
                    },
                    _resetLastSuggestion: function resetLastSuggestion() {
                        this.$lastSuggestion = $();
                    },
                    _injectQuery: function injectQuery(query, obj) {
                        return _.isObject(obj) ? _.mixin({
                            _query: query
                        }, obj) : obj;
                    },
                    update: function update(query) {
                        var that = this,
                            canceled = false,
                            syncCalled = false,
                            rendered = 0;
                        this.cancel();
                        this.cancel = function cancel() {
                            canceled = true;
                            that.cancel = $.noop;
                            that.async && that.trigger("asyncCanceled", query);
                        };
                        this.source(query, sync, async);
                        !syncCalled && sync([]);
                        function sync(suggestions) {
                            if (syncCalled) {
                                return;
                            }
                            syncCalled = true;
                            suggestions = (suggestions || []).slice(0, that.limit);
                            rendered = suggestions.length;
                            that._overwrite(query, suggestions);
                            if (rendered < that.limit && that.async) {
                                that.trigger("asyncRequested", query);
                            }
                        }
                        function async(suggestions) {
                            suggestions = suggestions || [];
                            if (!canceled && rendered < that.limit) {
                                that.cancel = $.noop;
                                rendered += suggestions.length;
                                that._append(query, suggestions.slice(0, that.limit - rendered));
                                that.async && that.trigger("asyncReceived", query);
                            }
                        }
                    },
                    cancel: $.noop,
                    clear: function clear() {
                        this._empty();
                        this.cancel();
                        this.trigger("cleared");
                    },
                    isEmpty: function isEmpty() {
                        return this.$el.is(":empty");
                    },
                    destroy: function destroy() {
                        this.$el = $("<div>");
                    }
                });
                return Dataset;
                function getDisplayFn(display) {
                    display = display || _.stringify;
                    return _.isFunction(display) ? display : displayFn;
                    function displayFn(obj) {
                        return obj[display];
                    }
                }
                function getTemplates(templates, displayFn) {
                    return {
                        notFound: templates.notFound && _.templatify(templates.notFound),
                        pending: templates.pending && _.templatify(templates.pending),
                        header: templates.header && _.templatify(templates.header),
                        footer: templates.footer && _.templatify(templates.footer),
                        suggestion: templates.suggestion || suggestionTemplate
                    };
                    function suggestionTemplate(context) {
                        return $("<div>").text(displayFn(context));
                    }
                }
                function isValidName(str) {
                    return (/^[_a-zA-Z0-9-]+$/.test(str)
                    );
                }
            }();
            var Menu = function () {
                "use strict";

                function Menu(o, www) {
                    var that = this;
                    o = o || {};
                    if (!o.node) {
                        $.error("node is required");
                    }
                    www.mixin(this);
                    this.$node = $(o.node);
                    this.query = null;
                    this.datasets = _.map(o.datasets, initializeDataset);
                    function initializeDataset(oDataset) {
                        var node = that.$node.find(oDataset.node).first();
                        oDataset.node = node.length ? node : $("<div>").appendTo(that.$node);
                        return new Dataset(oDataset, www);
                    }
                }
                _.mixin(Menu.prototype, EventEmitter, {
                    _onSelectableClick: function onSelectableClick($e) {
                        this.trigger("selectableClicked", $($e.currentTarget));
                    },
                    _onRendered: function onRendered(type, dataset, suggestions, async) {
                        this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                        this.trigger("datasetRendered", dataset, suggestions, async);
                    },
                    _onCleared: function onCleared() {
                        this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                        this.trigger("datasetCleared");
                    },
                    _propagate: function propagate() {
                        this.trigger.apply(this, arguments);
                    },
                    _allDatasetsEmpty: function allDatasetsEmpty() {
                        return _.every(this.datasets, isDatasetEmpty);
                        function isDatasetEmpty(dataset) {
                            return dataset.isEmpty();
                        }
                    },
                    _getSelectables: function getSelectables() {
                        return this.$node.find(this.selectors.selectable);
                    },
                    _removeCursor: function _removeCursor() {
                        var $selectable = this.getActiveSelectable();
                        $selectable && $selectable.removeClass(this.classes.cursor);
                    },
                    _ensureVisible: function ensureVisible($el) {
                        var elTop, elBottom, nodeScrollTop, nodeHeight;
                        elTop = $el.position().top;
                        elBottom = elTop + $el.outerHeight(true);
                        nodeScrollTop = this.$node.scrollTop();
                        nodeHeight = this.$node.height() + parseInt(this.$node.css("paddingTop"), 10) + parseInt(this.$node.css("paddingBottom"), 10);
                        if (elTop < 0) {
                            this.$node.scrollTop(nodeScrollTop + elTop);
                        } else if (nodeHeight < elBottom) {
                            this.$node.scrollTop(nodeScrollTop + (elBottom - nodeHeight));
                        }
                    },
                    bind: function () {
                        var that = this,
                            onSelectableClick;
                        onSelectableClick = _.bind(this._onSelectableClick, this);
                        this.$node.on("click.tt", this.selectors.selectable, onSelectableClick);
                        _.each(this.datasets, function (dataset) {
                            dataset.onSync("asyncRequested", that._propagate, that).onSync("asyncCanceled", that._propagate, that).onSync("asyncReceived", that._propagate, that).onSync("rendered", that._onRendered, that).onSync("cleared", that._onCleared, that);
                        });
                        return this;
                    },
                    isOpen: function isOpen() {
                        return this.$node.hasClass(this.classes.open);
                    },
                    open: function open() {
                        this.$node.addClass(this.classes.open);
                    },
                    close: function close() {
                        this.$node.removeClass(this.classes.open);
                        this._removeCursor();
                    },
                    setLanguageDirection: function setLanguageDirection(dir) {
                        this.$node.attr("dir", dir);
                    },
                    selectableRelativeToCursor: function selectableRelativeToCursor(delta) {
                        var $selectables, $oldCursor, oldIndex, newIndex;
                        $oldCursor = this.getActiveSelectable();
                        $selectables = this._getSelectables();
                        oldIndex = $oldCursor ? $selectables.index($oldCursor) : -1;
                        newIndex = oldIndex + delta;
                        newIndex = (newIndex + 1) % ($selectables.length + 1) - 1;
                        newIndex = newIndex < -1 ? $selectables.length - 1 : newIndex;
                        return newIndex === -1 ? null : $selectables.eq(newIndex);
                    },
                    setCursor: function setCursor($selectable) {
                        this._removeCursor();
                        if ($selectable = $selectable && $selectable.first()) {
                            $selectable.addClass(this.classes.cursor);
                            this._ensureVisible($selectable);
                        }
                    },
                    getSelectableData: function getSelectableData($el) {
                        return $el && $el.length ? Dataset.extractData($el) : null;
                    },
                    getActiveSelectable: function getActiveSelectable() {
                        var $selectable = this._getSelectables().filter(this.selectors.cursor).first();
                        return $selectable.length ? $selectable : null;
                    },
                    getTopSelectable: function getTopSelectable() {
                        var $selectable = this._getSelectables().first();
                        return $selectable.length ? $selectable : null;
                    },
                    update: function update(query) {
                        var isValidUpdate = query !== this.query;
                        if (isValidUpdate) {
                            this.query = query;
                            _.each(this.datasets, updateDataset);
                        }
                        return isValidUpdate;
                        function updateDataset(dataset) {
                            dataset.update(query);
                        }
                    },
                    empty: function empty() {
                        _.each(this.datasets, clearDataset);
                        this.query = null;
                        this.$node.addClass(this.classes.empty);
                        function clearDataset(dataset) {
                            dataset.clear();
                        }
                    },
                    destroy: function destroy() {
                        this.$node.off(".tt");
                        this.$node = $("<div>");
                        _.each(this.datasets, destroyDataset);
                        function destroyDataset(dataset) {
                            dataset.destroy();
                        }
                    }
                });
                return Menu;
            }();
            var DefaultMenu = function () {
                "use strict";

                var s = Menu.prototype;
                function DefaultMenu() {
                    Menu.apply(this, [].slice.call(arguments, 0));
                }
                _.mixin(DefaultMenu.prototype, Menu.prototype, {
                    open: function open() {
                        !this._allDatasetsEmpty() && this._show();
                        return s.open.apply(this, [].slice.call(arguments, 0));
                    },
                    close: function close() {
                        this._hide();
                        return s.close.apply(this, [].slice.call(arguments, 0));
                    },
                    _onRendered: function onRendered() {
                        if (this._allDatasetsEmpty()) {
                            this._hide();
                        } else {
                            this.isOpen() && this._show();
                        }
                        return s._onRendered.apply(this, [].slice.call(arguments, 0));
                    },
                    _onCleared: function onCleared() {
                        if (this._allDatasetsEmpty()) {
                            this._hide();
                        } else {
                            this.isOpen() && this._show();
                        }
                        return s._onCleared.apply(this, [].slice.call(arguments, 0));
                    },
                    setLanguageDirection: function setLanguageDirection(dir) {
                        this.$node.css(dir === "ltr" ? this.css.ltr : this.css.rtl);
                        return s.setLanguageDirection.apply(this, [].slice.call(arguments, 0));
                    },
                    _hide: function hide() {
                        this.$node.hide();
                    },
                    _show: function show() {
                        this.$node.css("display", "block");
                    }
                });
                return DefaultMenu;
            }();
            var Typeahead = function () {
                "use strict";

                function Typeahead(o, www) {
                    var onFocused, onBlurred, onEnterKeyed, onTabKeyed, onEscKeyed, onUpKeyed, onDownKeyed, onLeftKeyed, onRightKeyed, onQueryChanged, onWhitespaceChanged;
                    o = o || {};
                    if (!o.input) {
                        $.error("missing input");
                    }
                    if (!o.menu) {
                        $.error("missing menu");
                    }
                    if (!o.eventBus) {
                        $.error("missing event bus");
                    }
                    www.mixin(this);
                    this.eventBus = o.eventBus;
                    this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
                    this.input = o.input;
                    this.menu = o.menu;
                    this.enabled = true;
                    this.active = false;
                    this.input.hasFocus() && this.activate();
                    this.dir = this.input.getLangDir();
                    this._hacks();
                    this.menu.bind().onSync("selectableClicked", this._onSelectableClicked, this).onSync("asyncRequested", this._onAsyncRequested, this).onSync("asyncCanceled", this._onAsyncCanceled, this).onSync("asyncReceived", this._onAsyncReceived, this).onSync("datasetRendered", this._onDatasetRendered, this).onSync("datasetCleared", this._onDatasetCleared, this);
                    onFocused = c(this, "activate", "open", "_onFocused");
                    onBlurred = c(this, "deactivate", "_onBlurred");
                    onEnterKeyed = c(this, "isActive", "isOpen", "_onEnterKeyed");
                    onTabKeyed = c(this, "isActive", "isOpen", "_onTabKeyed");
                    onEscKeyed = c(this, "isActive", "_onEscKeyed");
                    onUpKeyed = c(this, "isActive", "open", "_onUpKeyed");
                    onDownKeyed = c(this, "isActive", "open", "_onDownKeyed");
                    onLeftKeyed = c(this, "isActive", "isOpen", "_onLeftKeyed");
                    onRightKeyed = c(this, "isActive", "isOpen", "_onRightKeyed");
                    onQueryChanged = c(this, "_openIfActive", "_onQueryChanged");
                    onWhitespaceChanged = c(this, "_openIfActive", "_onWhitespaceChanged");
                    this.input.bind().onSync("focused", onFocused, this).onSync("blurred", onBlurred, this).onSync("enterKeyed", onEnterKeyed, this).onSync("tabKeyed", onTabKeyed, this).onSync("escKeyed", onEscKeyed, this).onSync("upKeyed", onUpKeyed, this).onSync("downKeyed", onDownKeyed, this).onSync("leftKeyed", onLeftKeyed, this).onSync("rightKeyed", onRightKeyed, this).onSync("queryChanged", onQueryChanged, this).onSync("whitespaceChanged", onWhitespaceChanged, this).onSync("langDirChanged", this._onLangDirChanged, this);
                }
                _.mixin(Typeahead.prototype, {
                    _hacks: function hacks() {
                        var $input, $menu;
                        $input = this.input.$input || $("<div>");
                        $menu = this.menu.$node || $("<div>");
                        $input.on("blur.tt", function ($e) {
                            var active, isActive, hasActive;
                            active = document.activeElement;
                            isActive = $menu.is(active);
                            hasActive = $menu.has(active).length > 0;
                            if (_.isMsie() && (isActive || hasActive)) {
                                $e.preventDefault();
                                $e.stopImmediatePropagation();
                                _.defer(function () {
                                    $input.focus();
                                });
                            }
                        });
                        $menu.on("mousedown.tt", function ($e) {
                            $e.preventDefault();
                        });
                    },
                    _onSelectableClicked: function onSelectableClicked(type, $el) {
                        this.select($el);
                    },
                    _onDatasetCleared: function onDatasetCleared() {
                        this._updateHint();
                    },
                    _onDatasetRendered: function onDatasetRendered(type, dataset, suggestions, async) {
                        this._updateHint();
                        this.eventBus.trigger("render", suggestions, async, dataset);
                    },
                    _onAsyncRequested: function onAsyncRequested(type, dataset, query) {
                        this.eventBus.trigger("asyncrequest", query, dataset);
                    },
                    _onAsyncCanceled: function onAsyncCanceled(type, dataset, query) {
                        this.eventBus.trigger("asynccancel", query, dataset);
                    },
                    _onAsyncReceived: function onAsyncReceived(type, dataset, query) {
                        this.eventBus.trigger("asyncreceive", query, dataset);
                    },
                    _onFocused: function onFocused() {
                        this._minLengthMet() && this.menu.update(this.input.getQuery());
                    },
                    _onBlurred: function onBlurred() {
                        if (this.input.hasQueryChangedSinceLastFocus()) {
                            this.eventBus.trigger("change", this.input.getQuery());
                        }
                    },
                    _onEnterKeyed: function onEnterKeyed(type, $e) {
                        var $selectable;
                        if ($selectable = this.menu.getActiveSelectable()) {
                            this.select($selectable) && $e.preventDefault();
                        }
                    },
                    _onTabKeyed: function onTabKeyed(type, $e) {
                        var $selectable;
                        if ($selectable = this.menu.getActiveSelectable()) {
                            this.select($selectable) && $e.preventDefault();
                        } else if ($selectable = this.menu.getTopSelectable()) {
                            this.autocomplete($selectable) && $e.preventDefault();
                        }
                    },
                    _onEscKeyed: function onEscKeyed() {
                        this.close();
                    },
                    _onUpKeyed: function onUpKeyed() {
                        this.moveCursor(-1);
                    },
                    _onDownKeyed: function onDownKeyed() {
                        this.moveCursor(+1);
                    },
                    _onLeftKeyed: function onLeftKeyed() {
                        if (this.dir === "rtl" && this.input.isCursorAtEnd()) {
                            this.autocomplete(this.menu.getTopSelectable());
                        }
                    },
                    _onRightKeyed: function onRightKeyed() {
                        if (this.dir === "ltr" && this.input.isCursorAtEnd()) {
                            this.autocomplete(this.menu.getTopSelectable());
                        }
                    },
                    _onQueryChanged: function onQueryChanged(e, query) {
                        this._minLengthMet(query) ? this.menu.update(query) : this.menu.empty();
                    },
                    _onWhitespaceChanged: function onWhitespaceChanged() {
                        this._updateHint();
                    },
                    _onLangDirChanged: function onLangDirChanged(e, dir) {
                        if (this.dir !== dir) {
                            this.dir = dir;
                            this.menu.setLanguageDirection(dir);
                        }
                    },
                    _openIfActive: function openIfActive() {
                        this.isActive() && this.open();
                    },
                    _minLengthMet: function minLengthMet(query) {
                        query = _.isString(query) ? query : this.input.getQuery() || "";
                        return query.length >= this.minLength;
                    },
                    _updateHint: function updateHint() {
                        var $selectable, data, val, query, escapedQuery, frontMatchRegEx, match;
                        $selectable = this.menu.getTopSelectable();
                        data = this.menu.getSelectableData($selectable);
                        val = this.input.getInputValue();
                        if (data && !_.isBlankString(val) && !this.input.hasOverflow()) {
                            query = Input.normalizeQuery(val);
                            escapedQuery = _.escapeRegExChars(query);
                            frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
                            match = frontMatchRegEx.exec(data.val);
                            match && this.input.setHint(val + match[1]);
                        } else {
                            this.input.clearHint();
                        }
                    },
                    isEnabled: function isEnabled() {
                        return this.enabled;
                    },
                    enable: function enable() {
                        this.enabled = true;
                    },
                    disable: function disable() {
                        this.enabled = false;
                    },
                    isActive: function isActive() {
                        return this.active;
                    },
                    activate: function activate() {
                        if (this.isActive()) {
                            return true;
                        } else if (!this.isEnabled() || this.eventBus.before("active")) {
                            return false;
                        } else {
                            this.active = true;
                            this.eventBus.trigger("active");
                            return true;
                        }
                    },
                    deactivate: function deactivate() {
                        if (!this.isActive()) {
                            return true;
                        } else if (this.eventBus.before("idle")) {
                            return false;
                        } else {
                            this.active = false;
                            this.close();
                            this.eventBus.trigger("idle");
                            return true;
                        }
                    },
                    isOpen: function isOpen() {
                        return this.menu.isOpen();
                    },
                    open: function open() {
                        if (!this.isOpen() && !this.eventBus.before("open")) {
                            this.menu.open();
                            this._updateHint();
                            this.eventBus.trigger("open");
                        }
                        return this.isOpen();
                    },
                    close: function close() {
                        if (this.isOpen() && !this.eventBus.before("close")) {
                            this.menu.close();
                            this.input.clearHint();
                            this.input.resetInputValue();
                            this.eventBus.trigger("close");
                        }
                        return !this.isOpen();
                    },
                    setVal: function setVal(val) {
                        this.input.setQuery(_.toStr(val));
                    },
                    getVal: function getVal() {
                        return this.input.getQuery();
                    },
                    select: function select($selectable) {
                        var data = this.menu.getSelectableData($selectable);
                        if (data && !this.eventBus.before("select", data.obj)) {
                            this.input.setQuery(data.val, true);
                            this.eventBus.trigger("select", data.obj);
                            this.close();
                            return true;
                        }
                        return false;
                    },
                    autocomplete: function autocomplete($selectable) {
                        var query, data, isValid;
                        query = this.input.getQuery();
                        data = this.menu.getSelectableData($selectable);
                        isValid = data && query !== data.val;
                        if (isValid && !this.eventBus.before("autocomplete", data.obj)) {
                            this.input.setQuery(data.val);
                            this.eventBus.trigger("autocomplete", data.obj);
                            return true;
                        }
                        return false;
                    },
                    moveCursor: function moveCursor(delta) {
                        var query, $candidate, data, payload, cancelMove;
                        query = this.input.getQuery();
                        $candidate = this.menu.selectableRelativeToCursor(delta);
                        data = this.menu.getSelectableData($candidate);
                        payload = data ? data.obj : null;
                        cancelMove = this._minLengthMet() && this.menu.update(query);
                        if (!cancelMove && !this.eventBus.before("cursorchange", payload)) {
                            this.menu.setCursor($candidate);
                            if (data) {
                                this.input.setInputValue(data.val);
                            } else {
                                this.input.resetInputValue();
                                this._updateHint();
                            }
                            this.eventBus.trigger("cursorchange", payload);
                            return true;
                        }
                        return false;
                    },
                    destroy: function destroy() {
                        this.input.destroy();
                        this.menu.destroy();
                    }
                });
                return Typeahead;
                function c(ctx) {
                    var methods = [].slice.call(arguments, 1);
                    return function () {
                        var args = [].slice.call(arguments);
                        _.each(methods, function (method) {
                            return ctx[method].apply(ctx, args);
                        });
                    };
                }
            }();
            (function () {
                "use strict";

                var old, keys, methods;
                old = $.fn.typeahead;
                keys = {
                    www: "tt-www",
                    attrs: "tt-attrs",
                    typeahead: "tt-typeahead"
                };
                methods = {
                    initialize: function initialize(o, datasets) {
                        var www;
                        datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
                        o = o || {};
                        www = WWW(o.classNames);
                        return this.each(attach);
                        function attach() {
                            var $input, $wrapper, $hint, $menu, defaultHint, defaultMenu, eventBus, input, menu, typeahead, MenuConstructor;
                            _.each(datasets, function (d) {
                                d.highlight = !!o.highlight;
                            });
                            $input = $(this);
                            $wrapper = $(www.html.wrapper);
                            $hint = $elOrNull(o.hint);
                            $menu = $elOrNull(o.menu);
                            defaultHint = o.hint !== false && !$hint;
                            defaultMenu = o.menu !== false && !$menu;
                            defaultHint && ($hint = buildHintFromInput($input, www));
                            defaultMenu && ($menu = $(www.html.menu).css(www.css.menu));
                            $hint && $hint.val("");
                            $input = prepInput($input, www);
                            if (defaultHint || defaultMenu) {
                                $wrapper.css(www.css.wrapper);
                                $input.css(defaultHint ? www.css.input : www.css.inputWithNoHint);
                                $input.wrap($wrapper).parent().prepend(defaultHint ? $hint : null).append(defaultMenu ? $menu : null);
                            }
                            MenuConstructor = defaultMenu ? DefaultMenu : Menu;
                            eventBus = new EventBus({
                                el: $input
                            });
                            input = new Input({
                                hint: $hint,
                                input: $input
                            }, www);
                            menu = new MenuConstructor({
                                node: $menu,
                                datasets: datasets
                            }, www);
                            typeahead = new Typeahead({
                                input: input,
                                menu: menu,
                                eventBus: eventBus,
                                minLength: o.minLength
                            }, www);
                            $input.data(keys.www, www);
                            $input.data(keys.typeahead, typeahead);
                        }
                    },
                    isEnabled: function isEnabled() {
                        var enabled;
                        ttEach(this.first(), function (t) {
                            enabled = t.isEnabled();
                        });
                        return enabled;
                    },
                    enable: function enable() {
                        ttEach(this, function (t) {
                            t.enable();
                        });
                        return this;
                    },
                    disable: function disable() {
                        ttEach(this, function (t) {
                            t.disable();
                        });
                        return this;
                    },
                    isActive: function isActive() {
                        var active;
                        ttEach(this.first(), function (t) {
                            active = t.isActive();
                        });
                        return active;
                    },
                    activate: function activate() {
                        ttEach(this, function (t) {
                            t.activate();
                        });
                        return this;
                    },
                    deactivate: function deactivate() {
                        ttEach(this, function (t) {
                            t.deactivate();
                        });
                        return this;
                    },
                    isOpen: function isOpen() {
                        var open;
                        ttEach(this.first(), function (t) {
                            open = t.isOpen();
                        });
                        return open;
                    },
                    open: function open() {
                        ttEach(this, function (t) {
                            t.open();
                        });
                        return this;
                    },
                    close: function close() {
                        ttEach(this, function (t) {
                            t.close();
                        });
                        return this;
                    },
                    select: function select(el) {
                        var success = false,
                            $el = $(el);
                        ttEach(this.first(), function (t) {
                            success = t.select($el);
                        });
                        return success;
                    },
                    autocomplete: function autocomplete(el) {
                        var success = false,
                            $el = $(el);
                        ttEach(this.first(), function (t) {
                            success = t.autocomplete($el);
                        });
                        return success;
                    },
                    moveCursor: function moveCursoe(delta) {
                        var success = false;
                        ttEach(this.first(), function (t) {
                            success = t.moveCursor(delta);
                        });
                        return success;
                    },
                    val: function val(newVal) {
                        var query;
                        if (!arguments.length) {
                            ttEach(this.first(), function (t) {
                                query = t.getVal();
                            });
                            return query;
                        } else {
                            ttEach(this, function (t) {
                                t.setVal(newVal);
                            });
                            return this;
                        }
                    },
                    destroy: function destroy() {
                        ttEach(this, function (typeahead, $input) {
                            revert($input);
                            typeahead.destroy();
                        });
                        return this;
                    }
                };
                $.fn.typeahead = function (method) {
                    if (methods[method]) {
                        return methods[method].apply(this, [].slice.call(arguments, 1));
                    } else {
                        return methods.initialize.apply(this, arguments);
                    }
                };
                $.fn.typeahead.noConflict = function noConflict() {
                    $.fn.typeahead = old;
                    return this;
                };
                function ttEach($els, fn) {
                    $els.each(function () {
                        var $input = $(this),
                            typeahead;
                        (typeahead = $input.data(keys.typeahead)) && fn(typeahead, $input);
                    });
                }
                function buildHintFromInput($input, www) {
                    return $input.clone().addClass(www.classes.hint).removeData().css(www.css.hint).css(getBackgroundStyles($input)).prop("readonly", true).removeAttr("id name placeholder required").attr({
                        autocomplete: "off",
                        spellcheck: "false",
                        tabindex: -1
                    });
                }
                function prepInput($input, www) {
                    $input.data(keys.attrs, {
                        dir: $input.attr("dir"),
                        autocomplete: $input.attr("autocomplete"),
                        spellcheck: $input.attr("spellcheck"),
                        style: $input.attr("style")
                    });
                    $input.addClass(www.classes.input).attr({
                        autocomplete: "off",
                        spellcheck: false
                    });
                    try {
                        !$input.attr("dir") && $input.attr("dir", "auto");
                    } catch (e) {}
                    return $input;
                }
                function getBackgroundStyles($el) {
                    return {
                        backgroundAttachment: $el.css("background-attachment"),
                        backgroundClip: $el.css("background-clip"),
                        backgroundColor: $el.css("background-color"),
                        backgroundImage: $el.css("background-image"),
                        backgroundOrigin: $el.css("background-origin"),
                        backgroundPosition: $el.css("background-position"),
                        backgroundRepeat: $el.css("background-repeat"),
                        backgroundSize: $el.css("background-size")
                    };
                }
                function revert($input) {
                    var www, $wrapper;
                    www = $input.data(keys.www);
                    $wrapper = $input.parent().filter(www.selectors.wrapper);
                    _.each($input.data(keys.attrs), function (val, key) {
                        _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
                    });
                    $input.removeData(keys.typeahead).removeData(keys.www).removeData(keys.attr).removeClass(www.classes.input);
                    if ($wrapper.length) {
                        $input.detach().insertAfter($wrapper);
                        $wrapper.remove();
                    }
                }
                function $elOrNull(obj) {
                    var isValid, $el;
                    isValid = _.isJQuery(obj) || _.isElement(obj);
                    $el = isValid ? $(obj).first() : [];
                    return $el.length ? $el : null;
                }
            })();
        });
    })(this);

    return _retrieveGlobal();
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/dialog-renderer.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'npm:systemjs-plugin-babel@0.0.17/babel-helpers/createClass.js', 'aurelia-pal', 'aurelia-dependency-injection'], function (_export, _context) {
  "use strict";

  var _classCallCheck, _createClass, DOM, transient, _dec, _class, containerTagName, overlayTagName, transitionEvent, DialogRenderer;

  function centerDialog(modalContainer) {
    var child = modalContainer.children[0];
    var vh = Math.max(DOM.querySelectorAll('html')[0].clientHeight, window.innerHeight || 0);

    child.style.marginTop = Math.max((vh - child.offsetHeight) / 2, 30) + 'px';
    child.style.marginBottom = Math.max((vh - child.offsetHeight) / 2, 30) + 'px';
  }
  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_npmSystemjsPluginBabel0017BabelHelpersCreateClassJs) {
      _createClass = _npmSystemjsPluginBabel0017BabelHelpersCreateClassJs.default;
    }, function (_aureliaPal) {
      DOM = _aureliaPal.DOM;
    }, function (_aureliaDependencyInjection) {
      transient = _aureliaDependencyInjection.transient;
    }],
    execute: function () {
      containerTagName = 'ai-dialog-container';
      overlayTagName = 'ai-dialog-overlay';

      transitionEvent = function () {
        var transition = null;

        return function () {
          if (transition) return transition;

          var t = void 0;
          var el = DOM.createElement('fakeelement');
          var transitions = {
            'transition': 'transitionend',
            'OTransition': 'oTransitionEnd',
            'MozTransition': 'transitionend',
            'WebkitTransition': 'webkitTransitionEnd'
          };
          for (t in transitions) {
            if (el.style[t] !== undefined) {
              transition = transitions[t];
              return transition;
            }
          }
        };
      }();

      _export('DialogRenderer', DialogRenderer = (_dec = transient(), _dec(_class = function () {
        function DialogRenderer() {
          var _this = this;

          _classCallCheck(this, DialogRenderer);

          this._escapeKeyEventHandler = function (e) {
            if (e.keyCode === 27) {
              var top = _this._dialogControllers[_this._dialogControllers.length - 1];
              if (top && top.settings.lock !== true) {
                top.cancel();
              }
            }
          };
        }

        _createClass(DialogRenderer, [{
          key: 'getDialogContainer',
          value: function getDialogContainer() {
            return DOM.createElement('div');
          }
        }, {
          key: 'showDialog',
          value: function showDialog(dialogController) {
            var _this2 = this;

            var settings = dialogController.settings;
            var body = DOM.querySelectorAll('body')[0];
            var wrapper = document.createElement('div');

            this.modalOverlay = DOM.createElement(overlayTagName);
            this.modalContainer = DOM.createElement(containerTagName);
            this.anchor = dialogController.slot.anchor;
            wrapper.appendChild(this.anchor);
            this.modalContainer.appendChild(wrapper);

            this.stopPropagation = function (e) {
              e._aureliaDialogHostClicked = true;
            };
            this.closeModalClick = function (e) {
              if (!settings.lock && !e._aureliaDialogHostClicked) {
                dialogController.cancel();
              } else {
                return false;
              }
            };

            dialogController.centerDialog = function () {
              if (settings.centerHorizontalOnly) return;
              centerDialog(_this2.modalContainer);
            };

            this.modalOverlay.style.zIndex = settings.startingZIndex;
            this.modalContainer.style.zIndex = settings.startingZIndex;

            var lastContainer = Array.from(body.querySelectorAll(containerTagName)).pop();

            if (lastContainer) {
              lastContainer.parentNode.insertBefore(this.modalContainer, lastContainer.nextSibling);
              lastContainer.parentNode.insertBefore(this.modalOverlay, lastContainer.nextSibling);
            } else {
              body.insertBefore(this.modalContainer, body.firstChild);
              body.insertBefore(this.modalOverlay, body.firstChild);
            }

            if (!this._dialogControllers.length) {
              DOM.addEventListener('keyup', this._escapeKeyEventHandler);
            }

            this._dialogControllers.push(dialogController);

            dialogController.slot.attached();

            if (typeof settings.position === 'function') {
              settings.position(this.modalContainer, this.modalOverlay);
            } else {
              dialogController.centerDialog();
            }

            this.modalContainer.addEventListener('click', this.closeModalClick);
            this.anchor.addEventListener('click', this.stopPropagation);

            return new Promise(function (resolve) {
              var renderer = _this2;
              if (settings.ignoreTransitions) {
                resolve();
              } else {
                _this2.modalContainer.addEventListener(transitionEvent(), onTransitionEnd);
              }

              _this2.modalOverlay.classList.add('active');
              _this2.modalContainer.classList.add('active');
              body.classList.add('ai-dialog-open');

              function onTransitionEnd(e) {
                if (e.target !== renderer.modalContainer) {
                  return;
                }
                renderer.modalContainer.removeEventListener(transitionEvent(), onTransitionEnd);
                resolve();
              }
            });
          }
        }, {
          key: 'hideDialog',
          value: function hideDialog(dialogController) {
            var _this3 = this;

            var settings = dialogController.settings;
            var body = DOM.querySelectorAll('body')[0];

            this.modalContainer.removeEventListener('click', this.closeModalClick);
            this.anchor.removeEventListener('click', this.stopPropagation);

            var i = this._dialogControllers.indexOf(dialogController);
            if (i !== -1) {
              this._dialogControllers.splice(i, 1);
            }

            if (!this._dialogControllers.length) {
              DOM.removeEventListener('keyup', this._escapeKeyEventHandler);
            }

            return new Promise(function (resolve) {
              var renderer = _this3;
              if (settings.ignoreTransitions) {
                resolve();
              } else {
                _this3.modalContainer.addEventListener(transitionEvent(), onTransitionEnd);
              }

              _this3.modalOverlay.classList.remove('active');
              _this3.modalContainer.classList.remove('active');

              function onTransitionEnd() {
                renderer.modalContainer.removeEventListener(transitionEvent(), onTransitionEnd);
                resolve();
              }
            }).then(function () {
              body.removeChild(_this3.modalOverlay);
              body.removeChild(_this3.modalContainer);
              dialogController.slot.detached();

              if (!_this3._dialogControllers.length) {
                body.classList.remove('ai-dialog-open');
              }

              return Promise.resolve();
            });
          }
        }]);

        return DialogRenderer;
      }()) || _class));

      _export('DialogRenderer', DialogRenderer);

      DialogRenderer.prototype._dialogControllers = [];
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/dialog-configuration.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'npm:systemjs-plugin-babel@0.0.17/babel-helpers/createClass.js', './renderer', './dialog-renderer', './dialog-options', 'aurelia-pal'], function (_export, _context) {
  "use strict";

  var _classCallCheck, _createClass, Renderer, DialogRenderer, dialogOptions, DOM, defaultRenderer, resources, defaultCSSText, DialogConfiguration;

  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_npmSystemjsPluginBabel0017BabelHelpersCreateClassJs) {
      _createClass = _npmSystemjsPluginBabel0017BabelHelpersCreateClassJs.default;
    }, function (_renderer) {
      Renderer = _renderer.Renderer;
    }, function (_dialogRenderer) {
      DialogRenderer = _dialogRenderer.DialogRenderer;
    }, function (_dialogOptions) {
      dialogOptions = _dialogOptions.dialogOptions;
    }, function (_aureliaPal) {
      DOM = _aureliaPal.DOM;
    }],
    execute: function () {
      defaultRenderer = DialogRenderer;
      resources = {
        'ai-dialog': './ai-dialog',
        'ai-dialog-header': './ai-dialog-header',
        'ai-dialog-body': './ai-dialog-body',
        'ai-dialog-footer': './ai-dialog-footer',
        'attach-focus': './attach-focus'
      };
      defaultCSSText = 'ai-dialog-container,ai-dialog-overlay{position:fixed;top:0;right:0;bottom:0;left:0}ai-dialog-overlay{opacity:0}ai-dialog-overlay.active{opacity:1}ai-dialog-container{display:block;transition:opacity .2s linear;opacity:0;overflow-x:hidden;overflow-y:auto;-webkit-overflow-scrolling:touch}ai-dialog-container.active{opacity:1}ai-dialog-container>div{padding:30px}ai-dialog-container>div>div{display:block;min-width:300px;width:-moz-fit-content;width:-webkit-fit-content;width:fit-content;height:-moz-fit-content;height:-webkit-fit-content;height:fit-content;margin:auto}ai-dialog-container,ai-dialog-container>div,ai-dialog-container>div>div{outline:0}ai-dialog{display:table;box-shadow:0 5px 15px rgba(0,0,0,.5);border:1px solid rgba(0,0,0,.2);border-radius:5px;padding:3;min-width:300px;width:-moz-fit-content;width:-webkit-fit-content;width:fit-content;height:-moz-fit-content;height:-webkit-fit-content;height:fit-content;margin:auto;border-image-source:initial;border-image-slice:initial;border-image-width:initial;border-image-outset:initial;border-image-repeat:initial;background:#fff}ai-dialog>ai-dialog-header{display:block;padding:16px;border-bottom:1px solid #e5e5e5}ai-dialog>ai-dialog-header>button{float:right;border:none;display:block;width:32px;height:32px;background:0 0;font-size:22px;line-height:16px;margin:-14px -16px 0 0;padding:0;cursor:pointer}ai-dialog>ai-dialog-body{display:block;padding:16px}ai-dialog>ai-dialog-footer{display:block;padding:6px;border-top:1px solid #e5e5e5;text-align:right}ai-dialog>ai-dialog-footer button{color:#333;background-color:#fff;padding:6px 12px;font-size:14px;text-align:center;white-space:nowrap;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;background-image:none;border:1px solid #ccc;border-radius:4px;margin:5px 0 5px 5px}ai-dialog>ai-dialog-footer button:disabled{cursor:default;opacity:.45}ai-dialog>ai-dialog-footer button:hover:enabled{color:#333;background-color:#e6e6e6;border-color:#adadad}.ai-dialog-open{overflow:hidden}';

      _export('DialogConfiguration', DialogConfiguration = function () {
        function DialogConfiguration(aurelia) {
          _classCallCheck(this, DialogConfiguration);

          this.aurelia = aurelia;
          this.settings = dialogOptions;
          this.resources = [];
          this.cssText = defaultCSSText;
          this.renderer = defaultRenderer;
        }

        _createClass(DialogConfiguration, [{
          key: 'useDefaults',
          value: function useDefaults() {
            return this.useRenderer(defaultRenderer).useCSS(defaultCSSText).useStandardResources();
          }
        }, {
          key: 'useStandardResources',
          value: function useStandardResources() {
            return this.useResource('ai-dialog').useResource('ai-dialog-header').useResource('ai-dialog-body').useResource('ai-dialog-footer').useResource('attach-focus');
          }
        }, {
          key: 'useResource',
          value: function useResource(resourceName) {
            this.resources.push(resourceName);
            return this;
          }
        }, {
          key: 'useRenderer',
          value: function useRenderer(renderer, settings) {
            this.renderer = renderer;
            this.settings = Object.assign(this.settings, settings || {});
            return this;
          }
        }, {
          key: 'useCSS',
          value: function useCSS(cssText) {
            this.cssText = cssText;
            return this;
          }
        }, {
          key: '_apply',
          value: function _apply() {
            var _this = this;

            this.aurelia.transient(Renderer, this.renderer);
            this.resources.forEach(function (resourceName) {
              return _this.aurelia.globalResources(resources[resourceName]);
            });

            if (this.cssText) {
              DOM.injectStyles(this.cssText);
            }
          }
        }]);

        return DialogConfiguration;
      }());

      _export('DialogConfiguration', DialogConfiguration);
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/ai-dialog.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'aurelia-templating'], function (_export, _context) {
  "use strict";

  var _classCallCheck, customElement, inlineView, _dec, _dec2, _class, AiDialog;

  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_aureliaTemplating) {
      customElement = _aureliaTemplating.customElement;
      inlineView = _aureliaTemplating.inlineView;
    }],
    execute: function () {
      _export('AiDialog', AiDialog = (_dec = customElement('ai-dialog'), _dec2 = inlineView('\n  <template>\n    <slot></slot>\n  </template>\n'), _dec(_class = _dec2(_class = function AiDialog() {
        _classCallCheck(this, AiDialog);
      }) || _class) || _class));

      _export('AiDialog', AiDialog);
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/ai-dialog-header.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'aurelia-templating', './dialog-controller'], function (_export, _context) {
  "use strict";

  var _classCallCheck, customElement, inlineView, DialogController, _dec, _dec2, _class, _class2, _temp, AiDialogHeader;

  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_aureliaTemplating) {
      customElement = _aureliaTemplating.customElement;
      inlineView = _aureliaTemplating.inlineView;
    }, function (_dialogController) {
      DialogController = _dialogController.DialogController;
    }],
    execute: function () {
      _export('AiDialogHeader', AiDialogHeader = (_dec = customElement('ai-dialog-header'), _dec2 = inlineView('\n  <template>\n    <button type="button" class="dialog-close" aria-label="Close" if.bind="!controller.settings.lock" click.trigger="controller.cancel()">\n      <span aria-hidden="true">&times;</span>\n    </button>\n\n    <div class="dialog-header-content">\n      <slot></slot>\n    </div>\n  </template>\n'), _dec(_class = _dec2(_class = (_temp = _class2 = function AiDialogHeader(controller) {
        _classCallCheck(this, AiDialogHeader);

        this.controller = controller;
      }, _class2.inject = [DialogController], _temp)) || _class) || _class));

      _export('AiDialogHeader', AiDialogHeader);
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/ai-dialog-body.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'aurelia-templating'], function (_export, _context) {
  "use strict";

  var _classCallCheck, customElement, inlineView, _dec, _dec2, _class, AiDialogBody;

  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_aureliaTemplating) {
      customElement = _aureliaTemplating.customElement;
      inlineView = _aureliaTemplating.inlineView;
    }],
    execute: function () {
      _export('AiDialogBody', AiDialogBody = (_dec = customElement('ai-dialog-body'), _dec2 = inlineView('\n  <template>\n    <slot></slot>\n  </template>\n'), _dec(_class = _dec2(_class = function AiDialogBody() {
        _classCallCheck(this, AiDialogBody);
      }) || _class) || _class));

      _export('AiDialogBody', AiDialogBody);
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/ai-dialog-footer.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'npm:systemjs-plugin-babel@0.0.17/babel-helpers/createClass.js', 'aurelia-templating', './dialog-controller'], function (_export, _context) {
  "use strict";

  var _classCallCheck, _createClass, customElement, bindable, inlineView, DialogController, _dec, _dec2, _class, _desc, _value, _class2, _descriptor, _descriptor2, _class3, _temp, AiDialogFooter;

  function _initDefineProp(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');
  }

  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_npmSystemjsPluginBabel0017BabelHelpersCreateClassJs) {
      _createClass = _npmSystemjsPluginBabel0017BabelHelpersCreateClassJs.default;
    }, function (_aureliaTemplating) {
      customElement = _aureliaTemplating.customElement;
      bindable = _aureliaTemplating.bindable;
      inlineView = _aureliaTemplating.inlineView;
    }, function (_dialogController) {
      DialogController = _dialogController.DialogController;
    }],
    execute: function () {
      _export('AiDialogFooter', AiDialogFooter = (_dec = customElement('ai-dialog-footer'), _dec2 = inlineView('\n  <template>\n    <slot></slot>\n\n    <template if.bind="buttons.length > 0">\n      <button type="button" class="btn btn-default" repeat.for="button of buttons" click.trigger="close(button)">${button}</button>\n    </template>\n  </template>\n'), _dec(_class = _dec2(_class = (_class2 = (_temp = _class3 = function () {
        function AiDialogFooter(controller) {
          _classCallCheck(this, AiDialogFooter);

          _initDefineProp(this, 'buttons', _descriptor, this);

          _initDefineProp(this, 'useDefaultButtons', _descriptor2, this);

          this.controller = controller;
        }

        _createClass(AiDialogFooter, [{
          key: 'close',
          value: function close(buttonValue) {
            if (AiDialogFooter.isCancelButton(buttonValue)) {
              this.controller.cancel(buttonValue);
            } else {
              this.controller.ok(buttonValue);
            }
          }
        }, {
          key: 'useDefaultButtonsChanged',
          value: function useDefaultButtonsChanged(newValue) {
            if (newValue) {
              this.buttons = ['Cancel', 'Ok'];
            }
          }
        }], [{
          key: 'isCancelButton',
          value: function isCancelButton(value) {
            return value === 'Cancel';
          }
        }]);

        return AiDialogFooter;
      }(), _class3.inject = [DialogController], _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'buttons', [bindable], {
        enumerable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'useDefaultButtons', [bindable], {
        enumerable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2)) || _class) || _class));

      _export('AiDialogFooter', AiDialogFooter);
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/attach-focus.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'npm:systemjs-plugin-babel@0.0.17/babel-helpers/createClass.js', 'aurelia-templating'], function (_export, _context) {
  "use strict";

  var _classCallCheck, _createClass, customAttribute, _dec, _class, _class2, _temp, AttachFocus;

  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_npmSystemjsPluginBabel0017BabelHelpersCreateClassJs) {
      _createClass = _npmSystemjsPluginBabel0017BabelHelpersCreateClassJs.default;
    }, function (_aureliaTemplating) {
      customAttribute = _aureliaTemplating.customAttribute;
    }],
    execute: function () {
      _export('AttachFocus', AttachFocus = (_dec = customAttribute('attach-focus'), _dec(_class = (_temp = _class2 = function () {
        function AttachFocus(element) {
          _classCallCheck(this, AttachFocus);

          this.value = true;

          this.element = element;
        }

        _createClass(AttachFocus, [{
          key: 'attached',
          value: function attached() {
            if (this.value && this.value !== 'false') {
              this.element.focus();
            }
          }
        }, {
          key: 'valueChanged',
          value: function valueChanged(newValue) {
            this.value = newValue;
          }
        }]);

        return AttachFocus;
      }(), _class2.inject = [Element], _temp)) || _class));

      _export('AttachFocus', AttachFocus);
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/renderer.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'npm:systemjs-plugin-babel@0.0.17/babel-helpers/createClass.js'], function (_export, _context) {
  "use strict";

  var _classCallCheck, _createClass, Renderer;

  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_npmSystemjsPluginBabel0017BabelHelpersCreateClassJs) {
      _createClass = _npmSystemjsPluginBabel0017BabelHelpersCreateClassJs.default;
    }],
    execute: function () {
      _export('Renderer', Renderer = function () {
        function Renderer() {
          _classCallCheck(this, Renderer);
        }

        _createClass(Renderer, [{
          key: 'getDialogContainer',
          value: function getDialogContainer() {
            throw new Error('DialogRenderer must implement getDialogContainer().');
          }
        }, {
          key: 'showDialog',
          value: function showDialog(dialogController) {
            throw new Error('DialogRenderer must implement showDialog().');
          }
        }, {
          key: 'hideDialog',
          value: function hideDialog(dialogController) {
            throw new Error('DialogRenderer must implement hideDialog().');
          }
        }]);

        return Renderer;
      }());

      _export('Renderer', Renderer);
    }
  };
});
System.register("npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/dialog-options.js", [], function (_export, _context) {
  "use strict";

  var dialogOptions;
  return {
    setters: [],
    execute: function () {
      _export("dialogOptions", dialogOptions = {
        lock: true,
        centerHorizontalOnly: false,
        startingZIndex: 1000,
        ignoreTransitions: false
      });

      _export("dialogOptions", dialogOptions);
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/dialog-service.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'npm:systemjs-plugin-babel@0.0.17/babel-helpers/createClass.js', 'aurelia-metadata', 'aurelia-dependency-injection', 'aurelia-templating', './dialog-controller', './renderer', './lifecycle', './dialog-result', './dialog-options'], function (_export, _context) {
  "use strict";

  var _classCallCheck, _createClass, Origin, Container, CompositionEngine, ViewSlot, DialogController, Renderer, invokeLifecycle, DialogResult, dialogOptions, _class, _temp, DialogService;

  function _createSettings(settings) {
    settings = Object.assign({}, dialogOptions, settings);
    settings.startingZIndex = dialogOptions.startingZIndex;
    return settings;
  }

  function _openDialog(service, childContainer, dialogController) {
    var host = dialogController.renderer.getDialogContainer();
    var instruction = {
      container: service.container,
      childContainer: childContainer,
      model: dialogController.settings.model,
      view: dialogController.settings.view,
      viewModel: dialogController.settings.viewModel,
      viewSlot: new ViewSlot(host, true),
      host: host
    };

    return _getViewModel(instruction, service.compositionEngine).then(function (returnedInstruction) {
      dialogController.viewModel = returnedInstruction.viewModel;
      dialogController.slot = returnedInstruction.viewSlot;

      return invokeLifecycle(dialogController.viewModel, 'canActivate', dialogController.settings.model).then(function (canActivate) {
        if (canActivate) {
          return service.compositionEngine.compose(returnedInstruction).then(function (controller) {
            service.controllers.push(dialogController);
            service.hasActiveDialog = !!service.controllers.length;
            dialogController.controller = controller;
            dialogController.view = controller.view;

            return dialogController.renderer.showDialog(dialogController);
          });
        }
      });
    });
  }

  function _getViewModel(instruction, compositionEngine) {
    if (typeof instruction.viewModel === 'function') {
      instruction.viewModel = Origin.get(instruction.viewModel).moduleId;
    }

    if (typeof instruction.viewModel === 'string') {
      return compositionEngine.ensureViewModel(instruction);
    }

    return Promise.resolve(instruction);
  }

  function _removeController(service, controller) {
    var i = service.controllers.indexOf(controller);
    if (i !== -1) {
      service.controllers.splice(i, 1);
      service.hasActiveDialog = !!service.controllers.length;
    }
  }
  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_npmSystemjsPluginBabel0017BabelHelpersCreateClassJs) {
      _createClass = _npmSystemjsPluginBabel0017BabelHelpersCreateClassJs.default;
    }, function (_aureliaMetadata) {
      Origin = _aureliaMetadata.Origin;
    }, function (_aureliaDependencyInjection) {
      Container = _aureliaDependencyInjection.Container;
    }, function (_aureliaTemplating) {
      CompositionEngine = _aureliaTemplating.CompositionEngine;
      ViewSlot = _aureliaTemplating.ViewSlot;
    }, function (_dialogController) {
      DialogController = _dialogController.DialogController;
    }, function (_renderer) {
      Renderer = _renderer.Renderer;
    }, function (_lifecycle) {
      invokeLifecycle = _lifecycle.invokeLifecycle;
    }, function (_dialogResult) {
      DialogResult = _dialogResult.DialogResult;
    }, function (_dialogOptions) {
      dialogOptions = _dialogOptions.dialogOptions;
    }],
    execute: function () {
      _export('DialogService', DialogService = (_temp = _class = function () {
        function DialogService(container, compositionEngine) {
          _classCallCheck(this, DialogService);

          this.container = container;
          this.compositionEngine = compositionEngine;
          this.controllers = [];
          this.hasActiveDialog = false;
        }

        _createClass(DialogService, [{
          key: 'open',
          value: function open(settings) {
            return this.openAndYieldController(settings).then(function (controller) {
              return controller.result;
            });
          }
        }, {
          key: 'openAndYieldController',
          value: function openAndYieldController(settings) {
            var _this = this;

            var childContainer = this.container.createChild();
            var dialogController = void 0;
            var promise = new Promise(function (resolve, reject) {
              dialogController = new DialogController(childContainer.get(Renderer), _createSettings(settings), resolve, reject);
            });
            childContainer.registerInstance(DialogController, dialogController);
            dialogController.result = promise;
            dialogController.result.then(function () {
              _removeController(_this, dialogController);
            }, function () {
              _removeController(_this, dialogController);
            });
            return _openDialog(this, childContainer, dialogController).then(function () {
              return dialogController;
            });
          }
        }]);

        return DialogService;
      }(), _class.inject = [Container, CompositionEngine], _temp));

      _export('DialogService', DialogService);
    }
  };
});
System.register("npm:systemjs-plugin-babel@0.0.17/babel-helpers/createClass.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }());
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/lifecycle.js', [], function (_export, _context) {
  "use strict";

  function invokeLifecycle(instance, name, model) {
    if (typeof instance[name] === 'function') {
      var result = instance[name](model);

      if (result instanceof Promise) {
        return result;
      }

      if (result !== null && result !== undefined) {
        return Promise.resolve(result);
      }

      return Promise.resolve(true);
    }

    return Promise.resolve(true);
  }

  _export('invokeLifecycle', invokeLifecycle);

  return {
    setters: [],
    execute: function () {}
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/dialog-controller.js', ['npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js', 'npm:systemjs-plugin-babel@0.0.17/babel-helpers/createClass.js', './lifecycle', './dialog-result'], function (_export, _context) {
  "use strict";

  var _classCallCheck, _createClass, invokeLifecycle, DialogResult, DialogController;

  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }, function (_npmSystemjsPluginBabel0017BabelHelpersCreateClassJs) {
      _createClass = _npmSystemjsPluginBabel0017BabelHelpersCreateClassJs.default;
    }, function (_lifecycle) {
      invokeLifecycle = _lifecycle.invokeLifecycle;
    }, function (_dialogResult) {
      DialogResult = _dialogResult.DialogResult;
    }],
    execute: function () {
      _export('DialogController', DialogController = function () {
        function DialogController(renderer, settings, resolve, reject) {
          _classCallCheck(this, DialogController);

          this.renderer = renderer;
          this.settings = settings;
          this._resolve = resolve;
          this._reject = reject;
        }

        _createClass(DialogController, [{
          key: 'ok',
          value: function ok(output) {
            return this.close(true, output);
          }
        }, {
          key: 'cancel',
          value: function cancel(output) {
            return this.close(false, output);
          }
        }, {
          key: 'error',
          value: function error(message) {
            var _this = this;

            return invokeLifecycle(this.viewModel, 'deactivate').then(function () {
              return _this.renderer.hideDialog(_this);
            }).then(function () {
              _this.controller.unbind();
              _this._reject(message);
            });
          }
        }, {
          key: 'close',
          value: function close(ok, output) {
            var _this2 = this;

            if (this._closePromise) {
              return this._closePromise;
            }

            this._closePromise = invokeLifecycle(this.viewModel, 'canDeactivate').then(function (canDeactivate) {
              if (canDeactivate) {
                return invokeLifecycle(_this2.viewModel, 'deactivate').then(function () {
                  return _this2.renderer.hideDialog(_this2);
                }).then(function () {
                  var result = new DialogResult(!ok, output);
                  _this2.controller.unbind();
                  _this2._resolve(result);
                  return result;
                });
              }

              _this2._closePromise = undefined;
            }, function (e) {
              _this2._closePromise = undefined;
              return Promise.reject(e);
            });

            return this._closePromise;
          }
        }]);

        return DialogController;
      }());

      _export('DialogController', DialogController);
    }
  };
});
System.register("npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      });
    }
  };
});
System.register("npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/dialog-result.js", ["npm:systemjs-plugin-babel@0.0.17/babel-helpers/classCallCheck.js"], function (_export, _context) {
  "use strict";

  var _classCallCheck, DialogResult;

  return {
    setters: [function (_npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs) {
      _classCallCheck = _npmSystemjsPluginBabel0017BabelHelpersClassCallCheckJs.default;
    }],
    execute: function () {
      _export("DialogResult", DialogResult = function DialogResult(cancelled, output) {
        _classCallCheck(this, DialogResult);

        this.wasCancelled = false;

        this.wasCancelled = cancelled;
        this.output = output;
      });

      _export("DialogResult", DialogResult);
    }
  };
});
System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/aurelia-dialog.js', ['./dialog-configuration', './ai-dialog', './ai-dialog-header', './ai-dialog-body', './ai-dialog-footer', './attach-focus', './dialog-service', './dialog-controller', './dialog-result'], function (_export, _context) {
  "use strict";

  var DialogConfiguration;
  function configure(aurelia, callback) {
    var config = new DialogConfiguration(aurelia);

    if (typeof callback === 'function') {
      callback(config);
    } else {
      config.useDefaults();
    }

    config._apply();
  }

  _export('configure', configure);

  return {
    setters: [function (_dialogConfiguration) {
      DialogConfiguration = _dialogConfiguration.DialogConfiguration;
      var _exportObj = {};
      _exportObj.DialogConfiguration = _dialogConfiguration.DialogConfiguration;

      _export(_exportObj);
    }, function (_aiDialog) {
      var _exportObj2 = {};
      _exportObj2.AiDialog = _aiDialog.AiDialog;

      _export(_exportObj2);
    }, function (_aiDialogHeader) {
      var _exportObj3 = {};
      _exportObj3.AiDialogHeader = _aiDialogHeader.AiDialogHeader;

      _export(_exportObj3);
    }, function (_aiDialogBody) {
      var _exportObj4 = {};
      _exportObj4.AiDialogBody = _aiDialogBody.AiDialogBody;

      _export(_exportObj4);
    }, function (_aiDialogFooter) {
      var _exportObj5 = {};
      _exportObj5.AiDialogFooter = _aiDialogFooter.AiDialogFooter;

      _export(_exportObj5);
    }, function (_attachFocus) {
      var _exportObj6 = {};
      _exportObj6.AttachFocus = _attachFocus.AttachFocus;

      _export(_exportObj6);
    }, function (_dialogService) {
      var _exportObj7 = {};
      _exportObj7.DialogService = _dialogService.DialogService;

      _export(_exportObj7);
    }, function (_dialogController) {
      var _exportObj8 = {};
      _exportObj8.DialogController = _dialogController.DialogController;

      _export(_exportObj8);
    }, function (_dialogResult) {
      var _exportObj9 = {};
      _exportObj9.DialogResult = _dialogResult.DialogResult;

      _export(_exportObj9);
    }],
    execute: function () {}
  };
});
System.registerDynamic("npm:aurelia-dialog@1.0.0-beta.3.0.1.json", [], true, function() {
  return {
    "main": "dist/es2015/index",
    "format": "esm"
  };
});

System.register('npm:aurelia-dialog@1.0.0-beta.3.0.1/dist/es2015/index.js', ['./aurelia-dialog'], function (_export, _context) {
  "use strict";

  return {
    setters: [function (_aureliaDialog) {
      var _exportObj = {};

      for (var _key in _aureliaDialog) {
        if (_key !== "default" && _key !== "__esModule") _exportObj[_key] = _aureliaDialog[_key];
      }

      _export(_exportObj);
    }],
    execute: function () {}
  };
});
System.registerDynamic("npm:aurelia-fetch-client@1.1.2.json", [], true, function() {
  return {
    "main": "aurelia-fetch-client",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-fetch-client@1.1.2/aurelia-fetch-client.js', [], false, function ($__require, $__exports, $__module) {
  return (function (exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.json = json;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };

    function json(body) {
      return new Blob([JSON.stringify(body !== undefined ? body : {})], { type: 'application/json' });
    }

    var HttpClientConfiguration = exports.HttpClientConfiguration = function () {
      function HttpClientConfiguration() {

        this.baseUrl = '';
        this.defaults = {};
        this.interceptors = [];
      }

      HttpClientConfiguration.prototype.withBaseUrl = function withBaseUrl(baseUrl) {
        this.baseUrl = baseUrl;
        return this;
      };

      HttpClientConfiguration.prototype.withDefaults = function withDefaults(defaults) {
        this.defaults = defaults;
        return this;
      };

      HttpClientConfiguration.prototype.withInterceptor = function withInterceptor(interceptor) {
        this.interceptors.push(interceptor);
        return this;
      };

      HttpClientConfiguration.prototype.useStandardConfiguration = function useStandardConfiguration() {
        var standardConfig = { credentials: 'same-origin' };
        Object.assign(this.defaults, standardConfig, this.defaults);
        return this.rejectErrorResponses();
      };

      HttpClientConfiguration.prototype.rejectErrorResponses = function rejectErrorResponses() {
        return this.withInterceptor({ response: rejectOnError });
      };

      return HttpClientConfiguration;
    }();

    function rejectOnError(response) {
      if (!response.ok) {
        throw response;
      }

      return response;
    }

    var HttpClient = exports.HttpClient = function () {
      function HttpClient() {

        this.activeRequestCount = 0;
        this.isRequesting = false;
        this.isConfigured = false;
        this.baseUrl = '';
        this.defaults = null;
        this.interceptors = [];

        if (typeof fetch === 'undefined') {
          throw new Error('HttpClient requires a Fetch API implementation, but the current environment doesn\'t support it. You may need to load a polyfill such as https://github.com/github/fetch.');
        }
      }

      HttpClient.prototype.configure = function configure(config) {
        var normalizedConfig = void 0;

        if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {
          normalizedConfig = { defaults: config };
        } else if (typeof config === 'function') {
          normalizedConfig = new HttpClientConfiguration();
          normalizedConfig.baseUrl = this.baseUrl;
          normalizedConfig.defaults = Object.assign({}, this.defaults);
          normalizedConfig.interceptors = this.interceptors;

          var c = config(normalizedConfig);
          if (HttpClientConfiguration.prototype.isPrototypeOf(c)) {
            normalizedConfig = c;
          }
        } else {
          throw new Error('invalid config');
        }

        var defaults = normalizedConfig.defaults;
        if (defaults && Headers.prototype.isPrototypeOf(defaults.headers)) {
          throw new Error('Default headers must be a plain object.');
        }

        this.baseUrl = normalizedConfig.baseUrl;
        this.defaults = defaults;
        this.interceptors = normalizedConfig.interceptors || [];
        this.isConfigured = true;

        return this;
      };

      HttpClient.prototype.fetch = function (_fetch) {
        function fetch(_x, _x2) {
          return _fetch.apply(this, arguments);
        }

        fetch.toString = function () {
          return _fetch.toString();
        };

        return fetch;
      }(function (input, init) {
        var _this = this;

        trackRequestStart.call(this);

        var request = Promise.resolve().then(function () {
          return buildRequest.call(_this, input, init, _this.defaults);
        });
        var promise = processRequest(request, this.interceptors).then(function (result) {
          var response = null;

          if (Response.prototype.isPrototypeOf(result)) {
            response = result;
          } else if (Request.prototype.isPrototypeOf(result)) {
            request = Promise.resolve(result);
            response = fetch(result);
          } else {
            throw new Error('An invalid result was returned by the interceptor chain. Expected a Request or Response instance, but got [' + result + ']');
          }

          return request.then(function (_request) {
            return processResponse(response, _this.interceptors, _request);
          });
        });

        return trackRequestEndWith.call(this, promise);
      });

      return HttpClient;
    }();

    var absoluteUrlRegexp = /^([a-z][a-z0-9+\-.]*:)?\/\//i;

    function trackRequestStart() {
      this.isRequesting = !!++this.activeRequestCount;
    }

    function trackRequestEnd() {
      this.isRequesting = !! --this.activeRequestCount;
    }

    function trackRequestEndWith(promise) {
      var handle = trackRequestEnd.bind(this);
      promise.then(handle, handle);
      return promise;
    }

    function parseHeaderValues(headers) {
      var parsedHeaders = {};
      for (var name in headers || {}) {
        if (headers.hasOwnProperty(name)) {
          parsedHeaders[name] = typeof headers[name] === 'function' ? headers[name]() : headers[name];
        }
      }
      return parsedHeaders;
    }

    function buildRequest(input, init) {
      var defaults = this.defaults || {};
      var request = void 0;
      var body = void 0;
      var requestContentType = void 0;

      var parsedDefaultHeaders = parseHeaderValues(defaults.headers);
      if (Request.prototype.isPrototypeOf(input)) {
        request = input;
        requestContentType = new Headers(request.headers).get('Content-Type');
      } else {
        init || (init = {});
        body = init.body;
        var bodyObj = body ? { body: body } : null;
        var requestInit = Object.assign({}, defaults, { headers: {} }, init, bodyObj);
        requestContentType = new Headers(requestInit.headers).get('Content-Type');
        request = new Request(getRequestUrl(this.baseUrl, input), requestInit);
      }
      if (!requestContentType && new Headers(parsedDefaultHeaders).has('content-type')) {
        request.headers.set('Content-Type', new Headers(parsedDefaultHeaders).get('content-type'));
      }
      setDefaultHeaders(request.headers, parsedDefaultHeaders);
      if (body && Blob.prototype.isPrototypeOf(body) && body.type) {
        request.headers.set('Content-Type', body.type);
      }
      return request;
    }

    function getRequestUrl(baseUrl, url) {
      if (absoluteUrlRegexp.test(url)) {
        return url;
      }

      return (baseUrl || '') + url;
    }

    function setDefaultHeaders(headers, defaultHeaders) {
      for (var name in defaultHeaders || {}) {
        if (defaultHeaders.hasOwnProperty(name) && !headers.has(name)) {
          headers.set(name, defaultHeaders[name]);
        }
      }
    }

    function processRequest(request, interceptors) {
      return applyInterceptors(request, interceptors, 'request', 'requestError');
    }

    function processResponse(response, interceptors, request) {
      return applyInterceptors(response, interceptors, 'response', 'responseError', request);
    }

    function applyInterceptors(input, interceptors, successName, errorName) {
      for (var _len = arguments.length, interceptorArgs = Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        interceptorArgs[_key - 4] = arguments[_key];
      }

      return (interceptors || []).reduce(function (chain, interceptor) {
        var successHandler = interceptor[successName];
        var errorHandler = interceptor[errorName];

        return chain.then(successHandler && function (value) {
          return successHandler.call.apply(successHandler, [interceptor, value].concat(interceptorArgs));
        } || identity, errorHandler && function (reason) {
          return errorHandler.call.apply(errorHandler, [interceptor, reason].concat(interceptorArgs));
        } || thrower);
      }, Promise.resolve(input));
    }

    function identity(x) {
      return x;
    }

    function thrower(x) {
      throw x;
    }
  }).call($__exports, $__exports, $__require);
});
System.registerDynamic("npm:aurelia-binding@1.2.1.json", [], true, function() {
  return {
    "main": "aurelia-binding",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-binding@1.2.1/aurelia-binding.js', ['aurelia-logging', 'aurelia-pal', 'aurelia-task-queue', 'aurelia-metadata'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaLogging, _aureliaPal, _aureliaTaskQueue, _aureliaMetadata) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getSetObserver = exports.BindingEngine = exports.NameExpression = exports.Listener = exports.ListenerExpression = exports.BindingBehaviorResource = exports.ValueConverterResource = exports.Call = exports.CallExpression = exports.Binding = exports.BindingExpression = exports.ObjectObservationAdapter = exports.ObserverLocator = exports.SVGAnalyzer = exports.presentationAttributes = exports.presentationElements = exports.elements = exports.ComputedExpression = exports.ClassObserver = exports.SelectValueObserver = exports.CheckedObserver = exports.ValueAttributeObserver = exports.StyleObserver = exports.DataAttributeObserver = exports.dataAttributeAccessor = exports.XLinkAttributeObserver = exports.SetterObserver = exports.PrimitiveObserver = exports.propertyAccessor = exports.DirtyCheckProperty = exports.DirtyChecker = exports.EventManager = exports.delegationStrategy = exports.getMapObserver = exports.ParserImplementation = exports.Parser = exports.Scanner = exports.Lexer = exports.Token = exports.bindingMode = exports.ExpressionCloner = exports.Unparser = exports.LiteralObject = exports.LiteralArray = exports.LiteralString = exports.LiteralPrimitive = exports.PrefixNot = exports.Binary = exports.CallFunction = exports.CallMember = exports.CallScope = exports.AccessKeyed = exports.AccessMember = exports.AccessScope = exports.AccessThis = exports.Conditional = exports.Assign = exports.ValueConverter = exports.BindingBehavior = exports.Chain = exports.Expression = exports.getArrayObserver = exports.CollectionLengthObserver = exports.ModifyCollectionObserver = exports.ExpressionObserver = exports.sourceContext = undefined;
    exports.camelCase = camelCase;
    exports.createOverrideContext = createOverrideContext;
    exports.getContextFor = getContextFor;
    exports.createScopeForTest = createScopeForTest;
    exports.connectable = connectable;
    exports.enqueueBindingConnect = enqueueBindingConnect;
    exports.subscriberCollection = subscriberCollection;
    exports.calcSplices = calcSplices;
    exports.mergeSplice = mergeSplice;
    exports.projectArraySplices = projectArraySplices;
    exports.getChangeRecords = getChangeRecords;
    exports.cloneExpression = cloneExpression;
    exports.hasDeclaredDependencies = hasDeclaredDependencies;
    exports.declarePropertyDependencies = declarePropertyDependencies;
    exports.computedFrom = computedFrom;
    exports.createComputedObserver = createComputedObserver;
    exports.valueConverter = valueConverter;
    exports.bindingBehavior = bindingBehavior;
    exports.observable = observable;

    var LogManager = _interopRequireWildcard(_aureliaLogging);

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};

        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }

        newObj.default = obj;
        return newObj;
      }
    }

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var _dec, _dec2, _class, _dec3, _class2, _dec4, _class3, _dec5, _class5, _dec6, _class7, _dec7, _class8, _dec8, _class9, _dec9, _class10, _class12, _temp, _dec10, _class13, _class14, _temp2;

    var map = Object.create(null);

    function camelCase(name) {
      if (name in map) {
        return map[name];
      }
      var result = name.charAt(0).toLowerCase() + name.slice(1).replace(/[_.-](\w|$)/g, function (_, x) {
        return x.toUpperCase();
      });
      map[name] = result;
      return result;
    }

    function createOverrideContext(bindingContext, parentOverrideContext) {
      return {
        bindingContext: bindingContext,
        parentOverrideContext: parentOverrideContext || null
      };
    }

    function getContextFor(name, scope, ancestor) {
      var oc = scope.overrideContext;

      if (ancestor) {
        while (ancestor && oc) {
          ancestor--;
          oc = oc.parentOverrideContext;
        }
        if (ancestor || !oc) {
          return undefined;
        }
        return name in oc ? oc : oc.bindingContext;
      }

      while (oc && !(name in oc) && !(oc.bindingContext && name in oc.bindingContext)) {
        oc = oc.parentOverrideContext;
      }
      if (oc) {
        return name in oc ? oc : oc.bindingContext;
      }

      return scope.bindingContext || scope.overrideContext;
    }

    function createScopeForTest(bindingContext, parentBindingContext) {
      if (parentBindingContext) {
        return {
          bindingContext: bindingContext,
          overrideContext: createOverrideContext(bindingContext, createOverrideContext(parentBindingContext))
        };
      }
      return {
        bindingContext: bindingContext,
        overrideContext: createOverrideContext(bindingContext)
      };
    }

    var sourceContext = exports.sourceContext = 'Binding:source';
    var slotNames = [];
    var versionSlotNames = [];

    for (var i = 0; i < 100; i++) {
      slotNames.push('_observer' + i);
      versionSlotNames.push('_observerVersion' + i);
    }

    function addObserver(observer) {
      var observerSlots = this._observerSlots === undefined ? 0 : this._observerSlots;
      var i = observerSlots;
      while (i-- && this[slotNames[i]] !== observer) {}

      if (i === -1) {
        i = 0;
        while (this[slotNames[i]]) {
          i++;
        }
        this[slotNames[i]] = observer;
        observer.subscribe(sourceContext, this);

        if (i === observerSlots) {
          this._observerSlots = i + 1;
        }
      }

      if (this._version === undefined) {
        this._version = 0;
      }
      this[versionSlotNames[i]] = this._version;
    }

    function observeProperty(obj, propertyName) {
      var observer = this.observerLocator.getObserver(obj, propertyName);
      addObserver.call(this, observer);
    }

    function observeArray(array) {
      var observer = this.observerLocator.getArrayObserver(array);
      addObserver.call(this, observer);
    }

    function unobserve(all) {
      var i = this._observerSlots;
      while (i--) {
        if (all || this[versionSlotNames[i]] !== this._version) {
          var observer = this[slotNames[i]];
          this[slotNames[i]] = null;
          if (observer) {
            observer.unsubscribe(sourceContext, this);
          }
        }
      }
    }

    function connectable() {
      return function (target) {
        target.prototype.observeProperty = observeProperty;
        target.prototype.observeArray = observeArray;
        target.prototype.unobserve = unobserve;
        target.prototype.addObserver = addObserver;
      };
    }

    var queue = [];
    var queued = {};
    var nextId = 0;
    var minimumImmediate = 100;
    var frameBudget = 15;

    var isFlushRequested = false;
    var immediate = 0;

    function flush(animationFrameStart) {
      var length = queue.length;
      var i = 0;
      while (i < length) {
        var binding = queue[i];
        queued[binding.__connectQueueId] = false;
        binding.connect(true);
        i++;

        if (i % 100 === 0 && _aureliaPal.PLATFORM.performance.now() - animationFrameStart > frameBudget) {
          break;
        }
      }
      queue.splice(0, i);

      if (queue.length) {
        _aureliaPal.PLATFORM.requestAnimationFrame(flush);
      } else {
        isFlushRequested = false;
        immediate = 0;
      }
    }

    function enqueueBindingConnect(binding) {
      if (immediate < minimumImmediate) {
        immediate++;
        binding.connect(false);
      } else {
        var id = binding.__connectQueueId;
        if (id === undefined) {
          id = nextId;
          nextId++;
          binding.__connectQueueId = id;
        }

        if (!queued[id]) {
          queue.push(binding);
          queued[id] = true;
        }
      }
      if (!isFlushRequested) {
        isFlushRequested = true;
        _aureliaPal.PLATFORM.requestAnimationFrame(flush);
      }
    }

    function addSubscriber(context, callable) {
      if (this.hasSubscriber(context, callable)) {
        return false;
      }
      if (!this._context0) {
        this._context0 = context;
        this._callable0 = callable;
        return true;
      }
      if (!this._context1) {
        this._context1 = context;
        this._callable1 = callable;
        return true;
      }
      if (!this._context2) {
        this._context2 = context;
        this._callable2 = callable;
        return true;
      }
      if (!this._contextsRest) {
        this._contextsRest = [context];
        this._callablesRest = [callable];
        return true;
      }
      this._contextsRest.push(context);
      this._callablesRest.push(callable);
      return true;
    }

    function removeSubscriber(context, callable) {
      if (this._context0 === context && this._callable0 === callable) {
        this._context0 = null;
        this._callable0 = null;
        return true;
      }
      if (this._context1 === context && this._callable1 === callable) {
        this._context1 = null;
        this._callable1 = null;
        return true;
      }
      if (this._context2 === context && this._callable2 === callable) {
        this._context2 = null;
        this._callable2 = null;
        return true;
      }
      var rest = this._contextsRest;
      var index = void 0;
      if (!rest || !rest.length || (index = rest.indexOf(context)) === -1 || this._callablesRest[index] !== callable) {
        return false;
      }
      rest.splice(index, 1);
      this._callablesRest.splice(index, 1);
      return true;
    }

    var arrayPool1 = [];
    var arrayPool2 = [];
    var poolUtilization = [];

    function callSubscribers(newValue, oldValue) {
      var context0 = this._context0;
      var callable0 = this._callable0;
      var context1 = this._context1;
      var callable1 = this._callable1;
      var context2 = this._context2;
      var callable2 = this._callable2;
      var length = this._contextsRest ? this._contextsRest.length : 0;
      var contextsRest = void 0;
      var callablesRest = void 0;
      var poolIndex = void 0;
      var i = void 0;
      if (length) {
        poolIndex = poolUtilization.length;
        while (poolIndex-- && poolUtilization[poolIndex]) {}
        if (poolIndex < 0) {
          poolIndex = poolUtilization.length;
          contextsRest = [];
          callablesRest = [];
          poolUtilization.push(true);
          arrayPool1.push(contextsRest);
          arrayPool2.push(callablesRest);
        } else {
          poolUtilization[poolIndex] = true;
          contextsRest = arrayPool1[poolIndex];
          callablesRest = arrayPool2[poolIndex];
        }

        i = length;
        while (i--) {
          contextsRest[i] = this._contextsRest[i];
          callablesRest[i] = this._callablesRest[i];
        }
      }

      if (context0) {
        if (callable0) {
          callable0.call(context0, newValue, oldValue);
        } else {
          context0(newValue, oldValue);
        }
      }
      if (context1) {
        if (callable1) {
          callable1.call(context1, newValue, oldValue);
        } else {
          context1(newValue, oldValue);
        }
      }
      if (context2) {
        if (callable2) {
          callable2.call(context2, newValue, oldValue);
        } else {
          context2(newValue, oldValue);
        }
      }
      if (length) {
        for (i = 0; i < length; i++) {
          var callable = callablesRest[i];
          var context = contextsRest[i];
          if (callable) {
            callable.call(context, newValue, oldValue);
          } else {
            context(newValue, oldValue);
          }
          contextsRest[i] = null;
          callablesRest[i] = null;
        }
        poolUtilization[poolIndex] = false;
      }
    }

    function hasSubscribers() {
      return !!(this._context0 || this._context1 || this._context2 || this._contextsRest && this._contextsRest.length);
    }

    function hasSubscriber(context, callable) {
      var has = this._context0 === context && this._callable0 === callable || this._context1 === context && this._callable1 === callable || this._context2 === context && this._callable2 === callable;
      if (has) {
        return true;
      }
      var index = void 0;
      var contexts = this._contextsRest;
      if (!contexts || (index = contexts.length) === 0) {
        return false;
      }
      var callables = this._callablesRest;
      while (index--) {
        if (contexts[index] === context && callables[index] === callable) {
          return true;
        }
      }
      return false;
    }

    function subscriberCollection() {
      return function (target) {
        target.prototype.addSubscriber = addSubscriber;
        target.prototype.removeSubscriber = removeSubscriber;
        target.prototype.callSubscribers = callSubscribers;
        target.prototype.hasSubscribers = hasSubscribers;
        target.prototype.hasSubscriber = hasSubscriber;
      };
    }

    var ExpressionObserver = exports.ExpressionObserver = (_dec = connectable(), _dec2 = subscriberCollection(), _dec(_class = _dec2(_class = function () {
      function ExpressionObserver(scope, expression, observerLocator, lookupFunctions) {

        this.scope = scope;
        this.expression = expression;
        this.observerLocator = observerLocator;
        this.lookupFunctions = lookupFunctions;
      }

      ExpressionObserver.prototype.getValue = function getValue() {
        return this.expression.evaluate(this.scope, this.lookupFunctions);
      };

      ExpressionObserver.prototype.setValue = function setValue(newValue) {
        this.expression.assign(this.scope, newValue);
      };

      ExpressionObserver.prototype.subscribe = function subscribe(context, callable) {
        var _this = this;

        if (!this.hasSubscribers()) {
          this.oldValue = this.expression.evaluate(this.scope, this.lookupFunctions);
          this.expression.connect(this, this.scope);
        }
        this.addSubscriber(context, callable);
        if (arguments.length === 1 && context instanceof Function) {
          return {
            dispose: function dispose() {
              _this.unsubscribe(context, callable);
            }
          };
        }
      };

      ExpressionObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
        if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
          this.unobserve(true);
          this.oldValue = undefined;
        }
      };

      ExpressionObserver.prototype.call = function call() {
        var newValue = this.expression.evaluate(this.scope, this.lookupFunctions);
        var oldValue = this.oldValue;
        if (newValue !== oldValue) {
          this.oldValue = newValue;
          this.callSubscribers(newValue, oldValue);
        }
        this._version++;
        this.expression.connect(this, this.scope);
        this.unobserve(false);
      };

      return ExpressionObserver;
    }()) || _class) || _class);

    function isIndex(s) {
      return +s === s >>> 0;
    }

    function toNumber(s) {
      return +s;
    }

    function newSplice(index, removed, addedCount) {
      return {
        index: index,
        removed: removed,
        addedCount: addedCount
      };
    }

    var EDIT_LEAVE = 0;
    var EDIT_UPDATE = 1;
    var EDIT_ADD = 2;
    var EDIT_DELETE = 3;

    function ArraySplice() {}

    ArraySplice.prototype = {
      calcEditDistances: function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
        var rowCount = oldEnd - oldStart + 1;
        var columnCount = currentEnd - currentStart + 1;
        var distances = new Array(rowCount);
        var north = void 0;
        var west = void 0;

        for (var _i = 0; _i < rowCount; ++_i) {
          distances[_i] = new Array(columnCount);
          distances[_i][0] = _i;
        }

        for (var j = 0; j < columnCount; ++j) {
          distances[0][j] = j;
        }

        for (var _i2 = 1; _i2 < rowCount; ++_i2) {
          for (var _j = 1; _j < columnCount; ++_j) {
            if (this.equals(current[currentStart + _j - 1], old[oldStart + _i2 - 1])) {
              distances[_i2][_j] = distances[_i2 - 1][_j - 1];
            } else {
              north = distances[_i2 - 1][_j] + 1;
              west = distances[_i2][_j - 1] + 1;
              distances[_i2][_j] = north < west ? north : west;
            }
          }
        }

        return distances;
      },

      spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
        var i = distances.length - 1;
        var j = distances[0].length - 1;
        var current = distances[i][j];
        var edits = [];
        while (i > 0 || j > 0) {
          if (i === 0) {
            edits.push(EDIT_ADD);
            j--;
            continue;
          }
          if (j === 0) {
            edits.push(EDIT_DELETE);
            i--;
            continue;
          }
          var northWest = distances[i - 1][j - 1];
          var west = distances[i - 1][j];
          var north = distances[i][j - 1];

          var min = void 0;
          if (west < north) {
            min = west < northWest ? west : northWest;
          } else {
            min = north < northWest ? north : northWest;
          }

          if (min === northWest) {
            if (northWest === current) {
              edits.push(EDIT_LEAVE);
            } else {
              edits.push(EDIT_UPDATE);
              current = northWest;
            }
            i--;
            j--;
          } else if (min === west) {
            edits.push(EDIT_DELETE);
            i--;
            current = west;
          } else {
            edits.push(EDIT_ADD);
            j--;
            current = north;
          }
        }

        edits.reverse();
        return edits;
      },

      calcSplices: function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
        var prefixCount = 0;
        var suffixCount = 0;

        var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
        if (currentStart === 0 && oldStart === 0) {
          prefixCount = this.sharedPrefix(current, old, minLength);
        }

        if (currentEnd === current.length && oldEnd === old.length) {
          suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
        }

        currentStart += prefixCount;
        oldStart += prefixCount;
        currentEnd -= suffixCount;
        oldEnd -= suffixCount;

        if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {
          return [];
        }

        if (currentStart === currentEnd) {
          var _splice = newSplice(currentStart, [], 0);
          while (oldStart < oldEnd) {
            _splice.removed.push(old[oldStart++]);
          }

          return [_splice];
        } else if (oldStart === oldEnd) {
          return [newSplice(currentStart, [], currentEnd - currentStart)];
        }

        var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

        var splice = undefined;
        var splices = [];
        var index = currentStart;
        var oldIndex = oldStart;
        for (var _i3 = 0; _i3 < ops.length; ++_i3) {
          switch (ops[_i3]) {
            case EDIT_LEAVE:
              if (splice) {
                splices.push(splice);
                splice = undefined;
              }

              index++;
              oldIndex++;
              break;
            case EDIT_UPDATE:
              if (!splice) {
                splice = newSplice(index, [], 0);
              }

              splice.addedCount++;
              index++;

              splice.removed.push(old[oldIndex]);
              oldIndex++;
              break;
            case EDIT_ADD:
              if (!splice) {
                splice = newSplice(index, [], 0);
              }

              splice.addedCount++;
              index++;
              break;
            case EDIT_DELETE:
              if (!splice) {
                splice = newSplice(index, [], 0);
              }

              splice.removed.push(old[oldIndex]);
              oldIndex++;
              break;
          }
        }

        if (splice) {
          splices.push(splice);
        }
        return splices;
      },

      sharedPrefix: function sharedPrefix(current, old, searchLength) {
        for (var _i4 = 0; _i4 < searchLength; ++_i4) {
          if (!this.equals(current[_i4], old[_i4])) {
            return _i4;
          }
        }

        return searchLength;
      },

      sharedSuffix: function sharedSuffix(current, old, searchLength) {
        var index1 = current.length;
        var index2 = old.length;
        var count = 0;
        while (count < searchLength && this.equals(current[--index1], old[--index2])) {
          count++;
        }

        return count;
      },

      calculateSplices: function calculateSplices(current, previous) {
        return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
      },

      equals: function equals(currentValue, previousValue) {
        return currentValue === previousValue;
      }
    };

    var arraySplice = new ArraySplice();

    function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      return arraySplice.calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd);
    }

    function intersect(start1, end1, start2, end2) {
      if (end1 < start2 || end2 < start1) {
        return -1;
      }

      if (end1 === start2 || end2 === start1) {
        return 0;
      }

      if (start1 < start2) {
        if (end1 < end2) {
          return end1 - start2;
        }

        return end2 - start2;
      }

      if (end2 < end1) {
        return end2 - start1;
      }

      return end1 - start1;
    }

    function mergeSplice(splices, index, removed, addedCount) {
      var splice = newSplice(index, removed, addedCount);

      var inserted = false;
      var insertionOffset = 0;

      for (var _i5 = 0; _i5 < splices.length; _i5++) {
        var current = splices[_i5];
        current.index += insertionOffset;

        if (inserted) {
          continue;
        }

        var intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);

        if (intersectCount >= 0) {

          splices.splice(_i5, 1);
          _i5--;

          insertionOffset -= current.addedCount - current.removed.length;

          splice.addedCount += current.addedCount - intersectCount;
          var deleteCount = splice.removed.length + current.removed.length - intersectCount;

          if (!splice.addedCount && !deleteCount) {
            inserted = true;
          } else {
            var currentRemoved = current.removed;

            if (splice.index < current.index) {
              var prepend = splice.removed.slice(0, current.index - splice.index);
              Array.prototype.push.apply(prepend, currentRemoved);
              currentRemoved = prepend;
            }

            if (splice.index + splice.removed.length > current.index + current.addedCount) {
              var append = splice.removed.slice(current.index + current.addedCount - splice.index);
              Array.prototype.push.apply(currentRemoved, append);
            }

            splice.removed = currentRemoved;
            if (current.index < splice.index) {
              splice.index = current.index;
            }
          }
        } else if (splice.index < current.index) {

          inserted = true;

          splices.splice(_i5, 0, splice);
          _i5++;

          var offset = splice.addedCount - splice.removed.length;
          current.index += offset;
          insertionOffset += offset;
        }
      }

      if (!inserted) {
        splices.push(splice);
      }
    }

    function createInitialSplices(array, changeRecords) {
      var splices = [];

      for (var _i6 = 0; _i6 < changeRecords.length; _i6++) {
        var record = changeRecords[_i6];
        switch (record.type) {
          case 'splice':
            mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
            break;
          case 'add':
          case 'update':
          case 'delete':
            if (!isIndex(record.name)) {
              continue;
            }

            var index = toNumber(record.name);
            if (index < 0) {
              continue;
            }

            mergeSplice(splices, index, [record.oldValue], record.type === 'delete' ? 0 : 1);
            break;
          default:
            console.error('Unexpected record type: ' + JSON.stringify(record));
            break;
        }
      }

      return splices;
    }

    function projectArraySplices(array, changeRecords) {
      var splices = [];

      createInitialSplices(array, changeRecords).forEach(function (splice) {
        if (splice.addedCount === 1 && splice.removed.length === 1) {
          if (splice.removed[0] !== array[splice.index]) {
            splices.push(splice);
          }

          return;
        }

        splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
      });

      return splices;
    }

    function newRecord(type, object, key, oldValue) {
      return {
        type: type,
        object: object,
        key: key,
        oldValue: oldValue
      };
    }

    function getChangeRecords(map) {
      var entries = new Array(map.size);
      var keys = map.keys();
      var i = 0;
      var item = void 0;

      while (item = keys.next()) {
        if (item.done) {
          break;
        }

        entries[i] = newRecord('added', map, item.value);
        i++;
      }

      return entries;
    }

    var ModifyCollectionObserver = exports.ModifyCollectionObserver = (_dec3 = subscriberCollection(), _dec3(_class2 = function () {
      function ModifyCollectionObserver(taskQueue, collection) {

        this.taskQueue = taskQueue;
        this.queued = false;
        this.changeRecords = null;
        this.oldCollection = null;
        this.collection = collection;
        this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
      }

      ModifyCollectionObserver.prototype.subscribe = function subscribe(context, callable) {
        this.addSubscriber(context, callable);
      };

      ModifyCollectionObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
        this.removeSubscriber(context, callable);
      };

      ModifyCollectionObserver.prototype.addChangeRecord = function addChangeRecord(changeRecord) {
        if (!this.hasSubscribers() && !this.lengthObserver) {
          return;
        }

        if (changeRecord.type === 'splice') {
          var index = changeRecord.index;
          var arrayLength = changeRecord.object.length;
          if (index > arrayLength) {
            index = arrayLength - changeRecord.addedCount;
          } else if (index < 0) {
            index = arrayLength + changeRecord.removed.length + index - changeRecord.addedCount;
          }
          if (index < 0) {
            index = 0;
          }
          changeRecord.index = index;
        }

        if (this.changeRecords === null) {
          this.changeRecords = [changeRecord];
        } else {
          this.changeRecords.push(changeRecord);
        }

        if (!this.queued) {
          this.queued = true;
          this.taskQueue.queueMicroTask(this);
        }
      };

      ModifyCollectionObserver.prototype.flushChangeRecords = function flushChangeRecords() {
        if (this.changeRecords && this.changeRecords.length || this.oldCollection) {
          this.call();
        }
      };

      ModifyCollectionObserver.prototype.reset = function reset(oldCollection) {
        this.oldCollection = oldCollection;

        if (this.hasSubscribers() && !this.queued) {
          this.queued = true;
          this.taskQueue.queueMicroTask(this);
        }
      };

      ModifyCollectionObserver.prototype.getLengthObserver = function getLengthObserver() {
        return this.lengthObserver || (this.lengthObserver = new CollectionLengthObserver(this.collection));
      };

      ModifyCollectionObserver.prototype.call = function call() {
        var changeRecords = this.changeRecords;
        var oldCollection = this.oldCollection;
        var records = void 0;

        this.queued = false;
        this.changeRecords = [];
        this.oldCollection = null;

        if (this.hasSubscribers()) {
          if (oldCollection) {
            if (this.collection instanceof Map || this.collection instanceof Set) {
              records = getChangeRecords(oldCollection);
            } else {
              records = calcSplices(this.collection, 0, this.collection.length, oldCollection, 0, oldCollection.length);
            }
          } else {
            if (this.collection instanceof Map || this.collection instanceof Set) {
              records = changeRecords;
            } else {
              records = projectArraySplices(this.collection, changeRecords);
            }
          }

          this.callSubscribers(records);
        }

        if (this.lengthObserver) {
          this.lengthObserver.call(this.collection[this.lengthPropertyName]);
        }
      };

      return ModifyCollectionObserver;
    }()) || _class2);
    var CollectionLengthObserver = exports.CollectionLengthObserver = (_dec4 = subscriberCollection(), _dec4(_class3 = function () {
      function CollectionLengthObserver(collection) {

        this.collection = collection;
        this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
        this.currentValue = collection[this.lengthPropertyName];
      }

      CollectionLengthObserver.prototype.getValue = function getValue() {
        return this.collection[this.lengthPropertyName];
      };

      CollectionLengthObserver.prototype.setValue = function setValue(newValue) {
        this.collection[this.lengthPropertyName] = newValue;
      };

      CollectionLengthObserver.prototype.subscribe = function subscribe(context, callable) {
        this.addSubscriber(context, callable);
      };

      CollectionLengthObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
        this.removeSubscriber(context, callable);
      };

      CollectionLengthObserver.prototype.call = function call(newValue) {
        var oldValue = this.currentValue;
        this.callSubscribers(newValue, oldValue);
        this.currentValue = newValue;
      };

      return CollectionLengthObserver;
    }()) || _class3);

    var pop = Array.prototype.pop;
    var push = Array.prototype.push;
    var reverse = Array.prototype.reverse;
    var shift = Array.prototype.shift;
    var sort = Array.prototype.sort;
    var splice = Array.prototype.splice;
    var unshift = Array.prototype.unshift;

    Array.prototype.pop = function () {
      var notEmpty = this.length > 0;
      var methodCallResult = pop.apply(this, arguments);
      if (notEmpty && this.__array_observer__ !== undefined) {
        this.__array_observer__.addChangeRecord({
          type: 'delete',
          object: this,
          name: this.length,
          oldValue: methodCallResult
        });
      }
      return methodCallResult;
    };

    Array.prototype.push = function () {
      var methodCallResult = push.apply(this, arguments);
      if (this.__array_observer__ !== undefined) {
        this.__array_observer__.addChangeRecord({
          type: 'splice',
          object: this,
          index: this.length - arguments.length,
          removed: [],
          addedCount: arguments.length
        });
      }
      return methodCallResult;
    };

    Array.prototype.reverse = function () {
      var oldArray = void 0;
      if (this.__array_observer__ !== undefined) {
        this.__array_observer__.flushChangeRecords();
        oldArray = this.slice();
      }
      var methodCallResult = reverse.apply(this, arguments);
      if (this.__array_observer__ !== undefined) {
        this.__array_observer__.reset(oldArray);
      }
      return methodCallResult;
    };

    Array.prototype.shift = function () {
      var notEmpty = this.length > 0;
      var methodCallResult = shift.apply(this, arguments);
      if (notEmpty && this.__array_observer__ !== undefined) {
        this.__array_observer__.addChangeRecord({
          type: 'delete',
          object: this,
          name: 0,
          oldValue: methodCallResult
        });
      }
      return methodCallResult;
    };

    Array.prototype.sort = function () {
      var oldArray = void 0;
      if (this.__array_observer__ !== undefined) {
        this.__array_observer__.flushChangeRecords();
        oldArray = this.slice();
      }
      var methodCallResult = sort.apply(this, arguments);
      if (this.__array_observer__ !== undefined) {
        this.__array_observer__.reset(oldArray);
      }
      return methodCallResult;
    };

    Array.prototype.splice = function () {
      var methodCallResult = splice.apply(this, arguments);
      if (this.__array_observer__ !== undefined) {
        this.__array_observer__.addChangeRecord({
          type: 'splice',
          object: this,
          index: +arguments[0],
          removed: methodCallResult,
          addedCount: arguments.length > 2 ? arguments.length - 2 : 0
        });
      }
      return methodCallResult;
    };

    Array.prototype.unshift = function () {
      var methodCallResult = unshift.apply(this, arguments);
      if (this.__array_observer__ !== undefined) {
        this.__array_observer__.addChangeRecord({
          type: 'splice',
          object: this,
          index: 0,
          removed: [],
          addedCount: arguments.length
        });
      }
      return methodCallResult;
    };

    function _getArrayObserver(taskQueue, array) {
      return ModifyArrayObserver.for(taskQueue, array);
    }

    exports.getArrayObserver = _getArrayObserver;

    var ModifyArrayObserver = function (_ModifyCollectionObse) {
      _inherits(ModifyArrayObserver, _ModifyCollectionObse);

      function ModifyArrayObserver(taskQueue, array) {

        return _possibleConstructorReturn(this, _ModifyCollectionObse.call(this, taskQueue, array));
      }

      ModifyArrayObserver.for = function _for(taskQueue, array) {
        if (!('__array_observer__' in array)) {
          Reflect.defineProperty(array, '__array_observer__', {
            value: ModifyArrayObserver.create(taskQueue, array),
            enumerable: false, configurable: false
          });
        }
        return array.__array_observer__;
      };

      ModifyArrayObserver.create = function create(taskQueue, array) {
        return new ModifyArrayObserver(taskQueue, array);
      };

      return ModifyArrayObserver;
    }(ModifyCollectionObserver);

    var Expression = exports.Expression = function () {
      function Expression() {

        this.isChain = false;
        this.isAssignable = false;
      }

      Expression.prototype.evaluate = function evaluate(scope, lookupFunctions, args) {
        throw new Error('Binding expression "' + this + '" cannot be evaluated.');
      };

      Expression.prototype.assign = function assign(scope, value, lookupFunctions) {
        throw new Error('Binding expression "' + this + '" cannot be assigned to.');
      };

      Expression.prototype.toString = function toString() {
        return typeof FEATURE_NO_UNPARSER === 'undefined' ? _Unparser.unparse(this) : Function.prototype.toString.call(this);
      };

      return Expression;
    }();

    var Chain = exports.Chain = function (_Expression) {
      _inherits(Chain, _Expression);

      function Chain(expressions) {

        var _this3 = _possibleConstructorReturn(this, _Expression.call(this));

        _this3.expressions = expressions;
        _this3.isChain = true;
        return _this3;
      }

      Chain.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        var result = void 0;
        var expressions = this.expressions;
        var last = void 0;

        for (var _i7 = 0, length = expressions.length; _i7 < length; ++_i7) {
          last = expressions[_i7].evaluate(scope, lookupFunctions);

          if (last !== null) {
            result = last;
          }
        }

        return result;
      };

      Chain.prototype.accept = function accept(visitor) {
        return visitor.visitChain(this);
      };

      return Chain;
    }(Expression);

    var BindingBehavior = exports.BindingBehavior = function (_Expression2) {
      _inherits(BindingBehavior, _Expression2);

      function BindingBehavior(expression, name, args) {

        var _this4 = _possibleConstructorReturn(this, _Expression2.call(this));

        _this4.expression = expression;
        _this4.name = name;
        _this4.args = args;
        return _this4;
      }

      BindingBehavior.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        return this.expression.evaluate(scope, lookupFunctions);
      };

      BindingBehavior.prototype.assign = function assign(scope, value, lookupFunctions) {
        return this.expression.assign(scope, value, lookupFunctions);
      };

      BindingBehavior.prototype.accept = function accept(visitor) {
        return visitor.visitBindingBehavior(this);
      };

      BindingBehavior.prototype.connect = function connect(binding, scope) {
        this.expression.connect(binding, scope);
      };

      BindingBehavior.prototype.bind = function bind(binding, scope, lookupFunctions) {
        if (this.expression.expression && this.expression.bind) {
          this.expression.bind(binding, scope, lookupFunctions);
        }
        var behavior = lookupFunctions.bindingBehaviors(this.name);
        if (!behavior) {
          throw new Error('No BindingBehavior named "' + this.name + '" was found!');
        }
        var behaviorKey = 'behavior-' + this.name;
        if (binding[behaviorKey]) {
          throw new Error('A binding behavior named "' + this.name + '" has already been applied to "' + this.expression + '"');
        }
        binding[behaviorKey] = behavior;
        behavior.bind.apply(behavior, [binding, scope].concat(evalList(scope, this.args, binding.lookupFunctions)));
      };

      BindingBehavior.prototype.unbind = function unbind(binding, scope) {
        var behaviorKey = 'behavior-' + this.name;
        binding[behaviorKey].unbind(binding, scope);
        binding[behaviorKey] = null;
        if (this.expression.expression && this.expression.unbind) {
          this.expression.unbind(binding, scope);
        }
      };

      return BindingBehavior;
    }(Expression);

    var ValueConverter = exports.ValueConverter = function (_Expression3) {
      _inherits(ValueConverter, _Expression3);

      function ValueConverter(expression, name, args, allArgs) {

        var _this5 = _possibleConstructorReturn(this, _Expression3.call(this));

        _this5.expression = expression;
        _this5.name = name;
        _this5.args = args;
        _this5.allArgs = allArgs;
        return _this5;
      }

      ValueConverter.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        var converter = lookupFunctions.valueConverters(this.name);
        if (!converter) {
          throw new Error('No ValueConverter named "' + this.name + '" was found!');
        }

        if ('toView' in converter) {
          return converter.toView.apply(converter, evalList(scope, this.allArgs, lookupFunctions));
        }

        return this.allArgs[0].evaluate(scope, lookupFunctions);
      };

      ValueConverter.prototype.assign = function assign(scope, value, lookupFunctions) {
        var converter = lookupFunctions.valueConverters(this.name);
        if (!converter) {
          throw new Error('No ValueConverter named "' + this.name + '" was found!');
        }

        if ('fromView' in converter) {
          value = converter.fromView.apply(converter, [value].concat(evalList(scope, this.args, lookupFunctions)));
        }

        return this.allArgs[0].assign(scope, value, lookupFunctions);
      };

      ValueConverter.prototype.accept = function accept(visitor) {
        return visitor.visitValueConverter(this);
      };

      ValueConverter.prototype.connect = function connect(binding, scope) {
        var expressions = this.allArgs;
        var i = expressions.length;
        while (i--) {
          expressions[i].connect(binding, scope);
        }
      };

      return ValueConverter;
    }(Expression);

    var Assign = exports.Assign = function (_Expression4) {
      _inherits(Assign, _Expression4);

      function Assign(target, value) {

        var _this6 = _possibleConstructorReturn(this, _Expression4.call(this));

        _this6.target = target;
        _this6.value = value;
        _this6.isAssignable = true;
        return _this6;
      }

      Assign.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        return this.target.assign(scope, this.value.evaluate(scope, lookupFunctions));
      };

      Assign.prototype.accept = function accept(vistor) {
        vistor.visitAssign(this);
      };

      Assign.prototype.connect = function connect(binding, scope) {};

      Assign.prototype.assign = function assign(scope, value) {
        this.value.assign(scope, value);
        this.target.assign(scope, value);
      };

      return Assign;
    }(Expression);

    var Conditional = exports.Conditional = function (_Expression5) {
      _inherits(Conditional, _Expression5);

      function Conditional(condition, yes, no) {

        var _this7 = _possibleConstructorReturn(this, _Expression5.call(this));

        _this7.condition = condition;
        _this7.yes = yes;
        _this7.no = no;
        return _this7;
      }

      Conditional.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        return !!this.condition.evaluate(scope, lookupFunctions) ? this.yes.evaluate(scope, lookupFunctions) : this.no.evaluate(scope, lookupFunctions);
      };

      Conditional.prototype.accept = function accept(visitor) {
        return visitor.visitConditional(this);
      };

      Conditional.prototype.connect = function connect(binding, scope) {
        this.condition.connect(binding, scope);
        if (this.condition.evaluate(scope)) {
          this.yes.connect(binding, scope);
        } else {
          this.no.connect(binding, scope);
        }
      };

      return Conditional;
    }(Expression);

    var AccessThis = exports.AccessThis = function (_Expression6) {
      _inherits(AccessThis, _Expression6);

      function AccessThis(ancestor) {

        var _this8 = _possibleConstructorReturn(this, _Expression6.call(this));

        _this8.ancestor = ancestor;
        return _this8;
      }

      AccessThis.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        var oc = scope.overrideContext;
        var i = this.ancestor;
        while (i-- && oc) {
          oc = oc.parentOverrideContext;
        }
        return i < 1 && oc ? oc.bindingContext : undefined;
      };

      AccessThis.prototype.accept = function accept(visitor) {
        return visitor.visitAccessThis(this);
      };

      AccessThis.prototype.connect = function connect(binding, scope) {};

      return AccessThis;
    }(Expression);

    var AccessScope = exports.AccessScope = function (_Expression7) {
      _inherits(AccessScope, _Expression7);

      function AccessScope(name, ancestor) {

        var _this9 = _possibleConstructorReturn(this, _Expression7.call(this));

        _this9.name = name;
        _this9.ancestor = ancestor;
        _this9.isAssignable = true;
        return _this9;
      }

      AccessScope.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        var context = getContextFor(this.name, scope, this.ancestor);
        return context[this.name];
      };

      AccessScope.prototype.assign = function assign(scope, value) {
        var context = getContextFor(this.name, scope, this.ancestor);
        return context ? context[this.name] = value : undefined;
      };

      AccessScope.prototype.accept = function accept(visitor) {
        return visitor.visitAccessScope(this);
      };

      AccessScope.prototype.connect = function connect(binding, scope) {
        var context = getContextFor(this.name, scope, this.ancestor);
        binding.observeProperty(context, this.name);
      };

      return AccessScope;
    }(Expression);

    var AccessMember = exports.AccessMember = function (_Expression8) {
      _inherits(AccessMember, _Expression8);

      function AccessMember(object, name) {

        var _this10 = _possibleConstructorReturn(this, _Expression8.call(this));

        _this10.object = object;
        _this10.name = name;
        _this10.isAssignable = true;
        return _this10;
      }

      AccessMember.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        var instance = this.object.evaluate(scope, lookupFunctions);
        return instance === null || instance === undefined ? instance : instance[this.name];
      };

      AccessMember.prototype.assign = function assign(scope, value) {
        var instance = this.object.evaluate(scope);

        if (instance === null || instance === undefined) {
          instance = {};
          this.object.assign(scope, instance);
        }

        instance[this.name] = value;
        return value;
      };

      AccessMember.prototype.accept = function accept(visitor) {
        return visitor.visitAccessMember(this);
      };

      AccessMember.prototype.connect = function connect(binding, scope) {
        this.object.connect(binding, scope);
        var obj = this.object.evaluate(scope);
        if (obj) {
          binding.observeProperty(obj, this.name);
        }
      };

      return AccessMember;
    }(Expression);

    var AccessKeyed = exports.AccessKeyed = function (_Expression9) {
      _inherits(AccessKeyed, _Expression9);

      function AccessKeyed(object, key) {

        var _this11 = _possibleConstructorReturn(this, _Expression9.call(this));

        _this11.object = object;
        _this11.key = key;
        _this11.isAssignable = true;
        return _this11;
      }

      AccessKeyed.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        var instance = this.object.evaluate(scope, lookupFunctions);
        var lookup = this.key.evaluate(scope, lookupFunctions);
        return getKeyed(instance, lookup);
      };

      AccessKeyed.prototype.assign = function assign(scope, value) {
        var instance = this.object.evaluate(scope);
        var lookup = this.key.evaluate(scope);
        return setKeyed(instance, lookup, value);
      };

      AccessKeyed.prototype.accept = function accept(visitor) {
        return visitor.visitAccessKeyed(this);
      };

      AccessKeyed.prototype.connect = function connect(binding, scope) {
        this.object.connect(binding, scope);
        var obj = this.object.evaluate(scope);
        if (obj instanceof Object) {
          this.key.connect(binding, scope);
          var key = this.key.evaluate(scope);

          if (key !== null && key !== undefined && !(Array.isArray(obj) && typeof key === 'number')) {
            binding.observeProperty(obj, key);
          }
        }
      };

      return AccessKeyed;
    }(Expression);

    var CallScope = exports.CallScope = function (_Expression10) {
      _inherits(CallScope, _Expression10);

      function CallScope(name, args, ancestor) {

        var _this12 = _possibleConstructorReturn(this, _Expression10.call(this));

        _this12.name = name;
        _this12.args = args;
        _this12.ancestor = ancestor;
        return _this12;
      }

      CallScope.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
        var args = evalList(scope, this.args, lookupFunctions);
        var context = getContextFor(this.name, scope, this.ancestor);
        var func = getFunction(context, this.name, mustEvaluate);
        if (func) {
          return func.apply(context, args);
        }
        return undefined;
      };

      CallScope.prototype.accept = function accept(visitor) {
        return visitor.visitCallScope(this);
      };

      CallScope.prototype.connect = function connect(binding, scope) {
        var args = this.args;
        var i = args.length;
        while (i--) {
          args[i].connect(binding, scope);
        }
      };

      return CallScope;
    }(Expression);

    var CallMember = exports.CallMember = function (_Expression11) {
      _inherits(CallMember, _Expression11);

      function CallMember(object, name, args) {

        var _this13 = _possibleConstructorReturn(this, _Expression11.call(this));

        _this13.object = object;
        _this13.name = name;
        _this13.args = args;
        return _this13;
      }

      CallMember.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
        var instance = this.object.evaluate(scope, lookupFunctions);
        var args = evalList(scope, this.args, lookupFunctions);
        var func = getFunction(instance, this.name, mustEvaluate);
        if (func) {
          return func.apply(instance, args);
        }
        return undefined;
      };

      CallMember.prototype.accept = function accept(visitor) {
        return visitor.visitCallMember(this);
      };

      CallMember.prototype.connect = function connect(binding, scope) {
        this.object.connect(binding, scope);
        var obj = this.object.evaluate(scope);
        if (getFunction(obj, this.name, false)) {
          var args = this.args;
          var _i8 = args.length;
          while (_i8--) {
            args[_i8].connect(binding, scope);
          }
        }
      };

      return CallMember;
    }(Expression);

    var CallFunction = exports.CallFunction = function (_Expression12) {
      _inherits(CallFunction, _Expression12);

      function CallFunction(func, args) {

        var _this14 = _possibleConstructorReturn(this, _Expression12.call(this));

        _this14.func = func;
        _this14.args = args;
        return _this14;
      }

      CallFunction.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
        var func = this.func.evaluate(scope, lookupFunctions);
        if (typeof func === 'function') {
          return func.apply(null, evalList(scope, this.args, lookupFunctions));
        }
        if (!mustEvaluate && (func === null || func === undefined)) {
          return undefined;
        }
        throw new Error(this.func + ' is not a function');
      };

      CallFunction.prototype.accept = function accept(visitor) {
        return visitor.visitCallFunction(this);
      };

      CallFunction.prototype.connect = function connect(binding, scope) {
        this.func.connect(binding, scope);
        var func = this.func.evaluate(scope);
        if (typeof func === 'function') {
          var args = this.args;
          var _i9 = args.length;
          while (_i9--) {
            args[_i9].connect(binding, scope);
          }
        }
      };

      return CallFunction;
    }(Expression);

    var Binary = exports.Binary = function (_Expression13) {
      _inherits(Binary, _Expression13);

      function Binary(operation, left, right) {

        var _this15 = _possibleConstructorReturn(this, _Expression13.call(this));

        _this15.operation = operation;
        _this15.left = left;
        _this15.right = right;
        return _this15;
      }

      Binary.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        var left = this.left.evaluate(scope, lookupFunctions);

        switch (this.operation) {
          case '&&':
            return left && this.right.evaluate(scope, lookupFunctions);
          case '||':
            return left || this.right.evaluate(scope, lookupFunctions);
        }

        var right = this.right.evaluate(scope, lookupFunctions);

        switch (this.operation) {
          case '==':
            return left == right;
          case '===':
            return left === right;
          case '!=':
            return left != right;
          case '!==':
            return left !== right;
        }

        if (left === null || right === null || left === undefined || right === undefined) {
          switch (this.operation) {
            case '+':
              if (left !== null && left !== undefined) return left;
              if (right !== null && right !== undefined) return right;
              return 0;
            case '-':
              if (left !== null && left !== undefined) return left;
              if (right !== null && right !== undefined) return 0 - right;
              return 0;
          }

          return null;
        }

        switch (this.operation) {
          case '+':
            return autoConvertAdd(left, right);
          case '-':
            return left - right;
          case '*':
            return left * right;
          case '/':
            return left / right;
          case '%':
            return left % right;
          case '<':
            return left < right;
          case '>':
            return left > right;
          case '<=':
            return left <= right;
          case '>=':
            return left >= right;
          case '^':
            return left ^ right;
        }

        throw new Error('Internal error [' + this.operation + '] not handled');
      };

      Binary.prototype.accept = function accept(visitor) {
        return visitor.visitBinary(this);
      };

      Binary.prototype.connect = function connect(binding, scope) {
        this.left.connect(binding, scope);
        var left = this.left.evaluate(scope);
        if (this.operation === '&&' && !left || this.operation === '||' && left) {
          return;
        }
        this.right.connect(binding, scope);
      };

      return Binary;
    }(Expression);

    var PrefixNot = exports.PrefixNot = function (_Expression14) {
      _inherits(PrefixNot, _Expression14);

      function PrefixNot(operation, expression) {

        var _this16 = _possibleConstructorReturn(this, _Expression14.call(this));

        _this16.operation = operation;
        _this16.expression = expression;
        return _this16;
      }

      PrefixNot.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        return !this.expression.evaluate(scope, lookupFunctions);
      };

      PrefixNot.prototype.accept = function accept(visitor) {
        return visitor.visitPrefix(this);
      };

      PrefixNot.prototype.connect = function connect(binding, scope) {
        this.expression.connect(binding, scope);
      };

      return PrefixNot;
    }(Expression);

    var LiteralPrimitive = exports.LiteralPrimitive = function (_Expression15) {
      _inherits(LiteralPrimitive, _Expression15);

      function LiteralPrimitive(value) {

        var _this17 = _possibleConstructorReturn(this, _Expression15.call(this));

        _this17.value = value;
        return _this17;
      }

      LiteralPrimitive.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        return this.value;
      };

      LiteralPrimitive.prototype.accept = function accept(visitor) {
        return visitor.visitLiteralPrimitive(this);
      };

      LiteralPrimitive.prototype.connect = function connect(binding, scope) {};

      return LiteralPrimitive;
    }(Expression);

    var LiteralString = exports.LiteralString = function (_Expression16) {
      _inherits(LiteralString, _Expression16);

      function LiteralString(value) {

        var _this18 = _possibleConstructorReturn(this, _Expression16.call(this));

        _this18.value = value;
        return _this18;
      }

      LiteralString.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        return this.value;
      };

      LiteralString.prototype.accept = function accept(visitor) {
        return visitor.visitLiteralString(this);
      };

      LiteralString.prototype.connect = function connect(binding, scope) {};

      return LiteralString;
    }(Expression);

    var LiteralArray = exports.LiteralArray = function (_Expression17) {
      _inherits(LiteralArray, _Expression17);

      function LiteralArray(elements) {

        var _this19 = _possibleConstructorReturn(this, _Expression17.call(this));

        _this19.elements = elements;
        return _this19;
      }

      LiteralArray.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        var elements = this.elements;
        var result = [];

        for (var _i10 = 0, length = elements.length; _i10 < length; ++_i10) {
          result[_i10] = elements[_i10].evaluate(scope, lookupFunctions);
        }

        return result;
      };

      LiteralArray.prototype.accept = function accept(visitor) {
        return visitor.visitLiteralArray(this);
      };

      LiteralArray.prototype.connect = function connect(binding, scope) {
        var length = this.elements.length;
        for (var _i11 = 0; _i11 < length; _i11++) {
          this.elements[_i11].connect(binding, scope);
        }
      };

      return LiteralArray;
    }(Expression);

    var LiteralObject = exports.LiteralObject = function (_Expression18) {
      _inherits(LiteralObject, _Expression18);

      function LiteralObject(keys, values) {

        var _this20 = _possibleConstructorReturn(this, _Expression18.call(this));

        _this20.keys = keys;
        _this20.values = values;
        return _this20;
      }

      LiteralObject.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        var instance = {};
        var keys = this.keys;
        var values = this.values;

        for (var _i12 = 0, length = keys.length; _i12 < length; ++_i12) {
          instance[keys[_i12]] = values[_i12].evaluate(scope, lookupFunctions);
        }

        return instance;
      };

      LiteralObject.prototype.accept = function accept(visitor) {
        return visitor.visitLiteralObject(this);
      };

      LiteralObject.prototype.connect = function connect(binding, scope) {
        var length = this.keys.length;
        for (var _i13 = 0; _i13 < length; _i13++) {
          this.values[_i13].connect(binding, scope);
        }
      };

      return LiteralObject;
    }(Expression);

    function evalList(scope, list, lookupFunctions) {
      var length = list.length;
      var result = [];
      for (var _i14 = 0; _i14 < length; _i14++) {
        result[_i14] = list[_i14].evaluate(scope, lookupFunctions);
      }
      return result;
    }

    function autoConvertAdd(a, b) {
      if (a !== null && b !== null) {
        if (typeof a === 'string' && typeof b !== 'string') {
          return a + b.toString();
        }

        if (typeof a !== 'string' && typeof b === 'string') {
          return a.toString() + b;
        }

        return a + b;
      }

      if (a !== null) {
        return a;
      }

      if (b !== null) {
        return b;
      }

      return 0;
    }

    function getFunction(obj, name, mustExist) {
      var func = obj === null || obj === undefined ? null : obj[name];
      if (typeof func === 'function') {
        return func;
      }
      if (!mustExist && (func === null || func === undefined)) {
        return null;
      }
      throw new Error(name + ' is not a function');
    }

    function getKeyed(obj, key) {
      if (Array.isArray(obj)) {
        return obj[parseInt(key, 10)];
      } else if (obj) {
        return obj[key];
      } else if (obj === null || obj === undefined) {
        return undefined;
      }

      return obj[key];
    }

    function setKeyed(obj, key, value) {
      if (Array.isArray(obj)) {
        var index = parseInt(key, 10);

        if (obj.length <= index) {
          obj.length = index + 1;
        }

        obj[index] = value;
      } else {
        obj[key] = value;
      }

      return value;
    }

    var _Unparser = null;

    exports.Unparser = _Unparser;
    if (typeof FEATURE_NO_UNPARSER === 'undefined') {
      exports.Unparser = _Unparser = function () {
        function Unparser(buffer) {

          this.buffer = buffer;
        }

        Unparser.unparse = function unparse(expression) {
          var buffer = [];
          var visitor = new _Unparser(buffer);

          expression.accept(visitor);

          return buffer.join('');
        };

        Unparser.prototype.write = function write(text) {
          this.buffer.push(text);
        };

        Unparser.prototype.writeArgs = function writeArgs(args) {
          this.write('(');

          for (var _i15 = 0, length = args.length; _i15 < length; ++_i15) {
            if (_i15 !== 0) {
              this.write(',');
            }

            args[_i15].accept(this);
          }

          this.write(')');
        };

        Unparser.prototype.visitChain = function visitChain(chain) {
          var expressions = chain.expressions;

          for (var _i16 = 0, length = expression.length; _i16 < length; ++_i16) {
            if (_i16 !== 0) {
              this.write(';');
            }

            expressions[_i16].accept(this);
          }
        };

        Unparser.prototype.visitBindingBehavior = function visitBindingBehavior(behavior) {
          var args = behavior.args;

          behavior.expression.accept(this);
          this.write('&' + behavior.name);

          for (var _i17 = 0, length = args.length; _i17 < length; ++_i17) {
            this.write(':');
            args[_i17].accept(this);
          }
        };

        Unparser.prototype.visitValueConverter = function visitValueConverter(converter) {
          var args = converter.args;

          converter.expression.accept(this);
          this.write('|' + converter.name);

          for (var _i18 = 0, length = args.length; _i18 < length; ++_i18) {
            this.write(':');
            args[_i18].accept(this);
          }
        };

        Unparser.prototype.visitAssign = function visitAssign(assign) {
          assign.target.accept(this);
          this.write('=');
          assign.value.accept(this);
        };

        Unparser.prototype.visitConditional = function visitConditional(conditional) {
          conditional.condition.accept(this);
          this.write('?');
          conditional.yes.accept(this);
          this.write(':');
          conditional.no.accept(this);
        };

        Unparser.prototype.visitAccessThis = function visitAccessThis(access) {
          if (access.ancestor === 0) {
            this.write('$this');
            return;
          }
          this.write('$parent');
          var i = access.ancestor - 1;
          while (i--) {
            this.write('.$parent');
          }
        };

        Unparser.prototype.visitAccessScope = function visitAccessScope(access) {
          var i = access.ancestor;
          while (i--) {
            this.write('$parent.');
          }
          this.write(access.name);
        };

        Unparser.prototype.visitAccessMember = function visitAccessMember(access) {
          access.object.accept(this);
          this.write('.' + access.name);
        };

        Unparser.prototype.visitAccessKeyed = function visitAccessKeyed(access) {
          access.object.accept(this);
          this.write('[');
          access.key.accept(this);
          this.write(']');
        };

        Unparser.prototype.visitCallScope = function visitCallScope(call) {
          var i = call.ancestor;
          while (i--) {
            this.write('$parent.');
          }
          this.write(call.name);
          this.writeArgs(call.args);
        };

        Unparser.prototype.visitCallFunction = function visitCallFunction(call) {
          call.func.accept(this);
          this.writeArgs(call.args);
        };

        Unparser.prototype.visitCallMember = function visitCallMember(call) {
          call.object.accept(this);
          this.write('.' + call.name);
          this.writeArgs(call.args);
        };

        Unparser.prototype.visitPrefix = function visitPrefix(prefix) {
          this.write('(' + prefix.operation);
          prefix.expression.accept(this);
          this.write(')');
        };

        Unparser.prototype.visitBinary = function visitBinary(binary) {
          binary.left.accept(this);
          this.write(binary.operation);
          binary.right.accept(this);
        };

        Unparser.prototype.visitLiteralPrimitive = function visitLiteralPrimitive(literal) {
          this.write('' + literal.value);
        };

        Unparser.prototype.visitLiteralArray = function visitLiteralArray(literal) {
          var elements = literal.elements;

          this.write('[');

          for (var _i19 = 0, length = elements.length; _i19 < length; ++_i19) {
            if (_i19 !== 0) {
              this.write(',');
            }

            elements[_i19].accept(this);
          }

          this.write(']');
        };

        Unparser.prototype.visitLiteralObject = function visitLiteralObject(literal) {
          var keys = literal.keys;
          var values = literal.values;

          this.write('{');

          for (var _i20 = 0, length = keys.length; _i20 < length; ++_i20) {
            if (_i20 !== 0) {
              this.write(',');
            }

            this.write('\'' + keys[_i20] + '\':');
            values[_i20].accept(this);
          }

          this.write('}');
        };

        Unparser.prototype.visitLiteralString = function visitLiteralString(literal) {
          var escaped = literal.value.replace(/'/g, "\'");
          this.write('\'' + escaped + '\'');
        };

        return Unparser;
      }();
    }

    var ExpressionCloner = exports.ExpressionCloner = function () {
      function ExpressionCloner() {}

      ExpressionCloner.prototype.cloneExpressionArray = function cloneExpressionArray(array) {
        var clonedArray = [];
        var i = array.length;
        while (i--) {
          clonedArray[i] = array[i].accept(this);
        }
        return clonedArray;
      };

      ExpressionCloner.prototype.visitChain = function visitChain(chain) {
        return new Chain(this.cloneExpressionArray(chain.expressions));
      };

      ExpressionCloner.prototype.visitBindingBehavior = function visitBindingBehavior(behavior) {
        return new BindingBehavior(behavior.expression.accept(this), behavior.name, this.cloneExpressionArray(behavior.args));
      };

      ExpressionCloner.prototype.visitValueConverter = function visitValueConverter(converter) {
        return new ValueConverter(converter.expression.accept(this), converter.name, this.cloneExpressionArray(converter.args));
      };

      ExpressionCloner.prototype.visitAssign = function visitAssign(assign) {
        return new Assign(assign.target.accept(this), assign.value.accept(this));
      };

      ExpressionCloner.prototype.visitConditional = function visitConditional(conditional) {
        return new Conditional(conditional.condition.accept(this), conditional.yes.accept(this), conditional.no.accept(this));
      };

      ExpressionCloner.prototype.visitAccessThis = function visitAccessThis(access) {
        return new AccessThis(access.ancestor);
      };

      ExpressionCloner.prototype.visitAccessScope = function visitAccessScope(access) {
        return new AccessScope(access.name, access.ancestor);
      };

      ExpressionCloner.prototype.visitAccessMember = function visitAccessMember(access) {
        return new AccessMember(access.object.accept(this), access.name);
      };

      ExpressionCloner.prototype.visitAccessKeyed = function visitAccessKeyed(access) {
        return new AccessKeyed(access.object.accept(this), access.key.accept(this));
      };

      ExpressionCloner.prototype.visitCallScope = function visitCallScope(call) {
        return new CallScope(call.name, this.cloneExpressionArray(call.args), call.ancestor);
      };

      ExpressionCloner.prototype.visitCallFunction = function visitCallFunction(call) {
        return new CallFunction(call.func.accept(this), this.cloneExpressionArray(call.args));
      };

      ExpressionCloner.prototype.visitCallMember = function visitCallMember(call) {
        return new CallMember(call.object.accept(this), call.name, this.cloneExpressionArray(call.args));
      };

      ExpressionCloner.prototype.visitPrefix = function visitPrefix(prefix) {
        return new PrefixNot(prefix.operation, prefix.expression.accept(this));
      };

      ExpressionCloner.prototype.visitBinary = function visitBinary(binary) {
        return new Binary(binary.operation, binary.left.accept(this), binary.right.accept(this));
      };

      ExpressionCloner.prototype.visitLiteralPrimitive = function visitLiteralPrimitive(literal) {
        return new LiteralPrimitive(literal);
      };

      ExpressionCloner.prototype.visitLiteralArray = function visitLiteralArray(literal) {
        return new LiteralArray(this.cloneExpressionArray(literal.elements));
      };

      ExpressionCloner.prototype.visitLiteralObject = function visitLiteralObject(literal) {
        return new LiteralObject(literal.keys, this.cloneExpressionArray(literal.values));
      };

      ExpressionCloner.prototype.visitLiteralString = function visitLiteralString(literal) {
        return new LiteralString(literal.value);
      };

      return ExpressionCloner;
    }();

    function cloneExpression(expression) {
      var visitor = new ExpressionCloner();
      return expression.accept(visitor);
    }

    var bindingMode = exports.bindingMode = {
      oneTime: 0,
      oneWay: 1,
      twoWay: 2
    };

    var Token = exports.Token = function () {
      function Token(index, text) {

        this.index = index;
        this.text = text;
      }

      Token.prototype.withOp = function withOp(op) {
        this.opKey = op;
        return this;
      };

      Token.prototype.withGetterSetter = function withGetterSetter(key) {
        this.key = key;
        return this;
      };

      Token.prototype.withValue = function withValue(value) {
        this.value = value;
        return this;
      };

      Token.prototype.toString = function toString() {
        return 'Token(' + this.text + ')';
      };

      return Token;
    }();

    var Lexer = exports.Lexer = function () {
      function Lexer() {}

      Lexer.prototype.lex = function lex(text) {
        var scanner = new Scanner(text);
        var tokens = [];
        var token = scanner.scanToken();

        while (token) {
          tokens.push(token);
          token = scanner.scanToken();
        }

        return tokens;
      };

      return Lexer;
    }();

    var Scanner = exports.Scanner = function () {
      function Scanner(input) {

        this.input = input;
        this.length = input.length;
        this.peek = 0;
        this.index = -1;

        this.advance();
      }

      Scanner.prototype.scanToken = function scanToken() {
        while (this.peek <= $SPACE) {
          if (++this.index >= this.length) {
            this.peek = $EOF;
            return null;
          }

          this.peek = this.input.charCodeAt(this.index);
        }

        if (isIdentifierStart(this.peek)) {
          return this.scanIdentifier();
        }

        if (isDigit(this.peek)) {
          return this.scanNumber(this.index);
        }

        var start = this.index;

        switch (this.peek) {
          case $PERIOD:
            this.advance();
            return isDigit(this.peek) ? this.scanNumber(start) : new Token(start, '.');
          case $LPAREN:
          case $RPAREN:
          case $LBRACE:
          case $RBRACE:
          case $LBRACKET:
          case $RBRACKET:
          case $COMMA:
          case $COLON:
          case $SEMICOLON:
            return this.scanCharacter(start, String.fromCharCode(this.peek));
          case $SQ:
          case $DQ:
            return this.scanString();
          case $PLUS:
          case $MINUS:
          case $STAR:
          case $SLASH:
          case $PERCENT:
          case $CARET:
          case $QUESTION:
            return this.scanOperator(start, String.fromCharCode(this.peek));
          case $LT:
          case $GT:
          case $BANG:
          case $EQ:
            return this.scanComplexOperator(start, $EQ, String.fromCharCode(this.peek), '=');
          case $AMPERSAND:
            return this.scanComplexOperator(start, $AMPERSAND, '&', '&');
          case $BAR:
            return this.scanComplexOperator(start, $BAR, '|', '|');
          case $NBSP:
            while (isWhitespace(this.peek)) {
              this.advance();
            }

            return this.scanToken();
        }

        var character = String.fromCharCode(this.peek);
        this.error('Unexpected character [' + character + ']');
        return null;
      };

      Scanner.prototype.scanCharacter = function scanCharacter(start, text) {
        assert(this.peek === text.charCodeAt(0));
        this.advance();
        return new Token(start, text);
      };

      Scanner.prototype.scanOperator = function scanOperator(start, text) {
        assert(this.peek === text.charCodeAt(0));
        assert(OPERATORS.indexOf(text) !== -1);
        this.advance();
        return new Token(start, text).withOp(text);
      };

      Scanner.prototype.scanComplexOperator = function scanComplexOperator(start, code, one, two) {
        assert(this.peek === one.charCodeAt(0));
        this.advance();

        var text = one;

        if (this.peek === code) {
          this.advance();
          text += two;
        }

        if (this.peek === code) {
          this.advance();
          text += two;
        }

        assert(OPERATORS.indexOf(text) !== -1);

        return new Token(start, text).withOp(text);
      };

      Scanner.prototype.scanIdentifier = function scanIdentifier() {
        assert(isIdentifierStart(this.peek));
        var start = this.index;

        this.advance();

        while (isIdentifierPart(this.peek)) {
          this.advance();
        }

        var text = this.input.substring(start, this.index);
        var result = new Token(start, text);

        if (OPERATORS.indexOf(text) !== -1) {
          result.withOp(text);
        } else {
          result.withGetterSetter(text);
        }

        return result;
      };

      Scanner.prototype.scanNumber = function scanNumber(start) {
        assert(isDigit(this.peek));
        var simple = this.index === start;
        this.advance();

        while (true) {
          if (!isDigit(this.peek)) {
            if (this.peek === $PERIOD) {
              simple = false;
            } else if (isExponentStart(this.peek)) {
              this.advance();

              if (isExponentSign(this.peek)) {
                this.advance();
              }

              if (!isDigit(this.peek)) {
                this.error('Invalid exponent', -1);
              }

              simple = false;
            } else {
              break;
            }
          }

          this.advance();
        }

        var text = this.input.substring(start, this.index);
        var value = simple ? parseInt(text, 10) : parseFloat(text);
        return new Token(start, text).withValue(value);
      };

      Scanner.prototype.scanString = function scanString() {
        assert(this.peek === $SQ || this.peek === $DQ);

        var start = this.index;
        var quote = this.peek;

        this.advance();

        var buffer = void 0;
        var marker = this.index;

        while (this.peek !== quote) {
          if (this.peek === $BACKSLASH) {
            if (!buffer) {
              buffer = [];
            }

            buffer.push(this.input.substring(marker, this.index));
            this.advance();

            var _unescaped = void 0;

            if (this.peek === $u) {
              var hex = this.input.substring(this.index + 1, this.index + 5);

              if (!/[A-Z0-9]{4}/.test(hex)) {
                this.error('Invalid unicode escape [\\u' + hex + ']');
              }

              _unescaped = parseInt(hex, 16);

              for (var _i21 = 0; _i21 < 5; ++_i21) {
                this.advance();
              }
            } else {
              _unescaped = unescape(this.peek);
              this.advance();
            }

            buffer.push(String.fromCharCode(_unescaped));
            marker = this.index;
          } else if (this.peek === $EOF) {
            this.error('Unterminated quote');
          } else {
            this.advance();
          }
        }

        var last = this.input.substring(marker, this.index);
        this.advance();
        var text = this.input.substring(start, this.index);

        var unescaped = last;

        if (buffer !== null && buffer !== undefined) {
          buffer.push(last);
          unescaped = buffer.join('');
        }

        return new Token(start, text).withValue(unescaped);
      };

      Scanner.prototype.advance = function advance() {
        if (++this.index >= this.length) {
          this.peek = $EOF;
        } else {
          this.peek = this.input.charCodeAt(this.index);
        }
      };

      Scanner.prototype.error = function error(message) {
        var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var position = this.index + offset;
        throw new Error('Lexer Error: ' + message + ' at column ' + position + ' in expression [' + this.input + ']');
      };

      return Scanner;
    }();

    var OPERATORS = ['undefined', 'null', 'true', 'false', '+', '-', '*', '/', '%', '^', '=', '==', '===', '!=', '!==', '<', '>', '<=', '>=', '&&', '||', '&', '|', '!', '?'];

    var $EOF = 0;
    var $TAB = 9;
    var $LF = 10;
    var $VTAB = 11;
    var $FF = 12;
    var $CR = 13;
    var $SPACE = 32;
    var $BANG = 33;
    var $DQ = 34;
    var $$ = 36;
    var $PERCENT = 37;
    var $AMPERSAND = 38;
    var $SQ = 39;
    var $LPAREN = 40;
    var $RPAREN = 41;
    var $STAR = 42;
    var $PLUS = 43;
    var $COMMA = 44;
    var $MINUS = 45;
    var $PERIOD = 46;
    var $SLASH = 47;
    var $COLON = 58;
    var $SEMICOLON = 59;
    var $LT = 60;
    var $EQ = 61;
    var $GT = 62;
    var $QUESTION = 63;

    var $0 = 48;
    var $9 = 57;

    var $A = 65;
    var $E = 69;
    var $Z = 90;

    var $LBRACKET = 91;
    var $BACKSLASH = 92;
    var $RBRACKET = 93;
    var $CARET = 94;
    var $_ = 95;

    var $a = 97;
    var $e = 101;
    var $f = 102;
    var $n = 110;
    var $r = 114;
    var $t = 116;
    var $u = 117;
    var $v = 118;
    var $z = 122;

    var $LBRACE = 123;
    var $BAR = 124;
    var $RBRACE = 125;
    var $NBSP = 160;

    function isWhitespace(code) {
      return code >= $TAB && code <= $SPACE || code === $NBSP;
    }

    function isIdentifierStart(code) {
      return $a <= code && code <= $z || $A <= code && code <= $Z || code === $_ || code === $$;
    }

    function isIdentifierPart(code) {
      return $a <= code && code <= $z || $A <= code && code <= $Z || $0 <= code && code <= $9 || code === $_ || code === $$;
    }

    function isDigit(code) {
      return $0 <= code && code <= $9;
    }

    function isExponentStart(code) {
      return code === $e || code === $E;
    }

    function isExponentSign(code) {
      return code === $MINUS || code === $PLUS;
    }

    function unescape(code) {
      switch (code) {
        case $n:
          return $LF;
        case $f:
          return $FF;
        case $r:
          return $CR;
        case $t:
          return $TAB;
        case $v:
          return $VTAB;
        default:
          return code;
      }
    }

    function assert(condition, message) {
      if (!condition) {
        throw message || 'Assertion failed';
      }
    }

    var EOF = new Token(-1, null);

    var Parser = exports.Parser = function () {
      function Parser() {

        this.cache = {};
        this.lexer = new Lexer();
      }

      Parser.prototype.parse = function parse(input) {
        input = input || '';

        return this.cache[input] || (this.cache[input] = new ParserImplementation(this.lexer, input).parseChain());
      };

      return Parser;
    }();

    var ParserImplementation = exports.ParserImplementation = function () {
      function ParserImplementation(lexer, input) {

        this.index = 0;
        this.input = input;
        this.tokens = lexer.lex(input);
      }

      ParserImplementation.prototype.parseChain = function parseChain() {
        var isChain = false;
        var expressions = [];

        while (this.optional(';')) {
          isChain = true;
        }

        while (this.index < this.tokens.length) {
          if (this.peek.text === ')' || this.peek.text === '}' || this.peek.text === ']') {
            this.error('Unconsumed token ' + this.peek.text);
          }

          var expr = this.parseBindingBehavior();
          expressions.push(expr);

          while (this.optional(';')) {
            isChain = true;
          }

          if (isChain) {
            this.error('Multiple expressions are not allowed.');
          }
        }

        return expressions.length === 1 ? expressions[0] : new Chain(expressions);
      };

      ParserImplementation.prototype.parseBindingBehavior = function parseBindingBehavior() {
        var result = this.parseValueConverter();

        while (this.optional('&')) {
          var name = this.peek.text;
          var args = [];

          this.advance();

          while (this.optional(':')) {
            args.push(this.parseExpression());
          }

          result = new BindingBehavior(result, name, args);
        }

        return result;
      };

      ParserImplementation.prototype.parseValueConverter = function parseValueConverter() {
        var result = this.parseExpression();

        while (this.optional('|')) {
          var name = this.peek.text;
          var args = [];

          this.advance();

          while (this.optional(':')) {
            args.push(this.parseExpression());
          }

          result = new ValueConverter(result, name, args, [result].concat(args));
        }

        return result;
      };

      ParserImplementation.prototype.parseExpression = function parseExpression() {
        var start = this.peek.index;
        var result = this.parseConditional();

        while (this.peek.text === '=') {
          if (!result.isAssignable) {
            var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
            var _expression = this.input.substring(start, end);

            this.error('Expression ' + _expression + ' is not assignable');
          }

          this.expect('=');
          result = new Assign(result, this.parseConditional());
        }

        return result;
      };

      ParserImplementation.prototype.parseConditional = function parseConditional() {
        var start = this.peek.index;
        var result = this.parseLogicalOr();

        if (this.optional('?')) {
          var yes = this.parseExpression();

          if (!this.optional(':')) {
            var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
            var _expression2 = this.input.substring(start, end);

            this.error('Conditional expression ' + _expression2 + ' requires all 3 expressions');
          }

          var no = this.parseExpression();
          result = new Conditional(result, yes, no);
        }

        return result;
      };

      ParserImplementation.prototype.parseLogicalOr = function parseLogicalOr() {
        var result = this.parseLogicalAnd();

        while (this.optional('||')) {
          result = new Binary('||', result, this.parseLogicalAnd());
        }

        return result;
      };

      ParserImplementation.prototype.parseLogicalAnd = function parseLogicalAnd() {
        var result = this.parseEquality();

        while (this.optional('&&')) {
          result = new Binary('&&', result, this.parseEquality());
        }

        return result;
      };

      ParserImplementation.prototype.parseEquality = function parseEquality() {
        var result = this.parseRelational();

        while (true) {
          if (this.optional('==')) {
            result = new Binary('==', result, this.parseRelational());
          } else if (this.optional('!=')) {
            result = new Binary('!=', result, this.parseRelational());
          } else if (this.optional('===')) {
            result = new Binary('===', result, this.parseRelational());
          } else if (this.optional('!==')) {
            result = new Binary('!==', result, this.parseRelational());
          } else {
            return result;
          }
        }
      };

      ParserImplementation.prototype.parseRelational = function parseRelational() {
        var result = this.parseAdditive();

        while (true) {
          if (this.optional('<')) {
            result = new Binary('<', result, this.parseAdditive());
          } else if (this.optional('>')) {
            result = new Binary('>', result, this.parseAdditive());
          } else if (this.optional('<=')) {
            result = new Binary('<=', result, this.parseAdditive());
          } else if (this.optional('>=')) {
            result = new Binary('>=', result, this.parseAdditive());
          } else {
            return result;
          }
        }
      };

      ParserImplementation.prototype.parseAdditive = function parseAdditive() {
        var result = this.parseMultiplicative();

        while (true) {
          if (this.optional('+')) {
            result = new Binary('+', result, this.parseMultiplicative());
          } else if (this.optional('-')) {
            result = new Binary('-', result, this.parseMultiplicative());
          } else {
            return result;
          }
        }
      };

      ParserImplementation.prototype.parseMultiplicative = function parseMultiplicative() {
        var result = this.parsePrefix();

        while (true) {
          if (this.optional('*')) {
            result = new Binary('*', result, this.parsePrefix());
          } else if (this.optional('%')) {
            result = new Binary('%', result, this.parsePrefix());
          } else if (this.optional('/')) {
            result = new Binary('/', result, this.parsePrefix());
          } else {
            return result;
          }
        }
      };

      ParserImplementation.prototype.parsePrefix = function parsePrefix() {
        if (this.optional('+')) {
          return this.parsePrefix();
        } else if (this.optional('-')) {
          return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
        } else if (this.optional('!')) {
          return new PrefixNot('!', this.parsePrefix());
        }

        return this.parseAccessOrCallMember();
      };

      ParserImplementation.prototype.parseAccessOrCallMember = function parseAccessOrCallMember() {
        var result = this.parsePrimary();

        while (true) {
          if (this.optional('.')) {
            var name = this.peek.text;

            this.advance();

            if (this.optional('(')) {
              var args = this.parseExpressionList(')');
              this.expect(')');
              if (result instanceof AccessThis) {
                result = new CallScope(name, args, result.ancestor);
              } else {
                result = new CallMember(result, name, args);
              }
            } else {
              if (result instanceof AccessThis) {
                result = new AccessScope(name, result.ancestor);
              } else {
                result = new AccessMember(result, name);
              }
            }
          } else if (this.optional('[')) {
            var key = this.parseExpression();
            this.expect(']');
            result = new AccessKeyed(result, key);
          } else if (this.optional('(')) {
            var _args = this.parseExpressionList(')');
            this.expect(')');
            result = new CallFunction(result, _args);
          } else {
            return result;
          }
        }
      };

      ParserImplementation.prototype.parsePrimary = function parsePrimary() {
        if (this.optional('(')) {
          var result = this.parseExpression();
          this.expect(')');
          return result;
        } else if (this.optional('null')) {
          return new LiteralPrimitive(null);
        } else if (this.optional('undefined')) {
          return new LiteralPrimitive(undefined);
        } else if (this.optional('true')) {
          return new LiteralPrimitive(true);
        } else if (this.optional('false')) {
          return new LiteralPrimitive(false);
        } else if (this.optional('[')) {
          var elements = this.parseExpressionList(']');
          this.expect(']');
          return new LiteralArray(elements);
        } else if (this.peek.text === '{') {
          return this.parseObject();
        } else if (this.peek.key !== null && this.peek.key !== undefined) {
          return this.parseAccessOrCallScope();
        } else if (this.peek.value !== null && this.peek.value !== undefined) {
          var value = this.peek.value;
          this.advance();
          return value instanceof String || typeof value === 'string' ? new LiteralString(value) : new LiteralPrimitive(value);
        } else if (this.index >= this.tokens.length) {
          throw new Error('Unexpected end of expression: ' + this.input);
        } else {
          this.error('Unexpected token ' + this.peek.text);
        }
      };

      ParserImplementation.prototype.parseAccessOrCallScope = function parseAccessOrCallScope() {
        var name = this.peek.key;

        this.advance();

        if (name === '$this') {
          return new AccessThis(0);
        }

        var ancestor = 0;
        while (name === '$parent') {
          ancestor++;
          if (this.optional('.')) {
            name = this.peek.key;
            this.advance();
          } else if (this.peek === EOF || this.peek.text === '(' || this.peek.text === ')' || this.peek.text === '[' || this.peek.text === '}' || this.peek.text === ',') {
            return new AccessThis(ancestor);
          } else {
            this.error('Unexpected token ' + this.peek.text);
          }
        }

        if (this.optional('(')) {
          var args = this.parseExpressionList(')');
          this.expect(')');
          return new CallScope(name, args, ancestor);
        }

        return new AccessScope(name, ancestor);
      };

      ParserImplementation.prototype.parseObject = function parseObject() {
        var keys = [];
        var values = [];

        this.expect('{');

        if (this.peek.text !== '}') {
          do {
            var peek = this.peek;
            var value = peek.value;
            keys.push(typeof value === 'string' ? value : peek.text);

            this.advance();
            if (peek.key && (this.peek.text === ',' || this.peek.text === '}')) {
              --this.index;
              values.push(this.parseAccessOrCallScope());
            } else {
              this.expect(':');
              values.push(this.parseExpression());
            }
          } while (this.optional(','));
        }

        this.expect('}');

        return new LiteralObject(keys, values);
      };

      ParserImplementation.prototype.parseExpressionList = function parseExpressionList(terminator) {
        var result = [];

        if (this.peek.text !== terminator) {
          do {
            result.push(this.parseExpression());
          } while (this.optional(','));
        }

        return result;
      };

      ParserImplementation.prototype.optional = function optional(text) {
        if (this.peek.text === text) {
          this.advance();
          return true;
        }

        return false;
      };

      ParserImplementation.prototype.expect = function expect(text) {
        if (this.peek.text === text) {
          this.advance();
        } else {
          this.error('Missing expected ' + text);
        }
      };

      ParserImplementation.prototype.advance = function advance() {
        this.index++;
      };

      ParserImplementation.prototype.error = function error(message) {
        var location = this.index < this.tokens.length ? 'at column ' + (this.tokens[this.index].index + 1) + ' in' : 'at the end of the expression';

        throw new Error('Parser Error: ' + message + ' ' + location + ' [' + this.input + ']');
      };

      _createClass(ParserImplementation, [{
        key: 'peek',
        get: function get() {
          return this.index < this.tokens.length ? this.tokens[this.index] : EOF;
        }
      }]);

      return ParserImplementation;
    }();

    var mapProto = Map.prototype;

    function _getMapObserver(taskQueue, map) {
      return ModifyMapObserver.for(taskQueue, map);
    }

    exports.getMapObserver = _getMapObserver;

    var ModifyMapObserver = function (_ModifyCollectionObse2) {
      _inherits(ModifyMapObserver, _ModifyCollectionObse2);

      function ModifyMapObserver(taskQueue, map) {

        return _possibleConstructorReturn(this, _ModifyCollectionObse2.call(this, taskQueue, map));
      }

      ModifyMapObserver.for = function _for(taskQueue, map) {
        if (!('__map_observer__' in map)) {
          Reflect.defineProperty(map, '__map_observer__', {
            value: ModifyMapObserver.create(taskQueue, map),
            enumerable: false, configurable: false
          });
        }
        return map.__map_observer__;
      };

      ModifyMapObserver.create = function create(taskQueue, map) {
        var observer = new ModifyMapObserver(taskQueue, map);

        var proto = mapProto;
        if (proto.set !== map.set || proto.delete !== map.delete || proto.clear !== map.clear) {
          proto = {
            set: map.set,
            delete: map.delete,
            clear: map.clear
          };
        }

        map.set = function () {
          var hasValue = map.has(arguments[0]);
          var type = hasValue ? 'update' : 'add';
          var oldValue = map.get(arguments[0]);
          var methodCallResult = proto.set.apply(map, arguments);
          if (!hasValue || oldValue !== map.get(arguments[0])) {
            observer.addChangeRecord({
              type: type,
              object: map,
              key: arguments[0],
              oldValue: oldValue
            });
          }
          return methodCallResult;
        };

        map.delete = function () {
          var hasValue = map.has(arguments[0]);
          var oldValue = map.get(arguments[0]);
          var methodCallResult = proto.delete.apply(map, arguments);
          if (hasValue) {
            observer.addChangeRecord({
              type: 'delete',
              object: map,
              key: arguments[0],
              oldValue: oldValue
            });
          }
          return methodCallResult;
        };

        map.clear = function () {
          var methodCallResult = proto.clear.apply(map, arguments);
          observer.addChangeRecord({
            type: 'clear',
            object: map
          });
          return methodCallResult;
        };

        return observer;
      };

      return ModifyMapObserver;
    }(ModifyCollectionObserver);

    function findOriginalEventTarget(event) {
      return event.path && event.path[0] || event.deepPath && event.deepPath[0] || event.target;
    }

    function stopPropagation() {
      this.standardStopPropagation();
      this.propagationStopped = true;
    }

    function interceptStopPropagation(event) {
      event.standardStopPropagation = event.stopPropagation;
      event.stopPropagation = stopPropagation;
    }

    function handleCapturedEvent(event) {
      var interceptInstalled = false;
      event.propagationStopped = false;
      var target = findOriginalEventTarget(event);

      var orderedCallbacks = [];

      while (target) {
        if (target.capturedCallbacks) {
          var callback = target.capturedCallbacks[event.type];
          if (callback) {
            if (!interceptInstalled) {
              interceptStopPropagation(event);
              interceptInstalled = true;
            }
            orderedCallbacks.push(callback);
          }
        }
        target = target.parentNode;
      }
      for (var _i22 = orderedCallbacks.length - 1; _i22 >= 0; _i22--) {
        var orderedCallback = orderedCallbacks[_i22];
        orderedCallback(event);
        if (event.propagationStopped) {
          break;
        }
      }
    }

    var CapturedHandlerEntry = function () {
      function CapturedHandlerEntry(eventName) {

        this.eventName = eventName;
        this.count = 0;
      }

      CapturedHandlerEntry.prototype.increment = function increment() {
        this.count++;

        if (this.count === 1) {
          _aureliaPal.DOM.addEventListener(this.eventName, handleCapturedEvent, true);
        }
      };

      CapturedHandlerEntry.prototype.decrement = function decrement() {
        this.count--;

        if (this.count === 0) {
          _aureliaPal.DOM.removeEventListener(this.eventName, handleCapturedEvent, true);
        }
      };

      return CapturedHandlerEntry;
    }();

    function handleDelegatedEvent(event) {
      var interceptInstalled = false;
      event.propagationStopped = false;
      var target = findOriginalEventTarget(event);

      while (target && !event.propagationStopped) {
        if (target.delegatedCallbacks) {
          var callback = target.delegatedCallbacks[event.type];
          if (callback) {
            if (!interceptInstalled) {
              interceptStopPropagation(event);
              interceptInstalled = true;
            }
            callback(event);
          }
        }

        target = target.parentNode;
      }
    }

    var DelegateHandlerEntry = function () {
      function DelegateHandlerEntry(eventName) {

        this.eventName = eventName;
        this.count = 0;
      }

      DelegateHandlerEntry.prototype.increment = function increment() {
        this.count++;

        if (this.count === 1) {
          _aureliaPal.DOM.addEventListener(this.eventName, handleDelegatedEvent, false);
        }
      };

      DelegateHandlerEntry.prototype.decrement = function decrement() {
        this.count--;

        if (this.count === 0) {
          _aureliaPal.DOM.removeEventListener(this.eventName, handleDelegatedEvent);
        }
      };

      return DelegateHandlerEntry;
    }();

    var DefaultEventStrategy = function () {
      function DefaultEventStrategy() {

        this.delegatedHandlers = {};
        this.capturedHandlers = {};
      }

      DefaultEventStrategy.prototype.subscribe = function subscribe(target, targetEvent, callback, strategy) {
        var _this22 = this;

        var delegatedHandlers = void 0;
        var capturedHandlers = void 0;
        var handlerEntry = void 0;

        if (strategy === delegationStrategy.bubbling) {
          var _ret = function () {
            delegatedHandlers = _this22.delegatedHandlers;
            handlerEntry = delegatedHandlers[targetEvent] || (delegatedHandlers[targetEvent] = new DelegateHandlerEntry(targetEvent));
            var delegatedCallbacks = target.delegatedCallbacks || (target.delegatedCallbacks = {});

            handlerEntry.increment();
            delegatedCallbacks[targetEvent] = callback;

            return {
              v: function v() {
                handlerEntry.decrement();
                delegatedCallbacks[targetEvent] = null;
              }
            };
          }();

          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
        }
        if (strategy === delegationStrategy.capturing) {
          var _ret2 = function () {
            capturedHandlers = _this22.capturedHandlers;
            handlerEntry = capturedHandlers[targetEvent] || (capturedHandlers[targetEvent] = new CapturedHandlerEntry(targetEvent));
            var capturedCallbacks = target.capturedCallbacks || (target.capturedCallbacks = {});

            handlerEntry.increment();
            capturedCallbacks[targetEvent] = callback;

            return {
              v: function v() {
                handlerEntry.decrement();
                capturedCallbacks[targetEvent] = null;
              }
            };
          }();

          if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
        }

        target.addEventListener(targetEvent, callback, false);

        return function () {
          target.removeEventListener(targetEvent, callback);
        };
      };

      return DefaultEventStrategy;
    }();

    var delegationStrategy = exports.delegationStrategy = {
      none: 0,
      capturing: 1,
      bubbling: 2
    };

    var EventManager = exports.EventManager = function () {
      function EventManager() {

        this.elementHandlerLookup = {};
        this.eventStrategyLookup = {};

        this.registerElementConfig({
          tagName: 'input',
          properties: {
            value: ['change', 'input'],
            checked: ['change', 'input'],
            files: ['change', 'input']
          }
        });

        this.registerElementConfig({
          tagName: 'textarea',
          properties: {
            value: ['change', 'input']
          }
        });

        this.registerElementConfig({
          tagName: 'select',
          properties: {
            value: ['change']
          }
        });

        this.registerElementConfig({
          tagName: 'content editable',
          properties: {
            value: ['change', 'input', 'blur', 'keyup', 'paste']
          }
        });

        this.registerElementConfig({
          tagName: 'scrollable element',
          properties: {
            scrollTop: ['scroll'],
            scrollLeft: ['scroll']
          }
        });

        this.defaultEventStrategy = new DefaultEventStrategy();
      }

      EventManager.prototype.registerElementConfig = function registerElementConfig(config) {
        var tagName = config.tagName.toLowerCase();
        var properties = config.properties;
        var propertyName = void 0;

        this.elementHandlerLookup[tagName] = {};

        for (propertyName in properties) {
          if (properties.hasOwnProperty(propertyName)) {
            this.registerElementPropertyConfig(tagName, propertyName, properties[propertyName]);
          }
        }
      };

      EventManager.prototype.registerElementPropertyConfig = function registerElementPropertyConfig(tagName, propertyName, events) {
        this.elementHandlerLookup[tagName][propertyName] = this.createElementHandler(events);
      };

      EventManager.prototype.createElementHandler = function createElementHandler(events) {
        return {
          subscribe: function subscribe(target, callback) {
            events.forEach(function (changeEvent) {
              target.addEventListener(changeEvent, callback, false);
            });

            return function () {
              events.forEach(function (changeEvent) {
                target.removeEventListener(changeEvent, callback);
              });
            };
          }
        };
      };

      EventManager.prototype.registerElementHandler = function registerElementHandler(tagName, handler) {
        this.elementHandlerLookup[tagName.toLowerCase()] = handler;
      };

      EventManager.prototype.registerEventStrategy = function registerEventStrategy(eventName, strategy) {
        this.eventStrategyLookup[eventName] = strategy;
      };

      EventManager.prototype.getElementHandler = function getElementHandler(target, propertyName) {
        var tagName = void 0;
        var lookup = this.elementHandlerLookup;

        if (target.tagName) {
          tagName = target.tagName.toLowerCase();

          if (lookup[tagName] && lookup[tagName][propertyName]) {
            return lookup[tagName][propertyName];
          }

          if (propertyName === 'textContent' || propertyName === 'innerHTML') {
            return lookup['content editable'].value;
          }

          if (propertyName === 'scrollTop' || propertyName === 'scrollLeft') {
            return lookup['scrollable element'][propertyName];
          }
        }

        return null;
      };

      EventManager.prototype.addEventListener = function addEventListener(target, targetEvent, callback, delegate) {
        return (this.eventStrategyLookup[targetEvent] || this.defaultEventStrategy).subscribe(target, targetEvent, callback, delegate);
      };

      return EventManager;
    }();

    var DirtyChecker = exports.DirtyChecker = function () {
      function DirtyChecker() {

        this.tracked = [];
        this.checkDelay = 120;
      }

      DirtyChecker.prototype.addProperty = function addProperty(property) {
        var tracked = this.tracked;

        tracked.push(property);

        if (tracked.length === 1) {
          this.scheduleDirtyCheck();
        }
      };

      DirtyChecker.prototype.removeProperty = function removeProperty(property) {
        var tracked = this.tracked;
        tracked.splice(tracked.indexOf(property), 1);
      };

      DirtyChecker.prototype.scheduleDirtyCheck = function scheduleDirtyCheck() {
        var _this23 = this;

        setTimeout(function () {
          return _this23.check();
        }, this.checkDelay);
      };

      DirtyChecker.prototype.check = function check() {
        var tracked = this.tracked;
        var i = tracked.length;

        while (i--) {
          var current = tracked[i];

          if (current.isDirty()) {
            current.call();
          }
        }

        if (tracked.length) {
          this.scheduleDirtyCheck();
        }
      };

      return DirtyChecker;
    }();

    var DirtyCheckProperty = exports.DirtyCheckProperty = (_dec5 = subscriberCollection(), _dec5(_class5 = function () {
      function DirtyCheckProperty(dirtyChecker, obj, propertyName) {

        this.dirtyChecker = dirtyChecker;
        this.obj = obj;
        this.propertyName = propertyName;
      }

      DirtyCheckProperty.prototype.getValue = function getValue() {
        return this.obj[this.propertyName];
      };

      DirtyCheckProperty.prototype.setValue = function setValue(newValue) {
        this.obj[this.propertyName] = newValue;
      };

      DirtyCheckProperty.prototype.call = function call() {
        var oldValue = this.oldValue;
        var newValue = this.getValue();

        this.callSubscribers(newValue, oldValue);

        this.oldValue = newValue;
      };

      DirtyCheckProperty.prototype.isDirty = function isDirty() {
        return this.oldValue !== this.obj[this.propertyName];
      };

      DirtyCheckProperty.prototype.subscribe = function subscribe(context, callable) {
        if (!this.hasSubscribers()) {
          this.oldValue = this.getValue();
          this.dirtyChecker.addProperty(this);
        }
        this.addSubscriber(context, callable);
      };

      DirtyCheckProperty.prototype.unsubscribe = function unsubscribe(context, callable) {
        if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
          this.dirtyChecker.removeProperty(this);
        }
      };

      return DirtyCheckProperty;
    }()) || _class5);

    var logger = LogManager.getLogger('property-observation');

    var propertyAccessor = exports.propertyAccessor = {
      getValue: function getValue(obj, propertyName) {
        return obj[propertyName];
      },
      setValue: function setValue(value, obj, propertyName) {
        obj[propertyName] = value;
      }
    };

    var PrimitiveObserver = exports.PrimitiveObserver = function () {
      function PrimitiveObserver(primitive, propertyName) {

        this.doNotCache = true;

        this.primitive = primitive;
        this.propertyName = propertyName;
      }

      PrimitiveObserver.prototype.getValue = function getValue() {
        return this.primitive[this.propertyName];
      };

      PrimitiveObserver.prototype.setValue = function setValue() {
        var type = _typeof(this.primitive);
        throw new Error('The ' + this.propertyName + ' property of a ' + type + ' (' + this.primitive + ') cannot be assigned.');
      };

      PrimitiveObserver.prototype.subscribe = function subscribe() {};

      PrimitiveObserver.prototype.unsubscribe = function unsubscribe() {};

      return PrimitiveObserver;
    }();

    var SetterObserver = exports.SetterObserver = (_dec6 = subscriberCollection(), _dec6(_class7 = function () {
      function SetterObserver(taskQueue, obj, propertyName) {

        this.taskQueue = taskQueue;
        this.obj = obj;
        this.propertyName = propertyName;
        this.queued = false;
        this.observing = false;
      }

      SetterObserver.prototype.getValue = function getValue() {
        return this.obj[this.propertyName];
      };

      SetterObserver.prototype.setValue = function setValue(newValue) {
        this.obj[this.propertyName] = newValue;
      };

      SetterObserver.prototype.getterValue = function getterValue() {
        return this.currentValue;
      };

      SetterObserver.prototype.setterValue = function setterValue(newValue) {
        var oldValue = this.currentValue;

        if (oldValue !== newValue) {
          if (!this.queued) {
            this.oldValue = oldValue;
            this.queued = true;
            this.taskQueue.queueMicroTask(this);
          }

          this.currentValue = newValue;
        }
      };

      SetterObserver.prototype.call = function call() {
        var oldValue = this.oldValue;
        var newValue = this.currentValue;

        this.queued = false;

        this.callSubscribers(newValue, oldValue);
      };

      SetterObserver.prototype.subscribe = function subscribe(context, callable) {
        if (!this.observing) {
          this.convertProperty();
        }
        this.addSubscriber(context, callable);
      };

      SetterObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
        this.removeSubscriber(context, callable);
      };

      SetterObserver.prototype.convertProperty = function convertProperty() {
        this.observing = true;
        this.currentValue = this.obj[this.propertyName];
        this.setValue = this.setterValue;
        this.getValue = this.getterValue;

        if (!Reflect.defineProperty(this.obj, this.propertyName, {
          configurable: true,
          enumerable: this.propertyName in this.obj ? this.obj.propertyIsEnumerable(this.propertyName) : true,
          get: this.getValue.bind(this),
          set: this.setValue.bind(this)
        })) {
          logger.warn('Cannot observe property \'' + this.propertyName + '\' of object', this.obj);
        }
      };

      return SetterObserver;
    }()) || _class7);

    var XLinkAttributeObserver = exports.XLinkAttributeObserver = function () {
      function XLinkAttributeObserver(element, propertyName, attributeName) {

        this.element = element;
        this.propertyName = propertyName;
        this.attributeName = attributeName;
      }

      XLinkAttributeObserver.prototype.getValue = function getValue() {
        return this.element.getAttributeNS('http://www.w3.org/1999/xlink', this.attributeName);
      };

      XLinkAttributeObserver.prototype.setValue = function setValue(newValue) {
        return this.element.setAttributeNS('http://www.w3.org/1999/xlink', this.attributeName, newValue);
      };

      XLinkAttributeObserver.prototype.subscribe = function subscribe() {
        throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
      };

      return XLinkAttributeObserver;
    }();

    var dataAttributeAccessor = exports.dataAttributeAccessor = {
      getValue: function getValue(obj, propertyName) {
        return obj.getAttribute(propertyName);
      },
      setValue: function setValue(value, obj, propertyName) {
        return obj.setAttribute(propertyName, value);
      }
    };

    var DataAttributeObserver = exports.DataAttributeObserver = function () {
      function DataAttributeObserver(element, propertyName) {

        this.element = element;
        this.propertyName = propertyName;
      }

      DataAttributeObserver.prototype.getValue = function getValue() {
        return this.element.getAttribute(this.propertyName);
      };

      DataAttributeObserver.prototype.setValue = function setValue(newValue) {
        return this.element.setAttribute(this.propertyName, newValue);
      };

      DataAttributeObserver.prototype.subscribe = function subscribe() {
        throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
      };

      return DataAttributeObserver;
    }();

    var StyleObserver = exports.StyleObserver = function () {
      function StyleObserver(element, propertyName) {

        this.element = element;
        this.propertyName = propertyName;

        this.styles = null;
        this.version = 0;
      }

      StyleObserver.prototype.getValue = function getValue() {
        return this.element.style.cssText;
      };

      StyleObserver.prototype._setProperty = function _setProperty(style, value) {
        var priority = '';

        if (value !== null && value !== undefined && typeof value.indexOf === 'function' && value.indexOf('!important') !== -1) {
          priority = 'important';
          value = value.replace('!important', '');
        }
        this.element.style.setProperty(style, value, priority);
      };

      StyleObserver.prototype.setValue = function setValue(newValue) {
        var styles = this.styles || {};
        var style = void 0;
        var version = this.version;

        if (newValue !== null && newValue !== undefined) {
          if (newValue instanceof Object) {
            var value = void 0;
            for (style in newValue) {
              if (newValue.hasOwnProperty(style)) {
                value = newValue[style];
                style = style.replace(/([A-Z])/g, function (m) {
                  return '-' + m.toLowerCase();
                });
                styles[style] = version;
                this._setProperty(style, value);
              }
            }
          } else if (newValue.length) {
            var rx = /\s*([\w\-]+)\s*:\s*((?:(?:[\w\-]+\(\s*(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[\w\-]+\(\s*(?:^"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^\)]*)\),?|[^\)]*)\),?|"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^;]*),?\s*)+);?/g;
            var pair = void 0;
            while ((pair = rx.exec(newValue)) !== null) {
              style = pair[1];
              if (!style) {
                continue;
              }

              styles[style] = version;
              this._setProperty(style, pair[2]);
            }
          }
        }

        this.styles = styles;
        this.version += 1;

        if (version === 0) {
          return;
        }

        version -= 1;
        for (style in styles) {
          if (!styles.hasOwnProperty(style) || styles[style] !== version) {
            continue;
          }

          this.element.style.removeProperty(style);
        }
      };

      StyleObserver.prototype.subscribe = function subscribe() {
        throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
      };

      return StyleObserver;
    }();

    var ValueAttributeObserver = exports.ValueAttributeObserver = (_dec7 = subscriberCollection(), _dec7(_class8 = function () {
      function ValueAttributeObserver(element, propertyName, handler) {

        this.element = element;
        this.propertyName = propertyName;
        this.handler = handler;
        if (propertyName === 'files') {
          this.setValue = function () {};
        }
      }

      ValueAttributeObserver.prototype.getValue = function getValue() {
        return this.element[this.propertyName];
      };

      ValueAttributeObserver.prototype.setValue = function setValue(newValue) {
        newValue = newValue === undefined || newValue === null ? '' : newValue;
        if (this.element[this.propertyName] !== newValue) {
          this.element[this.propertyName] = newValue;
          this.notify();
        }
      };

      ValueAttributeObserver.prototype.notify = function notify() {
        var oldValue = this.oldValue;
        var newValue = this.getValue();

        this.callSubscribers(newValue, oldValue);

        this.oldValue = newValue;
      };

      ValueAttributeObserver.prototype.subscribe = function subscribe(context, callable) {
        if (!this.hasSubscribers()) {
          this.oldValue = this.getValue();
          this.disposeHandler = this.handler.subscribe(this.element, this.notify.bind(this));
        }

        this.addSubscriber(context, callable);
      };

      ValueAttributeObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
        if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
          this.disposeHandler();
          this.disposeHandler = null;
        }
      };

      return ValueAttributeObserver;
    }()) || _class8);

    var checkedArrayContext = 'CheckedObserver:array';
    var checkedValueContext = 'CheckedObserver:value';

    var CheckedObserver = exports.CheckedObserver = (_dec8 = subscriberCollection(), _dec8(_class9 = function () {
      function CheckedObserver(element, handler, observerLocator) {

        this.element = element;
        this.handler = handler;
        this.observerLocator = observerLocator;
      }

      CheckedObserver.prototype.getValue = function getValue() {
        return this.value;
      };

      CheckedObserver.prototype.setValue = function setValue(newValue) {
        if (this.initialSync && this.value === newValue) {
          return;
        }

        if (this.arrayObserver) {
          this.arrayObserver.unsubscribe(checkedArrayContext, this);
          this.arrayObserver = null;
        }

        if (this.element.type === 'checkbox' && Array.isArray(newValue)) {
          this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
          this.arrayObserver.subscribe(checkedArrayContext, this);
        }

        this.oldValue = this.value;
        this.value = newValue;
        this.synchronizeElement();
        this.notify();

        if (!this.initialSync) {
          this.initialSync = true;
          this.observerLocator.taskQueue.queueMicroTask(this);
        }
      };

      CheckedObserver.prototype.call = function call(context, splices) {
        this.synchronizeElement();

        if (!this.valueObserver) {
          this.valueObserver = this.element.__observers__.model || this.element.__observers__.value;
          if (this.valueObserver) {
            this.valueObserver.subscribe(checkedValueContext, this);
          }
        }
      };

      CheckedObserver.prototype.synchronizeElement = function synchronizeElement() {
        var value = this.value;
        var element = this.element;
        var elementValue = element.hasOwnProperty('model') ? element.model : element.value;
        var isRadio = element.type === 'radio';
        var matcher = element.matcher || function (a, b) {
          return a === b;
        };

        element.checked = isRadio && !!matcher(value, elementValue) || !isRadio && value === true || !isRadio && Array.isArray(value) && value.findIndex(function (item) {
          return !!matcher(item, elementValue);
        }) !== -1;
      };

      CheckedObserver.prototype.synchronizeValue = function synchronizeValue() {
        var value = this.value;
        var element = this.element;
        var elementValue = element.hasOwnProperty('model') ? element.model : element.value;
        var index = void 0;
        var matcher = element.matcher || function (a, b) {
          return a === b;
        };

        if (element.type === 'checkbox') {
          if (Array.isArray(value)) {
            index = value.findIndex(function (item) {
              return !!matcher(item, elementValue);
            });
            if (element.checked && index === -1) {
              value.push(elementValue);
            } else if (!element.checked && index !== -1) {
              value.splice(index, 1);
            }

            return;
          }

          value = element.checked;
        } else if (element.checked) {
          value = elementValue;
        } else {
          return;
        }

        this.oldValue = this.value;
        this.value = value;
        this.notify();
      };

      CheckedObserver.prototype.notify = function notify() {
        var oldValue = this.oldValue;
        var newValue = this.value;

        if (newValue === oldValue) {
          return;
        }

        this.callSubscribers(newValue, oldValue);
      };

      CheckedObserver.prototype.subscribe = function subscribe(context, callable) {
        if (!this.hasSubscribers()) {
          this.disposeHandler = this.handler.subscribe(this.element, this.synchronizeValue.bind(this, false));
        }
        this.addSubscriber(context, callable);
      };

      CheckedObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
        if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
          this.disposeHandler();
          this.disposeHandler = null;
        }
      };

      CheckedObserver.prototype.unbind = function unbind() {
        if (this.arrayObserver) {
          this.arrayObserver.unsubscribe(checkedArrayContext, this);
          this.arrayObserver = null;
        }
        if (this.valueObserver) {
          this.valueObserver.unsubscribe(checkedValueContext, this);
        }
      };

      return CheckedObserver;
    }()) || _class9);

    var selectArrayContext = 'SelectValueObserver:array';

    var SelectValueObserver = exports.SelectValueObserver = (_dec9 = subscriberCollection(), _dec9(_class10 = function () {
      function SelectValueObserver(element, handler, observerLocator) {

        this.element = element;
        this.handler = handler;
        this.observerLocator = observerLocator;
      }

      SelectValueObserver.prototype.getValue = function getValue() {
        return this.value;
      };

      SelectValueObserver.prototype.setValue = function setValue(newValue) {
        if (newValue !== null && newValue !== undefined && this.element.multiple && !Array.isArray(newValue)) {
          throw new Error('Only null or Array instances can be bound to a multi-select.');
        }
        if (this.value === newValue) {
          return;
        }

        if (this.arrayObserver) {
          this.arrayObserver.unsubscribe(selectArrayContext, this);
          this.arrayObserver = null;
        }

        if (Array.isArray(newValue)) {
          this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
          this.arrayObserver.subscribe(selectArrayContext, this);
        }

        this.oldValue = this.value;
        this.value = newValue;
        this.synchronizeOptions();
        this.notify();

        if (!this.initialSync) {
          this.initialSync = true;
          this.observerLocator.taskQueue.queueMicroTask(this);
        }
      };

      SelectValueObserver.prototype.call = function call(context, splices) {
        this.synchronizeOptions();
      };

      SelectValueObserver.prototype.synchronizeOptions = function synchronizeOptions() {
        var value = this.value;
        var isArray = void 0;

        if (Array.isArray(value)) {
          isArray = true;
        }

        var options = this.element.options;
        var i = options.length;
        var matcher = this.element.matcher || function (a, b) {
          return a === b;
        };

        var _loop = function _loop() {
          var option = options.item(i);
          var optionValue = option.hasOwnProperty('model') ? option.model : option.value;
          if (isArray) {
            option.selected = value.findIndex(function (item) {
              return !!matcher(optionValue, item);
            }) !== -1;
            return 'continue';
          }
          option.selected = !!matcher(optionValue, value);
        };

        while (i--) {
          var _ret3 = _loop();

          if (_ret3 === 'continue') continue;
        }
      };

      SelectValueObserver.prototype.synchronizeValue = function synchronizeValue() {
        var _this24 = this;

        var options = this.element.options;
        var count = 0;
        var value = [];

        for (var _i23 = 0, ii = options.length; _i23 < ii; _i23++) {
          var _option = options.item(_i23);
          if (!_option.selected) {
            continue;
          }
          value.push(_option.hasOwnProperty('model') ? _option.model : _option.value);
          count++;
        }

        if (this.element.multiple) {
          if (Array.isArray(this.value)) {
            var _ret4 = function () {
              var matcher = _this24.element.matcher || function (a, b) {
                return a === b;
              };

              var i = 0;

              var _loop2 = function _loop2() {
                var a = _this24.value[i];
                if (value.findIndex(function (b) {
                  return matcher(a, b);
                }) === -1) {
                  _this24.value.splice(i, 1);
                } else {
                  i++;
                }
              };

              while (i < _this24.value.length) {
                _loop2();
              }

              i = 0;

              var _loop3 = function _loop3() {
                var a = value[i];
                if (_this24.value.findIndex(function (b) {
                  return matcher(a, b);
                }) === -1) {
                  _this24.value.push(a);
                }
                i++;
              };

              while (i < value.length) {
                _loop3();
              }
              return {
                v: void 0
              };
            }();

            if ((typeof _ret4 === 'undefined' ? 'undefined' : _typeof(_ret4)) === "object") return _ret4.v;
          }
        } else {
          if (count === 0) {
            value = null;
          } else {
            value = value[0];
          }
        }

        if (value !== this.value) {
          this.oldValue = this.value;
          this.value = value;
          this.notify();
        }
      };

      SelectValueObserver.prototype.notify = function notify() {
        var oldValue = this.oldValue;
        var newValue = this.value;

        this.callSubscribers(newValue, oldValue);
      };

      SelectValueObserver.prototype.subscribe = function subscribe(context, callable) {
        if (!this.hasSubscribers()) {
          this.disposeHandler = this.handler.subscribe(this.element, this.synchronizeValue.bind(this, false));
        }
        this.addSubscriber(context, callable);
      };

      SelectValueObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
        if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
          this.disposeHandler();
          this.disposeHandler = null;
        }
      };

      SelectValueObserver.prototype.bind = function bind() {
        var _this25 = this;

        this.domObserver = _aureliaPal.DOM.createMutationObserver(function () {
          _this25.synchronizeOptions();
          _this25.synchronizeValue();
        });
        this.domObserver.observe(this.element, { childList: true, subtree: true });
      };

      SelectValueObserver.prototype.unbind = function unbind() {
        this.domObserver.disconnect();
        this.domObserver = null;

        if (this.arrayObserver) {
          this.arrayObserver.unsubscribe(selectArrayContext, this);
          this.arrayObserver = null;
        }
      };

      return SelectValueObserver;
    }()) || _class10);

    var ClassObserver = exports.ClassObserver = function () {
      function ClassObserver(element) {

        this.element = element;
        this.doNotCache = true;
        this.value = '';
        this.version = 0;
      }

      ClassObserver.prototype.getValue = function getValue() {
        return this.value;
      };

      ClassObserver.prototype.setValue = function setValue(newValue) {
        var nameIndex = this.nameIndex || {};
        var version = this.version;
        var names = void 0;
        var name = void 0;

        if (newValue !== null && newValue !== undefined && newValue.length) {
          names = newValue.split(/\s+/);
          for (var _i24 = 0, length = names.length; _i24 < length; _i24++) {
            name = names[_i24];
            if (name === '') {
              continue;
            }
            nameIndex[name] = version;
            this.element.classList.add(name);
          }
        }

        this.value = newValue;
        this.nameIndex = nameIndex;
        this.version += 1;

        if (version === 0) {
          return;
        }

        version -= 1;
        for (name in nameIndex) {
          if (!nameIndex.hasOwnProperty(name) || nameIndex[name] !== version) {
            continue;
          }
          this.element.classList.remove(name);
        }
      };

      ClassObserver.prototype.subscribe = function subscribe() {
        throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "class" property is not supported.');
      };

      return ClassObserver;
    }();

    function hasDeclaredDependencies(descriptor) {
      return !!(descriptor && descriptor.get && descriptor.get.dependencies);
    }

    function declarePropertyDependencies(ctor, propertyName, dependencies) {
      var descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, propertyName);
      descriptor.get.dependencies = dependencies;
    }

    function computedFrom() {
      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      return function (target, key, descriptor) {
        descriptor.get.dependencies = rest;
        return descriptor;
      };
    }

    var ComputedExpression = exports.ComputedExpression = function (_Expression19) {
      _inherits(ComputedExpression, _Expression19);

      function ComputedExpression(name, dependencies) {

        var _this26 = _possibleConstructorReturn(this, _Expression19.call(this));

        _this26.name = name;
        _this26.dependencies = dependencies;
        _this26.isAssignable = true;
        return _this26;
      }

      ComputedExpression.prototype.evaluate = function evaluate(scope, lookupFunctions) {
        return scope.bindingContext[this.name];
      };

      ComputedExpression.prototype.assign = function assign(scope, value) {
        scope.bindingContext[this.name] = value;
      };

      ComputedExpression.prototype.accept = function accept(visitor) {
        throw new Error('not implemented');
      };

      ComputedExpression.prototype.connect = function connect(binding, scope) {
        var dependencies = this.dependencies;
        var i = dependencies.length;
        while (i--) {
          dependencies[i].connect(binding, scope);
        }
      };

      return ComputedExpression;
    }(Expression);

    function createComputedObserver(obj, propertyName, descriptor, observerLocator) {
      var dependencies = descriptor.get.dependencies;
      if (!(dependencies instanceof ComputedExpression)) {
        var _i25 = dependencies.length;
        while (_i25--) {
          dependencies[_i25] = observerLocator.parser.parse(dependencies[_i25]);
        }
        dependencies = descriptor.get.dependencies = new ComputedExpression(propertyName, dependencies);
      }

      var scope = { bindingContext: obj, overrideContext: createOverrideContext(obj) };
      return new ExpressionObserver(scope, dependencies, observerLocator);
    }

    var svgElements = void 0;
    var svgPresentationElements = void 0;
    var svgPresentationAttributes = void 0;
    var svgAnalyzer = void 0;

    if (typeof FEATURE_NO_SVG === 'undefined') {
      (function () {
        svgElements = {
          a: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'target', 'transform', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          altGlyph: ['class', 'dx', 'dy', 'externalResourcesRequired', 'format', 'glyphRef', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          altGlyphDef: ['id', 'xml:base', 'xml:lang', 'xml:space'],
          altGlyphItem: ['id', 'xml:base', 'xml:lang', 'xml:space'],
          animate: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          animateColor: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          animateMotion: ['accumulate', 'additive', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keyPoints', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'origin', 'path', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'rotate', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          animateTransform: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'type', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          circle: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'r', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
          clipPath: ['class', 'clipPathUnits', 'externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
          'color-profile': ['id', 'local', 'name', 'rendering-intent', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          cursor: ['externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          defs: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
          desc: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
          ellipse: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
          feBlend: ['class', 'height', 'id', 'in', 'in2', 'mode', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feColorMatrix: ['class', 'height', 'id', 'in', 'result', 'style', 'type', 'values', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feComponentTransfer: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feComposite: ['class', 'height', 'id', 'in', 'in2', 'k1', 'k2', 'k3', 'k4', 'operator', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feConvolveMatrix: ['bias', 'class', 'divisor', 'edgeMode', 'height', 'id', 'in', 'kernelMatrix', 'kernelUnitLength', 'order', 'preserveAlpha', 'result', 'style', 'targetX', 'targetY', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feDiffuseLighting: ['class', 'diffuseConstant', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feDisplacementMap: ['class', 'height', 'id', 'in', 'in2', 'result', 'scale', 'style', 'width', 'x', 'xChannelSelector', 'xml:base', 'xml:lang', 'xml:space', 'y', 'yChannelSelector'],
          feDistantLight: ['azimuth', 'elevation', 'id', 'xml:base', 'xml:lang', 'xml:space'],
          feFlood: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feFuncA: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
          feFuncB: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
          feFuncG: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
          feFuncR: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
          feGaussianBlur: ['class', 'height', 'id', 'in', 'result', 'stdDeviation', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feImage: ['class', 'externalResourcesRequired', 'height', 'id', 'preserveAspectRatio', 'result', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feMerge: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feMergeNode: ['id', 'xml:base', 'xml:lang', 'xml:space'],
          feMorphology: ['class', 'height', 'id', 'in', 'operator', 'radius', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feOffset: ['class', 'dx', 'dy', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          fePointLight: ['id', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
          feSpecularLighting: ['class', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'specularConstant', 'specularExponent', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feSpotLight: ['id', 'limitingConeAngle', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
          feTile: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          feTurbulence: ['baseFrequency', 'class', 'height', 'id', 'numOctaves', 'result', 'seed', 'stitchTiles', 'style', 'type', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          filter: ['class', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          font: ['class', 'externalResourcesRequired', 'horiz-adv-x', 'horiz-origin-x', 'horiz-origin-y', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
          'font-face': ['accent-height', 'alphabetic', 'ascent', 'bbox', 'cap-height', 'descent', 'font-family', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'hanging', 'id', 'ideographic', 'mathematical', 'overline-position', 'overline-thickness', 'panose-1', 'slope', 'stemh', 'stemv', 'strikethrough-position', 'strikethrough-thickness', 'underline-position', 'underline-thickness', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'widths', 'x-height', 'xml:base', 'xml:lang', 'xml:space'],
          'font-face-format': ['id', 'string', 'xml:base', 'xml:lang', 'xml:space'],
          'font-face-name': ['id', 'name', 'xml:base', 'xml:lang', 'xml:space'],
          'font-face-src': ['id', 'xml:base', 'xml:lang', 'xml:space'],
          'font-face-uri': ['id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          foreignObject: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          g: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
          glyph: ['arabic-form', 'class', 'd', 'glyph-name', 'horiz-adv-x', 'id', 'lang', 'orientation', 'style', 'unicode', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
          glyphRef: ['class', 'dx', 'dy', 'format', 'glyphRef', 'id', 'style', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          hkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space'],
          image: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          line: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
          linearGradient: ['class', 'externalResourcesRequired', 'gradientTransform', 'gradientUnits', 'id', 'spreadMethod', 'style', 'x1', 'x2', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
          marker: ['class', 'externalResourcesRequired', 'id', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
          mask: ['class', 'externalResourcesRequired', 'height', 'id', 'maskContentUnits', 'maskUnits', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          metadata: ['id', 'xml:base', 'xml:lang', 'xml:space'],
          'missing-glyph': ['class', 'd', 'horiz-adv-x', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
          mpath: ['externalResourcesRequired', 'id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          path: ['class', 'd', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'pathLength', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
          pattern: ['class', 'externalResourcesRequired', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          polygon: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
          polyline: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
          radialGradient: ['class', 'cx', 'cy', 'externalResourcesRequired', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'spreadMethod', 'style', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          rect: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          script: ['externalResourcesRequired', 'id', 'type', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          set: ['attributeName', 'attributeType', 'begin', 'dur', 'end', 'externalResourcesRequired', 'fill', 'id', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          stop: ['class', 'id', 'offset', 'style', 'xml:base', 'xml:lang', 'xml:space'],
          style: ['id', 'media', 'title', 'type', 'xml:base', 'xml:lang', 'xml:space'],
          svg: ['baseProfile', 'class', 'contentScriptType', 'contentStyleType', 'externalResourcesRequired', 'height', 'id', 'onabort', 'onactivate', 'onclick', 'onerror', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onresize', 'onscroll', 'onunload', 'onzoom', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'version', 'viewBox', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'zoomAndPan'],
          switch: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
          symbol: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
          text: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'transform', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          textPath: ['class', 'externalResourcesRequired', 'id', 'lengthAdjust', 'method', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'textLength', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
          title: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
          tref: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          tspan: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          use: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
          view: ['externalResourcesRequired', 'id', 'preserveAspectRatio', 'viewBox', 'viewTarget', 'xml:base', 'xml:lang', 'xml:space', 'zoomAndPan'],
          vkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']
        };

        svgPresentationElements = {
          'a': true,
          'altGlyph': true,
          'animate': true,
          'animateColor': true,
          'circle': true,
          'clipPath': true,
          'defs': true,
          'ellipse': true,
          'feBlend': true,
          'feColorMatrix': true,
          'feComponentTransfer': true,
          'feComposite': true,
          'feConvolveMatrix': true,
          'feDiffuseLighting': true,
          'feDisplacementMap': true,
          'feFlood': true,
          'feGaussianBlur': true,
          'feImage': true,
          'feMerge': true,
          'feMorphology': true,
          'feOffset': true,
          'feSpecularLighting': true,
          'feTile': true,
          'feTurbulence': true,
          'filter': true,
          'font': true,
          'foreignObject': true,
          'g': true,
          'glyph': true,
          'glyphRef': true,
          'image': true,
          'line': true,
          'linearGradient': true,
          'marker': true,
          'mask': true,
          'missing-glyph': true,
          'path': true,
          'pattern': true,
          'polygon': true,
          'polyline': true,
          'radialGradient': true,
          'rect': true,
          'stop': true,
          'svg': true,
          'switch': true,
          'symbol': true,
          'text': true,
          'textPath': true,
          'tref': true,
          'tspan': true,
          'use': true
        };

        svgPresentationAttributes = {
          'alignment-baseline': true,
          'baseline-shift': true,
          'clip-path': true,
          'clip-rule': true,
          'clip': true,
          'color-interpolation-filters': true,
          'color-interpolation': true,
          'color-profile': true,
          'color-rendering': true,
          'color': true,
          'cursor': true,
          'direction': true,
          'display': true,
          'dominant-baseline': true,
          'enable-background': true,
          'fill-opacity': true,
          'fill-rule': true,
          'fill': true,
          'filter': true,
          'flood-color': true,
          'flood-opacity': true,
          'font-family': true,
          'font-size-adjust': true,
          'font-size': true,
          'font-stretch': true,
          'font-style': true,
          'font-variant': true,
          'font-weight': true,
          'glyph-orientation-horizontal': true,
          'glyph-orientation-vertical': true,
          'image-rendering': true,
          'kerning': true,
          'letter-spacing': true,
          'lighting-color': true,
          'marker-end': true,
          'marker-mid': true,
          'marker-start': true,
          'mask': true,
          'opacity': true,
          'overflow': true,
          'pointer-events': true,
          'shape-rendering': true,
          'stop-color': true,
          'stop-opacity': true,
          'stroke-dasharray': true,
          'stroke-dashoffset': true,
          'stroke-linecap': true,
          'stroke-linejoin': true,
          'stroke-miterlimit': true,
          'stroke-opacity': true,
          'stroke-width': true,
          'stroke': true,
          'text-anchor': true,
          'text-decoration': true,
          'text-rendering': true,
          'unicode-bidi': true,
          'visibility': true,
          'word-spacing': true,
          'writing-mode': true
        };

        var createElement = function createElement(html) {
          var div = _aureliaPal.DOM.createElement('div');
          div.innerHTML = html;
          return div.firstChild;
        };

        svgAnalyzer = function () {
          function SVGAnalyzer() {

            if (createElement('<svg><altGlyph /></svg>').firstElementChild.nodeName === 'altglyph' && elements.altGlyph) {
              elements.altglyph = elements.altGlyph;
              delete elements.altGlyph;
              elements.altglyphdef = elements.altGlyphDef;
              delete elements.altGlyphDef;
              elements.altglyphitem = elements.altGlyphItem;
              delete elements.altGlyphItem;
              elements.glyphref = elements.glyphRef;
              delete elements.glyphRef;
            }
          }

          SVGAnalyzer.prototype.isStandardSvgAttribute = function isStandardSvgAttribute(nodeName, attributeName) {
            return presentationElements[nodeName] && presentationAttributes[attributeName] || elements[nodeName] && elements[nodeName].indexOf(attributeName) !== -1;
          };

          return SVGAnalyzer;
        }();
      })();
    }

    var elements = exports.elements = svgElements;
    var presentationElements = exports.presentationElements = svgPresentationElements;
    var presentationAttributes = exports.presentationAttributes = svgPresentationAttributes;
    var SVGAnalyzer = exports.SVGAnalyzer = svgAnalyzer || function () {
      function _class11() {}

      _class11.prototype.isStandardSvgAttribute = function isStandardSvgAttribute() {
        return false;
      };

      return _class11;
    }();

    var ObserverLocator = exports.ObserverLocator = (_temp = _class12 = function () {
      function ObserverLocator(taskQueue, eventManager, dirtyChecker, svgAnalyzer, parser) {

        this.taskQueue = taskQueue;
        this.eventManager = eventManager;
        this.dirtyChecker = dirtyChecker;
        this.svgAnalyzer = svgAnalyzer;
        this.parser = parser;
        this.adapters = [];
        this.logger = LogManager.getLogger('observer-locator');
      }

      ObserverLocator.prototype.getObserver = function getObserver(obj, propertyName) {
        var observersLookup = obj.__observers__;
        var observer = void 0;

        if (observersLookup && propertyName in observersLookup) {
          return observersLookup[propertyName];
        }

        observer = this.createPropertyObserver(obj, propertyName);

        if (!observer.doNotCache) {
          if (observersLookup === undefined) {
            observersLookup = this.getOrCreateObserversLookup(obj);
          }

          observersLookup[propertyName] = observer;
        }

        return observer;
      };

      ObserverLocator.prototype.getOrCreateObserversLookup = function getOrCreateObserversLookup(obj) {
        return obj.__observers__ || this.createObserversLookup(obj);
      };

      ObserverLocator.prototype.createObserversLookup = function createObserversLookup(obj) {
        var value = {};

        if (!Reflect.defineProperty(obj, '__observers__', {
          enumerable: false,
          configurable: false,
          writable: false,
          value: value
        })) {
          this.logger.warn('Cannot add observers to object', obj);
        }

        return value;
      };

      ObserverLocator.prototype.addAdapter = function addAdapter(adapter) {
        this.adapters.push(adapter);
      };

      ObserverLocator.prototype.getAdapterObserver = function getAdapterObserver(obj, propertyName, descriptor) {
        for (var _i26 = 0, ii = this.adapters.length; _i26 < ii; _i26++) {
          var adapter = this.adapters[_i26];
          var observer = adapter.getObserver(obj, propertyName, descriptor);
          if (observer) {
            return observer;
          }
        }
        return null;
      };

      ObserverLocator.prototype.createPropertyObserver = function createPropertyObserver(obj, propertyName) {
        var descriptor = void 0;
        var handler = void 0;
        var xlinkResult = void 0;

        if (!(obj instanceof Object)) {
          return new PrimitiveObserver(obj, propertyName);
        }

        if (obj instanceof _aureliaPal.DOM.Element) {
          if (propertyName === 'class') {
            return new ClassObserver(obj);
          }
          if (propertyName === 'style' || propertyName === 'css') {
            return new StyleObserver(obj, propertyName);
          }
          handler = this.eventManager.getElementHandler(obj, propertyName);
          if (propertyName === 'value' && obj.tagName.toLowerCase() === 'select') {
            return new SelectValueObserver(obj, handler, this);
          }
          if (propertyName === 'checked' && obj.tagName.toLowerCase() === 'input') {
            return new CheckedObserver(obj, handler, this);
          }
          if (handler) {
            return new ValueAttributeObserver(obj, propertyName, handler);
          }
          xlinkResult = /^xlink:(.+)$/.exec(propertyName);
          if (xlinkResult) {
            return new XLinkAttributeObserver(obj, propertyName, xlinkResult[1]);
          }
          if (propertyName === 'role' && (obj instanceof _aureliaPal.DOM.Element || obj instanceof _aureliaPal.DOM.SVGElement) || /^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName)) {
            return new DataAttributeObserver(obj, propertyName);
          }
        }

        descriptor = Object.getPropertyDescriptor(obj, propertyName);

        if (hasDeclaredDependencies(descriptor)) {
          return createComputedObserver(obj, propertyName, descriptor, this);
        }

        if (descriptor) {
          var existingGetterOrSetter = descriptor.get || descriptor.set;
          if (existingGetterOrSetter) {
            if (existingGetterOrSetter.getObserver) {
              return existingGetterOrSetter.getObserver(obj);
            }

            var adapterObserver = this.getAdapterObserver(obj, propertyName, descriptor);
            if (adapterObserver) {
              return adapterObserver;
            }
            return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
          }
        }

        if (obj instanceof Array) {
          if (propertyName === 'length') {
            return this.getArrayObserver(obj).getLengthObserver();
          }

          return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
        } else if (obj instanceof Map) {
          if (propertyName === 'size') {
            return this.getMapObserver(obj).getLengthObserver();
          }

          return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
        } else if (obj instanceof Set) {
          if (propertyName === 'size') {
            return this.getSetObserver(obj).getLengthObserver();
          }

          return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
        }

        return new SetterObserver(this.taskQueue, obj, propertyName);
      };

      ObserverLocator.prototype.getAccessor = function getAccessor(obj, propertyName) {
        if (obj instanceof _aureliaPal.DOM.Element) {
          if (propertyName === 'class' || propertyName === 'style' || propertyName === 'css' || propertyName === 'value' && (obj.tagName.toLowerCase() === 'input' || obj.tagName.toLowerCase() === 'select') || propertyName === 'checked' && obj.tagName.toLowerCase() === 'input' || propertyName === 'model' && obj.tagName.toLowerCase() === 'input' || /^xlink:.+$/.exec(propertyName)) {
            return this.getObserver(obj, propertyName);
          }
          if (/^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName)) {
            return dataAttributeAccessor;
          }
        }
        return propertyAccessor;
      };

      ObserverLocator.prototype.getArrayObserver = function getArrayObserver(array) {
        return _getArrayObserver(this.taskQueue, array);
      };

      ObserverLocator.prototype.getMapObserver = function getMapObserver(map) {
        return _getMapObserver(this.taskQueue, map);
      };

      ObserverLocator.prototype.getSetObserver = function getSetObserver(set) {
        return _getSetObserver(this.taskQueue, set);
      };

      return ObserverLocator;
    }(), _class12.inject = [_aureliaTaskQueue.TaskQueue, EventManager, DirtyChecker, SVGAnalyzer, Parser], _temp);

    var ObjectObservationAdapter = exports.ObjectObservationAdapter = function () {
      function ObjectObservationAdapter() {}

      ObjectObservationAdapter.prototype.getObserver = function getObserver(object, propertyName, descriptor) {
        throw new Error('BindingAdapters must implement getObserver(object, propertyName).');
      };

      return ObjectObservationAdapter;
    }();

    var BindingExpression = exports.BindingExpression = function () {
      function BindingExpression(observerLocator, targetProperty, sourceExpression, mode, lookupFunctions, attribute) {

        this.observerLocator = observerLocator;
        this.targetProperty = targetProperty;
        this.sourceExpression = sourceExpression;
        this.mode = mode;
        this.lookupFunctions = lookupFunctions;
        this.attribute = attribute;
        this.discrete = false;
      }

      BindingExpression.prototype.createBinding = function createBinding(target) {
        return new Binding(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.mode, this.lookupFunctions);
      };

      return BindingExpression;
    }();

    var targetContext = 'Binding:target';

    var Binding = exports.Binding = (_dec10 = connectable(), _dec10(_class13 = function () {
      function Binding(observerLocator, sourceExpression, target, targetProperty, mode, lookupFunctions) {

        this.observerLocator = observerLocator;
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.targetProperty = targetProperty;
        this.mode = mode;
        this.lookupFunctions = lookupFunctions;
      }

      Binding.prototype.updateTarget = function updateTarget(value) {
        this.targetObserver.setValue(value, this.target, this.targetProperty);
      };

      Binding.prototype.updateSource = function updateSource(value) {
        this.sourceExpression.assign(this.source, value, this.lookupFunctions);
      };

      Binding.prototype.call = function call(context, newValue, oldValue) {
        if (!this.isBound) {
          return;
        }
        if (context === sourceContext) {
          oldValue = this.targetObserver.getValue(this.target, this.targetProperty);
          newValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
          if (newValue !== oldValue) {
            this.updateTarget(newValue);
          }
          if (this.mode !== bindingMode.oneTime) {
            this._version++;
            this.sourceExpression.connect(this, this.source);
            this.unobserve(false);
          }
          return;
        }
        if (context === targetContext) {
          if (newValue !== this.sourceExpression.evaluate(this.source, this.lookupFunctions)) {
            this.updateSource(newValue);
          }
          return;
        }
        throw new Error('Unexpected call context ' + context);
      };

      Binding.prototype.bind = function bind(source) {
        if (this.isBound) {
          if (this.source === source) {
            return;
          }
          this.unbind();
        }
        this.isBound = true;
        this.source = source;

        if (this.sourceExpression.bind) {
          this.sourceExpression.bind(this, source, this.lookupFunctions);
        }

        var mode = this.mode;
        if (!this.targetObserver) {
          var method = mode === bindingMode.twoWay ? 'getObserver' : 'getAccessor';
          this.targetObserver = this.observerLocator[method](this.target, this.targetProperty);
        }

        if ('bind' in this.targetObserver) {
          this.targetObserver.bind();
        }
        var value = this.sourceExpression.evaluate(source, this.lookupFunctions);
        this.updateTarget(value);

        if (mode === bindingMode.oneWay) {
          enqueueBindingConnect(this);
        } else if (mode === bindingMode.twoWay) {
          this.sourceExpression.connect(this, source);
          this.targetObserver.subscribe(targetContext, this);
        }
      };

      Binding.prototype.unbind = function unbind() {
        if (!this.isBound) {
          return;
        }
        this.isBound = false;
        if (this.sourceExpression.unbind) {
          this.sourceExpression.unbind(this, this.source);
        }
        this.source = null;
        if ('unbind' in this.targetObserver) {
          this.targetObserver.unbind();
        }
        if (this.targetObserver.unsubscribe) {
          this.targetObserver.unsubscribe(targetContext, this);
        }
        this.unobserve(true);
      };

      Binding.prototype.connect = function connect(evaluate) {
        if (!this.isBound) {
          return;
        }
        if (evaluate) {
          var value = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
          this.updateTarget(value);
        }
        this.sourceExpression.connect(this, this.source);
      };

      return Binding;
    }()) || _class13);

    var CallExpression = exports.CallExpression = function () {
      function CallExpression(observerLocator, targetProperty, sourceExpression, lookupFunctions) {

        this.observerLocator = observerLocator;
        this.targetProperty = targetProperty;
        this.sourceExpression = sourceExpression;
        this.lookupFunctions = lookupFunctions;
      }

      CallExpression.prototype.createBinding = function createBinding(target) {
        return new Call(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.lookupFunctions);
      };

      return CallExpression;
    }();

    var Call = exports.Call = function () {
      function Call(observerLocator, sourceExpression, target, targetProperty, lookupFunctions) {

        this.sourceExpression = sourceExpression;
        this.target = target;
        this.targetProperty = observerLocator.getObserver(target, targetProperty);
        this.lookupFunctions = lookupFunctions;
      }

      Call.prototype.callSource = function callSource($event) {
        var overrideContext = this.source.overrideContext;
        Object.assign(overrideContext, $event);
        overrideContext.$event = $event;
        var mustEvaluate = true;
        var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
        delete overrideContext.$event;
        for (var prop in $event) {
          delete overrideContext[prop];
        }
        return result;
      };

      Call.prototype.bind = function bind(source) {
        var _this27 = this;

        if (this.isBound) {
          if (this.source === source) {
            return;
          }
          this.unbind();
        }
        this.isBound = true;
        this.source = source;

        if (this.sourceExpression.bind) {
          this.sourceExpression.bind(this, source, this.lookupFunctions);
        }
        this.targetProperty.setValue(function ($event) {
          return _this27.callSource($event);
        });
      };

      Call.prototype.unbind = function unbind() {
        if (!this.isBound) {
          return;
        }
        this.isBound = false;
        if (this.sourceExpression.unbind) {
          this.sourceExpression.unbind(this, this.source);
        }
        this.source = null;
        this.targetProperty.setValue(null);
      };

      return Call;
    }();

    var ValueConverterResource = exports.ValueConverterResource = function () {
      function ValueConverterResource(name) {

        this.name = name;
      }

      ValueConverterResource.convention = function convention(name) {
        if (name.endsWith('ValueConverter')) {
          return new ValueConverterResource(camelCase(name.substring(0, name.length - 14)));
        }
      };

      ValueConverterResource.prototype.initialize = function initialize(container, target) {
        this.instance = container.get(target);
      };

      ValueConverterResource.prototype.register = function register(registry, name) {
        registry.registerValueConverter(name || this.name, this.instance);
      };

      ValueConverterResource.prototype.load = function load(container, target) {};

      return ValueConverterResource;
    }();

    function valueConverter(nameOrTarget) {
      if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
        return function (target) {
          _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(nameOrTarget), target);
        };
      }

      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(), nameOrTarget);
    }

    var BindingBehaviorResource = exports.BindingBehaviorResource = function () {
      function BindingBehaviorResource(name) {

        this.name = name;
      }

      BindingBehaviorResource.convention = function convention(name) {
        if (name.endsWith('BindingBehavior')) {
          return new BindingBehaviorResource(camelCase(name.substring(0, name.length - 15)));
        }
      };

      BindingBehaviorResource.prototype.initialize = function initialize(container, target) {
        this.instance = container.get(target);
      };

      BindingBehaviorResource.prototype.register = function register(registry, name) {
        registry.registerBindingBehavior(name || this.name, this.instance);
      };

      BindingBehaviorResource.prototype.load = function load(container, target) {};

      return BindingBehaviorResource;
    }();

    function bindingBehavior(nameOrTarget) {
      if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
        return function (target) {
          _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(nameOrTarget), target);
        };
      }

      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(), nameOrTarget);
    }

    var ListenerExpression = exports.ListenerExpression = function () {
      function ListenerExpression(eventManager, targetEvent, sourceExpression, delegationStrategy, preventDefault, lookupFunctions) {

        this.eventManager = eventManager;
        this.targetEvent = targetEvent;
        this.sourceExpression = sourceExpression;
        this.delegationStrategy = delegationStrategy;
        this.discrete = true;
        this.preventDefault = preventDefault;
        this.lookupFunctions = lookupFunctions;
      }

      ListenerExpression.prototype.createBinding = function createBinding(target) {
        return new Listener(this.eventManager, this.targetEvent, this.delegationStrategy, this.sourceExpression, target, this.preventDefault, this.lookupFunctions);
      };

      return ListenerExpression;
    }();

    var Listener = exports.Listener = function () {
      function Listener(eventManager, targetEvent, delegationStrategy, sourceExpression, target, preventDefault, lookupFunctions) {

        this.eventManager = eventManager;
        this.targetEvent = targetEvent;
        this.delegationStrategy = delegationStrategy;
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.preventDefault = preventDefault;
        this.lookupFunctions = lookupFunctions;
      }

      Listener.prototype.callSource = function callSource(event) {
        var overrideContext = this.source.overrideContext;
        overrideContext.$event = event;
        var mustEvaluate = true;
        var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
        delete overrideContext.$event;
        if (result !== true && this.preventDefault) {
          event.preventDefault();
        }
        return result;
      };

      Listener.prototype.bind = function bind(source) {
        var _this28 = this;

        if (this.isBound) {
          if (this.source === source) {
            return;
          }
          this.unbind();
        }
        this.isBound = true;
        this.source = source;

        if (this.sourceExpression.bind) {
          this.sourceExpression.bind(this, source, this.lookupFunctions);
        }
        this._disposeListener = this.eventManager.addEventListener(this.target, this.targetEvent, function (event) {
          return _this28.callSource(event);
        }, this.delegationStrategy);
      };

      Listener.prototype.unbind = function unbind() {
        if (!this.isBound) {
          return;
        }
        this.isBound = false;
        if (this.sourceExpression.unbind) {
          this.sourceExpression.unbind(this, this.source);
        }
        this.source = null;
        this._disposeListener();
        this._disposeListener = null;
      };

      return Listener;
    }();

    function getAU(element) {
      var au = element.au;

      if (au === undefined) {
        throw new Error('No Aurelia APIs are defined for the element: "' + element.tagName + '".');
      }

      return au;
    }

    var NameExpression = exports.NameExpression = function () {
      function NameExpression(sourceExpression, apiName, lookupFunctions) {

        this.sourceExpression = sourceExpression;
        this.apiName = apiName;
        this.lookupFunctions = lookupFunctions;
        this.discrete = true;
      }

      NameExpression.prototype.createBinding = function createBinding(target) {
        return new NameBinder(this.sourceExpression, NameExpression.locateAPI(target, this.apiName), this.lookupFunctions);
      };

      NameExpression.locateAPI = function locateAPI(element, apiName) {
        switch (apiName) {
          case 'element':
            return element;
          case 'controller':
            return getAU(element).controller;
          case 'view-model':
            return getAU(element).controller.viewModel;
          case 'view':
            return getAU(element).controller.view;
          default:
            var target = getAU(element)[apiName];

            if (target === undefined) {
              throw new Error('Attempted to reference "' + apiName + '", but it was not found amongst the target\'s API.');
            }

            return target.viewModel;
        }
      };

      return NameExpression;
    }();

    var NameBinder = function () {
      function NameBinder(sourceExpression, target, lookupFunctions) {

        this.sourceExpression = sourceExpression;
        this.target = target;
        this.lookupFunctions = lookupFunctions;
      }

      NameBinder.prototype.bind = function bind(source) {
        if (this.isBound) {
          if (this.source === source) {
            return;
          }
          this.unbind();
        }
        this.isBound = true;
        this.source = source;
        if (this.sourceExpression.bind) {
          this.sourceExpression.bind(this, source, this.lookupFunctions);
        }
        this.sourceExpression.assign(this.source, this.target, this.lookupFunctions);
      };

      NameBinder.prototype.unbind = function unbind() {
        if (!this.isBound) {
          return;
        }
        this.isBound = false;
        if (this.sourceExpression.evaluate(this.source, this.lookupFunctions) === this.target) {
          this.sourceExpression.assign(this.source, null, this.lookupFunctions);
        }
        if (this.sourceExpression.unbind) {
          this.sourceExpression.unbind(this, this.source);
        }
        this.source = null;
      };

      return NameBinder;
    }();

    var LookupFunctions = {
      bindingBehaviors: function bindingBehaviors(name) {
        return null;
      },
      valueConverters: function valueConverters(name) {
        return null;
      }
    };

    var BindingEngine = exports.BindingEngine = (_temp2 = _class14 = function () {
      function BindingEngine(observerLocator, parser) {

        this.observerLocator = observerLocator;
        this.parser = parser;
      }

      BindingEngine.prototype.createBindingExpression = function createBindingExpression(targetProperty, sourceExpression) {
        var mode = arguments.length <= 2 || arguments[2] === undefined ? bindingMode.oneWay : arguments[2];
        var lookupFunctions = arguments.length <= 3 || arguments[3] === undefined ? LookupFunctions : arguments[3];

        return new BindingExpression(this.observerLocator, targetProperty, this.parser.parse(sourceExpression), mode, lookupFunctions);
      };

      BindingEngine.prototype.propertyObserver = function propertyObserver(obj, propertyName) {
        var _this29 = this;

        return {
          subscribe: function subscribe(callback) {
            var observer = _this29.observerLocator.getObserver(obj, propertyName);
            observer.subscribe(callback);
            return {
              dispose: function dispose() {
                return observer.unsubscribe(callback);
              }
            };
          }
        };
      };

      BindingEngine.prototype.collectionObserver = function collectionObserver(collection) {
        var _this30 = this;

        return {
          subscribe: function subscribe(callback) {
            var observer = void 0;
            if (collection instanceof Array) {
              observer = _this30.observerLocator.getArrayObserver(collection);
            } else if (collection instanceof Map) {
              observer = _this30.observerLocator.getMapObserver(collection);
            } else if (collection instanceof Set) {
              observer = _this30.observerLocator.getSetObserver(collection);
            } else {
              throw new Error('collection must be an instance of Array, Map or Set.');
            }
            observer.subscribe(callback);
            return {
              dispose: function dispose() {
                return observer.unsubscribe(callback);
              }
            };
          }
        };
      };

      BindingEngine.prototype.expressionObserver = function expressionObserver(bindingContext, expression) {
        var scope = { bindingContext: bindingContext, overrideContext: createOverrideContext(bindingContext) };
        return new ExpressionObserver(scope, this.parser.parse(expression), this.observerLocator, LookupFunctions);
      };

      BindingEngine.prototype.parseExpression = function parseExpression(expression) {
        return this.parser.parse(expression);
      };

      BindingEngine.prototype.registerAdapter = function registerAdapter(adapter) {
        this.observerLocator.addAdapter(adapter);
      };

      return BindingEngine;
    }(), _class14.inject = [ObserverLocator, Parser], _temp2);

    var setProto = Set.prototype;

    function _getSetObserver(taskQueue, set) {
      return ModifySetObserver.for(taskQueue, set);
    }

    exports.getSetObserver = _getSetObserver;

    var ModifySetObserver = function (_ModifyCollectionObse3) {
      _inherits(ModifySetObserver, _ModifyCollectionObse3);

      function ModifySetObserver(taskQueue, set) {

        return _possibleConstructorReturn(this, _ModifyCollectionObse3.call(this, taskQueue, set));
      }

      ModifySetObserver.for = function _for(taskQueue, set) {
        if (!('__set_observer__' in set)) {
          Reflect.defineProperty(set, '__set_observer__', {
            value: ModifySetObserver.create(taskQueue, set),
            enumerable: false, configurable: false
          });
        }
        return set.__set_observer__;
      };

      ModifySetObserver.create = function create(taskQueue, set) {
        var observer = new ModifySetObserver(taskQueue, set);

        var proto = setProto;
        if (proto.add !== set.add || proto.delete !== set.delete || proto.clear !== set.clear) {
          proto = {
            add: set.add,
            delete: set.delete,
            clear: set.clear
          };
        }

        set.add = function () {
          var type = 'add';
          var oldSize = set.size;
          var methodCallResult = proto.add.apply(set, arguments);
          var hasValue = set.size === oldSize;
          if (!hasValue) {
            observer.addChangeRecord({
              type: type,
              object: set,
              value: Array.from(set).pop()
            });
          }
          return methodCallResult;
        };

        set.delete = function () {
          var hasValue = set.has(arguments[0]);
          var methodCallResult = proto.delete.apply(set, arguments);
          if (hasValue) {
            observer.addChangeRecord({
              type: 'delete',
              object: set,
              value: arguments[0]
            });
          }
          return methodCallResult;
        };

        set.clear = function () {
          var methodCallResult = proto.clear.apply(set, arguments);
          observer.addChangeRecord({
            type: 'clear',
            object: set
          });
          return methodCallResult;
        };

        return observer;
      };

      return ModifySetObserver;
    }(ModifyCollectionObserver);

    function observable(targetOrConfig, key, descriptor) {
      function deco(target, key, descriptor, config) {
        var isClassDecorator = key === undefined;
        if (isClassDecorator) {
          target = target.prototype;
          key = typeof config === 'string' ? config : config.name;
        }

        var innerPropertyName = '_' + key;
        var innerPropertyDescriptor = {
          configurable: true,
          enumerable: false,
          writable: true
        };

        var callbackName = config && config.changeHandler || key + 'Changed';

        if (descriptor) {
          if (typeof descriptor.initializer === 'function') {
            innerPropertyDescriptor.value = descriptor.initializer();
          }
        } else {
          descriptor = {};
        }

        if (!('enumerable' in descriptor)) {
          descriptor.enumerable = true;
        }

        delete descriptor.value;
        delete descriptor.writable;
        delete descriptor.initializer;

        Reflect.defineProperty(target, innerPropertyName, innerPropertyDescriptor);

        descriptor.get = function () {
          return this[innerPropertyName];
        };
        descriptor.set = function (newValue) {
          var oldValue = this[innerPropertyName];
          if (newValue === oldValue) {
            return;
          }

          this[innerPropertyName] = newValue;
          Reflect.defineProperty(this, innerPropertyName, { enumerable: false });

          if (this[callbackName]) {
            this[callbackName](newValue, oldValue, key);
          }
        };

        descriptor.get.dependencies = [innerPropertyName];

        if (isClassDecorator) {
          Reflect.defineProperty(target, key, descriptor);
        } else {
          return descriptor;
        }
      }

      if (key === undefined) {
        return function (t, k, d) {
          return deco(t, k, d, targetOrConfig);
        };
      }
      return deco(targetOrConfig, key, descriptor);
    }
  }).call($__exports, $__exports, $__require('aurelia-logging'), $__require('aurelia-pal'), $__require('aurelia-task-queue'), $__require('aurelia-metadata'));
});
System.registerDynamic("npm:aurelia-templating@1.4.2.json", [], true, function() {
  return {
    "main": "aurelia-templating",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-templating@1.4.2/aurelia-templating.js', ['aurelia-logging', 'aurelia-metadata', 'aurelia-pal', 'aurelia-path', 'aurelia-loader', 'aurelia-dependency-injection', 'aurelia-binding', 'aurelia-task-queue'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaLogging, _aureliaMetadata, _aureliaPal, _aureliaPath, _aureliaLoader, _aureliaDependencyInjection, _aureliaBinding, _aureliaTaskQueue) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TemplatingEngine = exports.ElementConfigResource = exports.CompositionEngine = exports.SwapStrategies = exports.HtmlBehaviorResource = exports.BindableProperty = exports.BehaviorPropertyObserver = exports.Controller = exports.ViewEngine = exports.ModuleAnalyzer = exports.ResourceDescription = exports.ResourceModule = exports.ViewCompiler = exports.ViewFactory = exports.BoundViewFactory = exports.ViewSlot = exports.View = exports.ViewResources = exports.ShadowDOM = exports.ShadowSlot = exports.PassThroughSlot = exports.SlotCustomAttribute = exports.BindingLanguage = exports.ViewLocator = exports.InlineViewStrategy = exports.TemplateRegistryViewStrategy = exports.NoViewStrategy = exports.ConventionalViewStrategy = exports.RelativeViewStrategy = exports.viewStrategy = exports.TargetInstruction = exports.BehaviorInstruction = exports.ViewCompileInstruction = exports.ResourceLoadContext = exports.ElementEvents = exports.ViewEngineHooksResource = exports.CompositionTransaction = exports.CompositionTransactionOwnershipToken = exports.CompositionTransactionNotifier = exports.Animator = exports.animationEvent = undefined;
    exports._hyphenate = _hyphenate;
    exports._isAllWhitespace = _isAllWhitespace;
    exports.viewEngineHooks = viewEngineHooks;
    exports.children = children;
    exports.child = child;
    exports.resource = resource;
    exports.behavior = behavior;
    exports.customElement = customElement;
    exports.customAttribute = customAttribute;
    exports.templateController = templateController;
    exports.bindable = bindable;
    exports.dynamicOptions = dynamicOptions;
    exports.useShadowDOM = useShadowDOM;
    exports.processAttributes = processAttributes;
    exports.processContent = processContent;
    exports.containerless = containerless;
    exports.useViewStrategy = useViewStrategy;
    exports.useView = useView;
    exports.inlineView = inlineView;
    exports.noView = noView;
    exports.elementConfig = elementConfig;
    exports.viewResources = viewResources;

    var LogManager = _interopRequireWildcard(_aureliaLogging);

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};

        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }

        newObj.default = obj;
        return newObj;
      }
    }

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var _class, _temp, _dec, _class2, _dec2, _class3, _dec3, _class4, _dec4, _class5, _dec5, _class6, _class7, _temp2, _dec6, _class8, _class9, _temp3, _class11, _dec7, _class13, _dec8, _class14, _class15, _temp4, _dec9, _class16, _dec10, _class17, _dec11, _class18;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var animationEvent = exports.animationEvent = {
      enterBegin: 'animation:enter:begin',
      enterActive: 'animation:enter:active',
      enterDone: 'animation:enter:done',
      enterTimeout: 'animation:enter:timeout',

      leaveBegin: 'animation:leave:begin',
      leaveActive: 'animation:leave:active',
      leaveDone: 'animation:leave:done',
      leaveTimeout: 'animation:leave:timeout',

      staggerNext: 'animation:stagger:next',

      removeClassBegin: 'animation:remove-class:begin',
      removeClassActive: 'animation:remove-class:active',
      removeClassDone: 'animation:remove-class:done',
      removeClassTimeout: 'animation:remove-class:timeout',

      addClassBegin: 'animation:add-class:begin',
      addClassActive: 'animation:add-class:active',
      addClassDone: 'animation:add-class:done',
      addClassTimeout: 'animation:add-class:timeout',

      animateBegin: 'animation:animate:begin',
      animateActive: 'animation:animate:active',
      animateDone: 'animation:animate:done',
      animateTimeout: 'animation:animate:timeout',

      sequenceBegin: 'animation:sequence:begin',
      sequenceDone: 'animation:sequence:done'
    };

    var Animator = exports.Animator = function () {
      function Animator() {}

      Animator.prototype.enter = function enter(element) {
        return Promise.resolve(false);
      };

      Animator.prototype.leave = function leave(element) {
        return Promise.resolve(false);
      };

      Animator.prototype.removeClass = function removeClass(element, className) {
        element.classList.remove(className);
        return Promise.resolve(false);
      };

      Animator.prototype.addClass = function addClass(element, className) {
        element.classList.add(className);
        return Promise.resolve(false);
      };

      Animator.prototype.animate = function animate(element, className) {
        return Promise.resolve(false);
      };

      Animator.prototype.runSequence = function runSequence(animations) {};

      Animator.prototype.registerEffect = function registerEffect(effectName, properties) {};

      Animator.prototype.unregisterEffect = function unregisterEffect(effectName) {};

      return Animator;
    }();

    var CompositionTransactionNotifier = exports.CompositionTransactionNotifier = function () {
      function CompositionTransactionNotifier(owner) {

        this.owner = owner;
        this.owner._compositionCount++;
      }

      CompositionTransactionNotifier.prototype.done = function done() {
        this.owner._compositionCount--;
        this.owner._tryCompleteTransaction();
      };

      return CompositionTransactionNotifier;
    }();

    var CompositionTransactionOwnershipToken = exports.CompositionTransactionOwnershipToken = function () {
      function CompositionTransactionOwnershipToken(owner) {

        this.owner = owner;
        this.owner._ownershipToken = this;
        this.thenable = this._createThenable();
      }

      CompositionTransactionOwnershipToken.prototype.waitForCompositionComplete = function waitForCompositionComplete() {
        this.owner._tryCompleteTransaction();
        return this.thenable;
      };

      CompositionTransactionOwnershipToken.prototype.resolve = function resolve() {
        this._resolveCallback();
      };

      CompositionTransactionOwnershipToken.prototype._createThenable = function _createThenable() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          _this._resolveCallback = resolve;
        });
      };

      return CompositionTransactionOwnershipToken;
    }();

    var CompositionTransaction = exports.CompositionTransaction = function () {
      function CompositionTransaction() {

        this._ownershipToken = null;
        this._compositionCount = 0;
      }

      CompositionTransaction.prototype.tryCapture = function tryCapture() {
        return this._ownershipToken === null ? new CompositionTransactionOwnershipToken(this) : null;
      };

      CompositionTransaction.prototype.enlist = function enlist() {
        return new CompositionTransactionNotifier(this);
      };

      CompositionTransaction.prototype._tryCompleteTransaction = function _tryCompleteTransaction() {
        if (this._compositionCount <= 0) {
          this._compositionCount = 0;

          if (this._ownershipToken !== null) {
            var token = this._ownershipToken;
            this._ownershipToken = null;
            token.resolve();
          }
        }
      };

      return CompositionTransaction;
    }();

    var capitalMatcher = /([A-Z])/g;

    function addHyphenAndLower(char) {
      return '-' + char.toLowerCase();
    }

    function _hyphenate(name) {
      return (name.charAt(0).toLowerCase() + name.slice(1)).replace(capitalMatcher, addHyphenAndLower);
    }

    function _isAllWhitespace(node) {
      return !(node.auInterpolationTarget || /[^\t\n\r ]/.test(node.textContent));
    }

    var ViewEngineHooksResource = exports.ViewEngineHooksResource = function () {
      function ViewEngineHooksResource() {}

      ViewEngineHooksResource.prototype.initialize = function initialize(container, target) {
        this.instance = container.get(target);
      };

      ViewEngineHooksResource.prototype.register = function register(registry, name) {
        registry.registerViewEngineHooks(this.instance);
      };

      ViewEngineHooksResource.prototype.load = function load(container, target) {};

      ViewEngineHooksResource.convention = function convention(name) {
        if (name.endsWith('ViewEngineHooks')) {
          return new ViewEngineHooksResource();
        }
      };

      return ViewEngineHooksResource;
    }();

    function viewEngineHooks(target) {
      var deco = function deco(t) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ViewEngineHooksResource(), t);
      };

      return target ? deco(target) : deco;
    }

    var ElementEvents = exports.ElementEvents = function () {
      function ElementEvents(element) {

        this.element = element;
        this.subscriptions = {};
      }

      ElementEvents.prototype._enqueueHandler = function _enqueueHandler(handler) {
        this.subscriptions[handler.eventName] = this.subscriptions[handler.eventName] || [];
        this.subscriptions[handler.eventName].push(handler);
      };

      ElementEvents.prototype._dequeueHandler = function _dequeueHandler(handler) {
        var index = void 0;
        var subscriptions = this.subscriptions[handler.eventName];
        if (subscriptions) {
          index = subscriptions.indexOf(handler);
          if (index > -1) {
            subscriptions.splice(index, 1);
          }
        }
        return handler;
      };

      ElementEvents.prototype.publish = function publish(eventName) {
        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var cancelable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        var event = _aureliaPal.DOM.createCustomEvent(eventName, { cancelable: cancelable, bubbles: bubbles, detail: detail });
        this.element.dispatchEvent(event);
      };

      ElementEvents.prototype.subscribe = function subscribe(eventName, handler) {
        var _this2 = this;

        var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (handler && typeof handler === 'function') {
          handler.eventName = eventName;
          handler.handler = handler;
          handler.bubbles = bubbles;
          handler.dispose = function () {
            _this2.element.removeEventListener(eventName, handler, bubbles);
            _this2._dequeueHandler(handler);
          };
          this.element.addEventListener(eventName, handler, bubbles);
          this._enqueueHandler(handler);
          return handler;
        }

        return undefined;
      };

      ElementEvents.prototype.subscribeOnce = function subscribeOnce(eventName, handler) {
        var _this3 = this;

        var bubbles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (handler && typeof handler === 'function') {
          var _ret = function () {
            var _handler = function _handler(event) {
              handler(event);
              _handler.dispose();
            };
            return {
              v: _this3.subscribe(eventName, _handler, bubbles)
            };
          }();

          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
        }

        return undefined;
      };

      ElementEvents.prototype.dispose = function dispose(eventName) {
        if (eventName && typeof eventName === 'string') {
          var subscriptions = this.subscriptions[eventName];
          if (subscriptions) {
            while (subscriptions.length) {
              var subscription = subscriptions.pop();
              if (subscription) {
                subscription.dispose();
              }
            }
          }
        } else {
          this.disposeAll();
        }
      };

      ElementEvents.prototype.disposeAll = function disposeAll() {
        for (var key in this.subscriptions) {
          this.dispose(key);
        }
      };

      return ElementEvents;
    }();

    var ResourceLoadContext = exports.ResourceLoadContext = function () {
      function ResourceLoadContext() {

        this.dependencies = {};
      }

      ResourceLoadContext.prototype.addDependency = function addDependency(url) {
        this.dependencies[url] = true;
      };

      ResourceLoadContext.prototype.hasDependency = function hasDependency(url) {
        return url in this.dependencies;
      };

      return ResourceLoadContext;
    }();

    var ViewCompileInstruction = exports.ViewCompileInstruction = function ViewCompileInstruction() {
      var targetShadowDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var compileSurrogate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this.targetShadowDOM = targetShadowDOM;
      this.compileSurrogate = compileSurrogate;
      this.associatedModuleId = null;
    };

    ViewCompileInstruction.normal = new ViewCompileInstruction();

    var BehaviorInstruction = exports.BehaviorInstruction = function () {
      BehaviorInstruction.enhance = function enhance() {
        var instruction = new BehaviorInstruction();
        instruction.enhance = true;
        return instruction;
      };

      BehaviorInstruction.unitTest = function unitTest(type, attributes) {
        var instruction = new BehaviorInstruction();
        instruction.type = type;
        instruction.attributes = attributes || {};
        return instruction;
      };

      BehaviorInstruction.element = function element(node, type) {
        var instruction = new BehaviorInstruction();
        instruction.type = type;
        instruction.attributes = {};
        instruction.anchorIsContainer = !(node.hasAttribute('containerless') || type.containerless);
        instruction.initiatedByBehavior = true;
        return instruction;
      };

      BehaviorInstruction.attribute = function attribute(attrName, type) {
        var instruction = new BehaviorInstruction();
        instruction.attrName = attrName;
        instruction.type = type || null;
        instruction.attributes = {};
        return instruction;
      };

      BehaviorInstruction.dynamic = function dynamic(host, viewModel, viewFactory) {
        var instruction = new BehaviorInstruction();
        instruction.host = host;
        instruction.viewModel = viewModel;
        instruction.viewFactory = viewFactory;
        instruction.inheritBindingContext = true;
        return instruction;
      };

      function BehaviorInstruction() {

        this.initiatedByBehavior = false;
        this.enhance = false;
        this.partReplacements = null;
        this.viewFactory = null;
        this.originalAttrName = null;
        this.skipContentProcessing = false;
        this.contentFactory = null;
        this.viewModel = null;
        this.anchorIsContainer = false;
        this.host = null;
        this.attributes = null;
        this.type = null;
        this.attrName = null;
        this.inheritBindingContext = false;
      }

      return BehaviorInstruction;
    }();

    BehaviorInstruction.normal = new BehaviorInstruction();

    var TargetInstruction = exports.TargetInstruction = (_temp = _class = function () {
      TargetInstruction.shadowSlot = function shadowSlot(parentInjectorId) {
        var instruction = new TargetInstruction();
        instruction.parentInjectorId = parentInjectorId;
        instruction.shadowSlot = true;
        return instruction;
      };

      TargetInstruction.contentExpression = function contentExpression(expression) {
        var instruction = new TargetInstruction();
        instruction.contentExpression = expression;
        return instruction;
      };

      TargetInstruction.lifting = function lifting(parentInjectorId, liftingInstruction) {
        var instruction = new TargetInstruction();
        instruction.parentInjectorId = parentInjectorId;
        instruction.expressions = TargetInstruction.noExpressions;
        instruction.behaviorInstructions = [liftingInstruction];
        instruction.viewFactory = liftingInstruction.viewFactory;
        instruction.providers = [liftingInstruction.type.target];
        instruction.lifting = true;
        return instruction;
      };

      TargetInstruction.normal = function normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction) {
        var instruction = new TargetInstruction();
        instruction.injectorId = injectorId;
        instruction.parentInjectorId = parentInjectorId;
        instruction.providers = providers;
        instruction.behaviorInstructions = behaviorInstructions;
        instruction.expressions = expressions;
        instruction.anchorIsContainer = elementInstruction ? elementInstruction.anchorIsContainer : true;
        instruction.elementInstruction = elementInstruction;
        return instruction;
      };

      TargetInstruction.surrogate = function surrogate(providers, behaviorInstructions, expressions, values) {
        var instruction = new TargetInstruction();
        instruction.expressions = expressions;
        instruction.behaviorInstructions = behaviorInstructions;
        instruction.providers = providers;
        instruction.values = values;
        return instruction;
      };

      function TargetInstruction() {

        this.injectorId = null;
        this.parentInjectorId = null;

        this.shadowSlot = false;
        this.slotName = null;
        this.slotFallbackFactory = null;

        this.contentExpression = null;

        this.expressions = null;
        this.behaviorInstructions = null;
        this.providers = null;

        this.viewFactory = null;

        this.anchorIsContainer = false;
        this.elementInstruction = null;
        this.lifting = false;

        this.values = null;
      }

      return TargetInstruction;
    }(), _class.noExpressions = Object.freeze([]), _temp);
    var viewStrategy = exports.viewStrategy = _aureliaMetadata.protocol.create('aurelia:view-strategy', {
      validate: function validate(target) {
        if (!(typeof target.loadViewFactory === 'function')) {
          return 'View strategies must implement: loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>';
        }

        return true;
      },
      compose: function compose(target) {
        if (!(typeof target.makeRelativeTo === 'function')) {
          target.makeRelativeTo = _aureliaPal.PLATFORM.noop;
        }
      }
    });

    var RelativeViewStrategy = exports.RelativeViewStrategy = (_dec = viewStrategy(), _dec(_class2 = function () {
      function RelativeViewStrategy(path) {

        this.path = path;
        this.absolutePath = null;
      }

      RelativeViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        if (this.absolutePath === null && this.moduleId) {
          this.absolutePath = (0, _aureliaPath.relativeToFile)(this.path, this.moduleId);
        }

        compileInstruction.associatedModuleId = this.moduleId;
        return viewEngine.loadViewFactory(this.absolutePath || this.path, compileInstruction, loadContext, target);
      };

      RelativeViewStrategy.prototype.makeRelativeTo = function makeRelativeTo(file) {
        if (this.absolutePath === null) {
          this.absolutePath = (0, _aureliaPath.relativeToFile)(this.path, file);
        }
      };

      return RelativeViewStrategy;
    }()) || _class2);
    var ConventionalViewStrategy = exports.ConventionalViewStrategy = (_dec2 = viewStrategy(), _dec2(_class3 = function () {
      function ConventionalViewStrategy(viewLocator, origin) {

        this.moduleId = origin.moduleId;
        this.viewUrl = viewLocator.convertOriginToViewUrl(origin);
      }

      ConventionalViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        compileInstruction.associatedModuleId = this.moduleId;
        return viewEngine.loadViewFactory(this.viewUrl, compileInstruction, loadContext, target);
      };

      return ConventionalViewStrategy;
    }()) || _class3);
    var NoViewStrategy = exports.NoViewStrategy = (_dec3 = viewStrategy(), _dec3(_class4 = function () {
      function NoViewStrategy(dependencies, dependencyBaseUrl) {

        this.dependencies = dependencies || null;
        this.dependencyBaseUrl = dependencyBaseUrl || '';
      }

      NoViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        var entry = this.entry;
        var dependencies = this.dependencies;

        if (entry && entry.factoryIsReady) {
          return Promise.resolve(null);
        }

        this.entry = entry = new _aureliaLoader.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);

        entry.dependencies = [];
        entry.templateIsLoaded = true;

        if (dependencies !== null) {
          for (var i = 0, ii = dependencies.length; i < ii; ++i) {
            var current = dependencies[i];

            if (typeof current === 'string' || typeof current === 'function') {
              entry.addDependency(current);
            } else {
              entry.addDependency(current.from, current.as);
            }
          }
        }

        compileInstruction.associatedModuleId = this.moduleId;

        return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
      };

      return NoViewStrategy;
    }()) || _class4);
    var TemplateRegistryViewStrategy = exports.TemplateRegistryViewStrategy = (_dec4 = viewStrategy(), _dec4(_class5 = function () {
      function TemplateRegistryViewStrategy(moduleId, entry) {

        this.moduleId = moduleId;
        this.entry = entry;
      }

      TemplateRegistryViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        var entry = this.entry;

        if (entry.factoryIsReady) {
          return Promise.resolve(entry.factory);
        }

        compileInstruction.associatedModuleId = this.moduleId;
        return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
      };

      return TemplateRegistryViewStrategy;
    }()) || _class5);
    var InlineViewStrategy = exports.InlineViewStrategy = (_dec5 = viewStrategy(), _dec5(_class6 = function () {
      function InlineViewStrategy(markup, dependencies, dependencyBaseUrl) {

        this.markup = markup;
        this.dependencies = dependencies || null;
        this.dependencyBaseUrl = dependencyBaseUrl || '';
      }

      InlineViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        var entry = this.entry;
        var dependencies = this.dependencies;

        if (entry && entry.factoryIsReady) {
          return Promise.resolve(entry.factory);
        }

        this.entry = entry = new _aureliaLoader.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);
        entry.template = _aureliaPal.DOM.createTemplateFromMarkup(this.markup);

        if (dependencies !== null) {
          for (var i = 0, ii = dependencies.length; i < ii; ++i) {
            var current = dependencies[i];

            if (typeof current === 'string' || typeof current === 'function') {
              entry.addDependency(current);
            } else {
              entry.addDependency(current.from, current.as);
            }
          }
        }

        compileInstruction.associatedModuleId = this.moduleId;
        return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
      };

      return InlineViewStrategy;
    }()) || _class6);
    var ViewLocator = exports.ViewLocator = (_temp2 = _class7 = function () {
      function ViewLocator() {}

      ViewLocator.prototype.getViewStrategy = function getViewStrategy(value) {
        if (!value) {
          return null;
        }

        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && 'getViewStrategy' in value) {
          var _origin = _aureliaMetadata.Origin.get(value.constructor);

          value = value.getViewStrategy();

          if (typeof value === 'string') {
            value = new RelativeViewStrategy(value);
          }

          viewStrategy.assert(value);

          if (_origin.moduleId) {
            value.makeRelativeTo(_origin.moduleId);
          }

          return value;
        }

        if (typeof value === 'string') {
          value = new RelativeViewStrategy(value);
        }

        if (viewStrategy.validate(value)) {
          return value;
        }

        if (typeof value !== 'function') {
          value = value.constructor;
        }

        var origin = _aureliaMetadata.Origin.get(value);
        var strategy = _aureliaMetadata.metadata.get(ViewLocator.viewStrategyMetadataKey, value);

        if (!strategy) {
          if (!origin.moduleId) {
            throw new Error('Cannot determine default view strategy for object.', value);
          }

          strategy = this.createFallbackViewStrategy(origin);
        } else if (origin.moduleId) {
          strategy.moduleId = origin.moduleId;
        }

        return strategy;
      };

      ViewLocator.prototype.createFallbackViewStrategy = function createFallbackViewStrategy(origin) {
        return new ConventionalViewStrategy(this, origin);
      };

      ViewLocator.prototype.convertOriginToViewUrl = function convertOriginToViewUrl(origin) {
        var moduleId = origin.moduleId;
        var id = moduleId.endsWith('.js') || moduleId.endsWith('.ts') ? moduleId.substring(0, moduleId.length - 3) : moduleId;
        return id + '.html';
      };

      return ViewLocator;
    }(), _class7.viewStrategyMetadataKey = 'aurelia:view-strategy', _temp2);

    function mi(name) {
      throw new Error('BindingLanguage must implement ' + name + '().');
    }

    var BindingLanguage = exports.BindingLanguage = function () {
      function BindingLanguage() {}

      BindingLanguage.prototype.inspectAttribute = function inspectAttribute(resources, elementName, attrName, attrValue) {
        mi('inspectAttribute');
      };

      BindingLanguage.prototype.createAttributeInstruction = function createAttributeInstruction(resources, element, info, existingInstruction) {
        mi('createAttributeInstruction');
      };

      BindingLanguage.prototype.inspectTextContent = function inspectTextContent(resources, value) {
        mi('inspectTextContent');
      };

      return BindingLanguage;
    }();

    var noNodes = Object.freeze([]);

    var SlotCustomAttribute = exports.SlotCustomAttribute = (_dec6 = (0, _aureliaDependencyInjection.inject)(_aureliaPal.DOM.Element), _dec6(_class8 = function () {
      function SlotCustomAttribute(element) {

        this.element = element;
        this.element.auSlotAttribute = this;
      }

      SlotCustomAttribute.prototype.valueChanged = function valueChanged(newValue, oldValue) {};

      return SlotCustomAttribute;
    }()) || _class8);

    var PassThroughSlot = exports.PassThroughSlot = function () {
      function PassThroughSlot(anchor, name, destinationName, fallbackFactory) {

        this.anchor = anchor;
        this.anchor.viewSlot = this;
        this.name = name;
        this.destinationName = destinationName;
        this.fallbackFactory = fallbackFactory;
        this.destinationSlot = null;
        this.projections = 0;
        this.contentView = null;

        var attr = new SlotCustomAttribute(this.anchor);
        attr.value = this.destinationName;
      }

      PassThroughSlot.prototype.renderFallbackContent = function renderFallbackContent(view, nodes, projectionSource, index) {
        if (this.contentView === null) {
          this.contentView = this.fallbackFactory.create(this.ownerView.container);
          this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);

          var slots = Object.create(null);
          slots[this.destinationSlot.name] = this.destinationSlot;

          ShadowDOM.distributeView(this.contentView, slots, projectionSource, index, this.destinationSlot.name);
        }
      };

      PassThroughSlot.prototype.passThroughTo = function passThroughTo(destinationSlot) {
        this.destinationSlot = destinationSlot;
      };

      PassThroughSlot.prototype.addNode = function addNode(view, node, projectionSource, index) {
        if (this.contentView !== null) {
          this.contentView.removeNodes();
          this.contentView.detached();
          this.contentView.unbind();
          this.contentView = null;
        }

        if (node.viewSlot instanceof PassThroughSlot) {
          node.viewSlot.passThroughTo(this);
          return;
        }

        this.projections++;
        this.destinationSlot.addNode(view, node, projectionSource, index);
      };

      PassThroughSlot.prototype.removeView = function removeView(view, projectionSource) {
        this.projections--;
        this.destinationSlot.removeView(view, projectionSource);

        if (this.needsFallbackRendering) {
          this.renderFallbackContent(null, noNodes, projectionSource);
        }
      };

      PassThroughSlot.prototype.removeAll = function removeAll(projectionSource) {
        this.projections = 0;
        this.destinationSlot.removeAll(projectionSource);

        if (this.needsFallbackRendering) {
          this.renderFallbackContent(null, noNodes, projectionSource);
        }
      };

      PassThroughSlot.prototype.projectFrom = function projectFrom(view, projectionSource) {
        this.destinationSlot.projectFrom(view, projectionSource);
      };

      PassThroughSlot.prototype.created = function created(ownerView) {
        this.ownerView = ownerView;
      };

      PassThroughSlot.prototype.bind = function bind(view) {
        if (this.contentView) {
          this.contentView.bind(view.bindingContext, view.overrideContext);
        }
      };

      PassThroughSlot.prototype.attached = function attached() {
        if (this.contentView) {
          this.contentView.attached();
        }
      };

      PassThroughSlot.prototype.detached = function detached() {
        if (this.contentView) {
          this.contentView.detached();
        }
      };

      PassThroughSlot.prototype.unbind = function unbind() {
        if (this.contentView) {
          this.contentView.unbind();
        }
      };

      _createClass(PassThroughSlot, [{
        key: 'needsFallbackRendering',
        get: function get() {
          return this.fallbackFactory && this.projections === 0;
        }
      }]);

      return PassThroughSlot;
    }();

    var ShadowSlot = exports.ShadowSlot = function () {
      function ShadowSlot(anchor, name, fallbackFactory) {

        this.anchor = anchor;
        this.anchor.isContentProjectionSource = true;
        this.anchor.viewSlot = this;
        this.name = name;
        this.fallbackFactory = fallbackFactory;
        this.contentView = null;
        this.projections = 0;
        this.children = [];
        this.projectFromAnchors = null;
        this.destinationSlots = null;
      }

      ShadowSlot.prototype.addNode = function addNode(view, node, projectionSource, index, destination) {
        if (this.contentView !== null) {
          this.contentView.removeNodes();
          this.contentView.detached();
          this.contentView.unbind();
          this.contentView = null;
        }

        if (node.viewSlot instanceof PassThroughSlot) {
          node.viewSlot.passThroughTo(this);
          return;
        }

        if (this.destinationSlots !== null) {
          ShadowDOM.distributeNodes(view, [node], this.destinationSlots, this, index);
        } else {
          node.auOwnerView = view;
          node.auProjectionSource = projectionSource;
          node.auAssignedSlot = this;

          var anchor = this._findAnchor(view, node, projectionSource, index);
          var parent = anchor.parentNode;

          parent.insertBefore(node, anchor);
          this.children.push(node);
          this.projections++;
        }
      };

      ShadowSlot.prototype.removeView = function removeView(view, projectionSource) {
        if (this.destinationSlots !== null) {
          ShadowDOM.undistributeView(view, this.destinationSlots, this);
        } else if (this.contentView && this.contentView.hasSlots) {
          ShadowDOM.undistributeView(view, this.contentView.slots, projectionSource);
        } else {
          var found = this.children.find(function (x) {
            return x.auSlotProjectFrom === projectionSource;
          });
          if (found) {
            var _children = found.auProjectionChildren;

            for (var i = 0, ii = _children.length; i < ii; ++i) {
              var _child = _children[i];

              if (_child.auOwnerView === view) {
                _children.splice(i, 1);
                view.fragment.appendChild(_child);
                i--;ii--;
                this.projections--;
              }
            }

            if (this.needsFallbackRendering) {
              this.renderFallbackContent(view, noNodes, projectionSource);
            }
          }
        }
      };

      ShadowSlot.prototype.removeAll = function removeAll(projectionSource) {
        if (this.destinationSlots !== null) {
          ShadowDOM.undistributeAll(this.destinationSlots, this);
        } else if (this.contentView && this.contentView.hasSlots) {
          ShadowDOM.undistributeAll(this.contentView.slots, projectionSource);
        } else {
          var found = this.children.find(function (x) {
            return x.auSlotProjectFrom === projectionSource;
          });

          if (found) {
            var _children2 = found.auProjectionChildren;
            for (var i = 0, ii = _children2.length; i < ii; ++i) {
              var _child2 = _children2[i];
              _child2.auOwnerView.fragment.appendChild(_child2);
              this.projections--;
            }

            found.auProjectionChildren = [];

            if (this.needsFallbackRendering) {
              this.renderFallbackContent(null, noNodes, projectionSource);
            }
          }
        }
      };

      ShadowSlot.prototype._findAnchor = function _findAnchor(view, node, projectionSource, index) {
        if (projectionSource) {
          var found = this.children.find(function (x) {
            return x.auSlotProjectFrom === projectionSource;
          });
          if (found) {
            if (index !== undefined) {
              var _children3 = found.auProjectionChildren;
              var viewIndex = -1;
              var lastView = void 0;

              for (var i = 0, ii = _children3.length; i < ii; ++i) {
                var current = _children3[i];

                if (current.auOwnerView !== lastView) {
                  viewIndex++;
                  lastView = current.auOwnerView;

                  if (viewIndex >= index && lastView !== view) {
                    _children3.splice(i, 0, node);
                    return current;
                  }
                }
              }
            }

            found.auProjectionChildren.push(node);
            return found;
          }
        }

        return this.anchor;
      };

      ShadowSlot.prototype.projectTo = function projectTo(slots) {
        this.destinationSlots = slots;
      };

      ShadowSlot.prototype.projectFrom = function projectFrom(view, projectionSource) {
        var anchor = _aureliaPal.DOM.createComment('anchor');
        var parent = this.anchor.parentNode;
        anchor.auSlotProjectFrom = projectionSource;
        anchor.auOwnerView = view;
        anchor.auProjectionChildren = [];
        parent.insertBefore(anchor, this.anchor);
        this.children.push(anchor);

        if (this.projectFromAnchors === null) {
          this.projectFromAnchors = [];
        }

        this.projectFromAnchors.push(anchor);
      };

      ShadowSlot.prototype.renderFallbackContent = function renderFallbackContent(view, nodes, projectionSource, index) {
        if (this.contentView === null) {
          this.contentView = this.fallbackFactory.create(this.ownerView.container);
          this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);
          this.contentView.insertNodesBefore(this.anchor);
        }

        if (this.contentView.hasSlots) {
          var slots = this.contentView.slots;
          var projectFromAnchors = this.projectFromAnchors;

          if (projectFromAnchors !== null) {
            for (var slotName in slots) {
              var slot = slots[slotName];

              for (var i = 0, ii = projectFromAnchors.length; i < ii; ++i) {
                var anchor = projectFromAnchors[i];
                slot.projectFrom(anchor.auOwnerView, anchor.auSlotProjectFrom);
              }
            }
          }

          this.fallbackSlots = slots;
          ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index);
        }
      };

      ShadowSlot.prototype.created = function created(ownerView) {
        this.ownerView = ownerView;
      };

      ShadowSlot.prototype.bind = function bind(view) {
        if (this.contentView) {
          this.contentView.bind(view.bindingContext, view.overrideContext);
        }
      };

      ShadowSlot.prototype.attached = function attached() {
        if (this.contentView) {
          this.contentView.attached();
        }
      };

      ShadowSlot.prototype.detached = function detached() {
        if (this.contentView) {
          this.contentView.detached();
        }
      };

      ShadowSlot.prototype.unbind = function unbind() {
        if (this.contentView) {
          this.contentView.unbind();
        }
      };

      _createClass(ShadowSlot, [{
        key: 'needsFallbackRendering',
        get: function get() {
          return this.fallbackFactory && this.projections === 0;
        }
      }]);

      return ShadowSlot;
    }();

    var ShadowDOM = exports.ShadowDOM = (_temp3 = _class9 = function () {
      function ShadowDOM() {}

      ShadowDOM.getSlotName = function getSlotName(node) {
        if (node.auSlotAttribute === undefined) {
          return ShadowDOM.defaultSlotKey;
        }

        return node.auSlotAttribute.value;
      };

      ShadowDOM.distributeView = function distributeView(view, slots, projectionSource, index, destinationOverride) {
        var nodes = void 0;

        if (view === null) {
          nodes = noNodes;
        } else {
          var childNodes = view.fragment.childNodes;
          var ii = childNodes.length;
          nodes = new Array(ii);

          for (var i = 0; i < ii; ++i) {
            nodes[i] = childNodes[i];
          }
        }

        ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride);
      };

      ShadowDOM.undistributeView = function undistributeView(view, slots, projectionSource) {
        for (var slotName in slots) {
          slots[slotName].removeView(view, projectionSource);
        }
      };

      ShadowDOM.undistributeAll = function undistributeAll(slots, projectionSource) {
        for (var slotName in slots) {
          slots[slotName].removeAll(projectionSource);
        }
      };

      ShadowDOM.distributeNodes = function distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride) {
        for (var i = 0, ii = nodes.length; i < ii; ++i) {
          var currentNode = nodes[i];
          var nodeType = currentNode.nodeType;

          if (currentNode.isContentProjectionSource) {
            currentNode.viewSlot.projectTo(slots);

            for (var slotName in slots) {
              slots[slotName].projectFrom(view, currentNode.viewSlot);
            }

            nodes.splice(i, 1);
            ii--;i--;
          } else if (nodeType === 1 || nodeType === 3 || currentNode.viewSlot instanceof PassThroughSlot) {
            if (nodeType === 3 && _isAllWhitespace(currentNode)) {
              nodes.splice(i, 1);
              ii--;i--;
            } else {
              var found = slots[destinationOverride || ShadowDOM.getSlotName(currentNode)];

              if (found) {
                found.addNode(view, currentNode, projectionSource, index);
                nodes.splice(i, 1);
                ii--;i--;
              }
            }
          } else {
            nodes.splice(i, 1);
            ii--;i--;
          }
        }

        for (var _slotName in slots) {
          var slot = slots[_slotName];

          if (slot.needsFallbackRendering) {
            slot.renderFallbackContent(view, nodes, projectionSource, index);
          }
        }
      };

      return ShadowDOM;
    }(), _class9.defaultSlotKey = '__au-default-slot-key__', _temp3);

    function register(lookup, name, resource, type) {
      if (!name) {
        return;
      }

      var existing = lookup[name];
      if (existing) {
        if (existing !== resource) {
          throw new Error('Attempted to register ' + type + ' when one with the same name already exists. Name: ' + name + '.');
        }

        return;
      }

      lookup[name] = resource;
    }

    var ViewResources = exports.ViewResources = function () {
      function ViewResources(parent, viewUrl) {

        this.bindingLanguage = null;

        this.parent = parent || null;
        this.hasParent = this.parent !== null;
        this.viewUrl = viewUrl || '';
        this.lookupFunctions = {
          valueConverters: this.getValueConverter.bind(this),
          bindingBehaviors: this.getBindingBehavior.bind(this)
        };
        this.attributes = Object.create(null);
        this.elements = Object.create(null);
        this.valueConverters = Object.create(null);
        this.bindingBehaviors = Object.create(null);
        this.attributeMap = Object.create(null);
        this.values = Object.create(null);
        this.beforeCompile = this.afterCompile = this.beforeCreate = this.afterCreate = this.beforeBind = this.beforeUnbind = false;
      }

      ViewResources.prototype._tryAddHook = function _tryAddHook(obj, name) {
        if (typeof obj[name] === 'function') {
          var func = obj[name].bind(obj);
          var counter = 1;
          var callbackName = void 0;

          while (this[callbackName = name + counter.toString()] !== undefined) {
            counter++;
          }

          this[name] = true;
          this[callbackName] = func;
        }
      };

      ViewResources.prototype._invokeHook = function _invokeHook(name, one, two, three, four) {
        if (this.hasParent) {
          this.parent._invokeHook(name, one, two, three, four);
        }

        if (this[name]) {
          this[name + '1'](one, two, three, four);

          var callbackName = name + '2';
          if (this[callbackName]) {
            this[callbackName](one, two, three, four);

            callbackName = name + '3';
            if (this[callbackName]) {
              this[callbackName](one, two, three, four);

              var counter = 4;

              while (this[callbackName = name + counter.toString()] !== undefined) {
                this[callbackName](one, two, three, four);
                counter++;
              }
            }
          }
        }
      };

      ViewResources.prototype.registerViewEngineHooks = function registerViewEngineHooks(hooks) {
        this._tryAddHook(hooks, 'beforeCompile');
        this._tryAddHook(hooks, 'afterCompile');
        this._tryAddHook(hooks, 'beforeCreate');
        this._tryAddHook(hooks, 'afterCreate');
        this._tryAddHook(hooks, 'beforeBind');
        this._tryAddHook(hooks, 'beforeUnbind');
      };

      ViewResources.prototype.getBindingLanguage = function getBindingLanguage(bindingLanguageFallback) {
        return this.bindingLanguage || (this.bindingLanguage = bindingLanguageFallback);
      };

      ViewResources.prototype.patchInParent = function patchInParent(newParent) {
        var originalParent = this.parent;

        this.parent = newParent || null;
        this.hasParent = this.parent !== null;

        if (newParent.parent === null) {
          newParent.parent = originalParent;
          newParent.hasParent = originalParent !== null;
        }
      };

      ViewResources.prototype.relativeToView = function relativeToView(path) {
        return (0, _aureliaPath.relativeToFile)(path, this.viewUrl);
      };

      ViewResources.prototype.registerElement = function registerElement(tagName, behavior) {
        register(this.elements, tagName, behavior, 'an Element');
      };

      ViewResources.prototype.getElement = function getElement(tagName) {
        return this.elements[tagName] || (this.hasParent ? this.parent.getElement(tagName) : null);
      };

      ViewResources.prototype.mapAttribute = function mapAttribute(attribute) {
        return this.attributeMap[attribute] || (this.hasParent ? this.parent.mapAttribute(attribute) : null);
      };

      ViewResources.prototype.registerAttribute = function registerAttribute(attribute, behavior, knownAttribute) {
        this.attributeMap[attribute] = knownAttribute;
        register(this.attributes, attribute, behavior, 'an Attribute');
      };

      ViewResources.prototype.getAttribute = function getAttribute(attribute) {
        return this.attributes[attribute] || (this.hasParent ? this.parent.getAttribute(attribute) : null);
      };

      ViewResources.prototype.registerValueConverter = function registerValueConverter(name, valueConverter) {
        register(this.valueConverters, name, valueConverter, 'a ValueConverter');
      };

      ViewResources.prototype.getValueConverter = function getValueConverter(name) {
        return this.valueConverters[name] || (this.hasParent ? this.parent.getValueConverter(name) : null);
      };

      ViewResources.prototype.registerBindingBehavior = function registerBindingBehavior(name, bindingBehavior) {
        register(this.bindingBehaviors, name, bindingBehavior, 'a BindingBehavior');
      };

      ViewResources.prototype.getBindingBehavior = function getBindingBehavior(name) {
        return this.bindingBehaviors[name] || (this.hasParent ? this.parent.getBindingBehavior(name) : null);
      };

      ViewResources.prototype.registerValue = function registerValue(name, value) {
        register(this.values, name, value, 'a value');
      };

      ViewResources.prototype.getValue = function getValue(name) {
        return this.values[name] || (this.hasParent ? this.parent.getValue(name) : null);
      };

      return ViewResources;
    }();

    var View = exports.View = function () {
      function View(container, viewFactory, fragment, controllers, bindings, children, slots) {

        this.container = container;
        this.viewFactory = viewFactory;
        this.resources = viewFactory.resources;
        this.fragment = fragment;
        this.firstChild = fragment.firstChild;
        this.lastChild = fragment.lastChild;
        this.controllers = controllers;
        this.bindings = bindings;
        this.children = children;
        this.slots = slots;
        this.hasSlots = false;
        this.fromCache = false;
        this.isBound = false;
        this.isAttached = false;
        this.bindingContext = null;
        this.overrideContext = null;
        this.controller = null;
        this.viewModelScope = null;
        this.animatableElement = undefined;
        this._isUserControlled = false;
        this.contentView = null;

        for (var key in slots) {
          this.hasSlots = true;
          break;
        }
      }

      View.prototype.returnToCache = function returnToCache() {
        this.viewFactory.returnViewToCache(this);
      };

      View.prototype.created = function created() {
        var i = void 0;
        var ii = void 0;
        var controllers = this.controllers;

        for (i = 0, ii = controllers.length; i < ii; ++i) {
          controllers[i].created(this);
        }
      };

      View.prototype.bind = function bind(bindingContext, overrideContext, _systemUpdate) {
        var controllers = void 0;
        var bindings = void 0;
        var children = void 0;
        var i = void 0;
        var ii = void 0;

        if (_systemUpdate && this._isUserControlled) {
          return;
        }

        if (this.isBound) {
          if (this.bindingContext === bindingContext) {
            return;
          }

          this.unbind();
        }

        this.isBound = true;
        this.bindingContext = bindingContext;
        this.overrideContext = overrideContext || (0, _aureliaBinding.createOverrideContext)(bindingContext);

        this.resources._invokeHook('beforeBind', this);

        bindings = this.bindings;
        for (i = 0, ii = bindings.length; i < ii; ++i) {
          bindings[i].bind(this);
        }

        if (this.viewModelScope !== null) {
          bindingContext.bind(this.viewModelScope.bindingContext, this.viewModelScope.overrideContext);
          this.viewModelScope = null;
        }

        controllers = this.controllers;
        for (i = 0, ii = controllers.length; i < ii; ++i) {
          controllers[i].bind(this);
        }

        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          children[i].bind(bindingContext, overrideContext, true);
        }

        if (this.hasSlots) {
          ShadowDOM.distributeView(this.contentView, this.slots);
        }
      };

      View.prototype.addBinding = function addBinding(binding) {
        this.bindings.push(binding);

        if (this.isBound) {
          binding.bind(this);
        }
      };

      View.prototype.unbind = function unbind() {
        var controllers = void 0;
        var bindings = void 0;
        var children = void 0;
        var i = void 0;
        var ii = void 0;

        if (this.isBound) {
          this.isBound = false;
          this.resources._invokeHook('beforeUnbind', this);

          if (this.controller !== null) {
            this.controller.unbind();
          }

          bindings = this.bindings;
          for (i = 0, ii = bindings.length; i < ii; ++i) {
            bindings[i].unbind();
          }

          controllers = this.controllers;
          for (i = 0, ii = controllers.length; i < ii; ++i) {
            controllers[i].unbind();
          }

          children = this.children;
          for (i = 0, ii = children.length; i < ii; ++i) {
            children[i].unbind();
          }

          this.bindingContext = null;
          this.overrideContext = null;
        }
      };

      View.prototype.insertNodesBefore = function insertNodesBefore(refNode) {
        refNode.parentNode.insertBefore(this.fragment, refNode);
      };

      View.prototype.appendNodesTo = function appendNodesTo(parent) {
        parent.appendChild(this.fragment);
      };

      View.prototype.removeNodes = function removeNodes() {
        var fragment = this.fragment;
        var current = this.firstChild;
        var end = this.lastChild;
        var next = void 0;

        while (current) {
          next = current.nextSibling;
          fragment.appendChild(current);

          if (current === end) {
            break;
          }

          current = next;
        }
      };

      View.prototype.attached = function attached() {
        var controllers = void 0;
        var children = void 0;
        var i = void 0;
        var ii = void 0;

        if (this.isAttached) {
          return;
        }

        this.isAttached = true;

        if (this.controller !== null) {
          this.controller.attached();
        }

        controllers = this.controllers;
        for (i = 0, ii = controllers.length; i < ii; ++i) {
          controllers[i].attached();
        }

        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          children[i].attached();
        }
      };

      View.prototype.detached = function detached() {
        var controllers = void 0;
        var children = void 0;
        var i = void 0;
        var ii = void 0;

        if (this.isAttached) {
          this.isAttached = false;

          if (this.controller !== null) {
            this.controller.detached();
          }

          controllers = this.controllers;
          for (i = 0, ii = controllers.length; i < ii; ++i) {
            controllers[i].detached();
          }

          children = this.children;
          for (i = 0, ii = children.length; i < ii; ++i) {
            children[i].detached();
          }
        }
      };

      return View;
    }();

    function getAnimatableElement(view) {
      if (view.animatableElement !== undefined) {
        return view.animatableElement;
      }

      var current = view.firstChild;

      while (current && current.nodeType !== 1) {
        current = current.nextSibling;
      }

      if (current && current.nodeType === 1) {
        return view.animatableElement = current.classList.contains('au-animate') ? current : null;
      }

      return view.animatableElement = null;
    }

    var ViewSlot = exports.ViewSlot = function () {
      function ViewSlot(anchor, anchorIsContainer) {
        var animator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Animator.instance;

        this.anchor = anchor;
        this.anchorIsContainer = anchorIsContainer;
        this.bindingContext = null;
        this.overrideContext = null;
        this.animator = animator;
        this.children = [];
        this.isBound = false;
        this.isAttached = false;
        this.contentSelectors = null;
        anchor.viewSlot = this;
        anchor.isContentProjectionSource = false;
      }

      ViewSlot.prototype.animateView = function animateView(view) {
        var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'enter';

        var animatableElement = getAnimatableElement(view);

        if (animatableElement !== null) {
          switch (direction) {
            case 'enter':
              return this.animator.enter(animatableElement);
            case 'leave':
              return this.animator.leave(animatableElement);
            default:
              throw new Error('Invalid animation direction: ' + direction);
          }
        }
      };

      ViewSlot.prototype.transformChildNodesIntoView = function transformChildNodesIntoView() {
        var parent = this.anchor;

        this.children.push({
          fragment: parent,
          firstChild: parent.firstChild,
          lastChild: parent.lastChild,
          returnToCache: function returnToCache() {},
          removeNodes: function removeNodes() {
            var last = void 0;

            while (last = parent.lastChild) {
              parent.removeChild(last);
            }
          },
          created: function created() {},
          bind: function bind() {},
          unbind: function unbind() {},
          attached: function attached() {},
          detached: function detached() {}
        });
      };

      ViewSlot.prototype.bind = function bind(bindingContext, overrideContext) {
        var i = void 0;
        var ii = void 0;
        var children = void 0;

        if (this.isBound) {
          if (this.bindingContext === bindingContext) {
            return;
          }

          this.unbind();
        }

        this.isBound = true;
        this.bindingContext = bindingContext = bindingContext || this.bindingContext;
        this.overrideContext = overrideContext = overrideContext || this.overrideContext;

        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          children[i].bind(bindingContext, overrideContext, true);
        }
      };

      ViewSlot.prototype.unbind = function unbind() {
        if (this.isBound) {
          var i = void 0;
          var ii = void 0;
          var _children4 = this.children;

          this.isBound = false;
          this.bindingContext = null;
          this.overrideContext = null;

          for (i = 0, ii = _children4.length; i < ii; ++i) {
            _children4[i].unbind();
          }
        }
      };

      ViewSlot.prototype.add = function add(view) {
        if (this.anchorIsContainer) {
          view.appendNodesTo(this.anchor);
        } else {
          view.insertNodesBefore(this.anchor);
        }

        this.children.push(view);

        if (this.isAttached) {
          view.attached();
          return this.animateView(view, 'enter');
        }
      };

      ViewSlot.prototype.insert = function insert(index, view) {
        var children = this.children;
        var length = children.length;

        if (index === 0 && length === 0 || index >= length) {
          return this.add(view);
        }

        view.insertNodesBefore(children[index].firstChild);
        children.splice(index, 0, view);

        if (this.isAttached) {
          view.attached();
          return this.animateView(view, 'enter');
        }
      };

      ViewSlot.prototype.move = function move(sourceIndex, targetIndex) {
        if (sourceIndex === targetIndex) {
          return;
        }

        var children = this.children;
        var view = children[sourceIndex];

        view.removeNodes();
        view.insertNodesBefore(children[targetIndex].firstChild);
        children.splice(sourceIndex, 1);
        children.splice(targetIndex, 0, view);
      };

      ViewSlot.prototype.remove = function remove(view, returnToCache, skipAnimation) {
        return this.removeAt(this.children.indexOf(view), returnToCache, skipAnimation);
      };

      ViewSlot.prototype.removeMany = function removeMany(viewsToRemove, returnToCache, skipAnimation) {
        var _this4 = this;

        var children = this.children;
        var ii = viewsToRemove.length;
        var i = void 0;
        var rmPromises = [];

        viewsToRemove.forEach(function (child) {
          if (skipAnimation) {
            child.removeNodes();
            return;
          }

          var animation = _this4.animateView(child, 'leave');
          if (animation) {
            rmPromises.push(animation.then(function () {
              return child.removeNodes();
            }));
          } else {
            child.removeNodes();
          }
        });

        var removeAction = function removeAction() {
          if (_this4.isAttached) {
            for (i = 0; i < ii; ++i) {
              viewsToRemove[i].detached();
            }
          }

          if (returnToCache) {
            for (i = 0; i < ii; ++i) {
              viewsToRemove[i].returnToCache();
            }
          }

          for (i = 0; i < ii; ++i) {
            var index = children.indexOf(viewsToRemove[i]);
            if (index >= 0) {
              children.splice(index, 1);
            }
          }
        };

        if (rmPromises.length > 0) {
          return Promise.all(rmPromises).then(function () {
            return removeAction();
          });
        }

        return removeAction();
      };

      ViewSlot.prototype.removeAt = function removeAt(index, returnToCache, skipAnimation) {
        var _this5 = this;

        var view = this.children[index];

        var removeAction = function removeAction() {
          index = _this5.children.indexOf(view);
          view.removeNodes();
          _this5.children.splice(index, 1);

          if (_this5.isAttached) {
            view.detached();
          }

          if (returnToCache) {
            view.returnToCache();
          }

          return view;
        };

        if (!skipAnimation) {
          var animation = this.animateView(view, 'leave');
          if (animation) {
            return animation.then(function () {
              return removeAction();
            });
          }
        }

        return removeAction();
      };

      ViewSlot.prototype.removeAll = function removeAll(returnToCache, skipAnimation) {
        var _this6 = this;

        var children = this.children;
        var ii = children.length;
        var i = void 0;
        var rmPromises = [];

        children.forEach(function (child) {
          if (skipAnimation) {
            child.removeNodes();
            return;
          }

          var animation = _this6.animateView(child, 'leave');
          if (animation) {
            rmPromises.push(animation.then(function () {
              return child.removeNodes();
            }));
          } else {
            child.removeNodes();
          }
        });

        var removeAction = function removeAction() {
          if (_this6.isAttached) {
            for (i = 0; i < ii; ++i) {
              children[i].detached();
            }
          }

          if (returnToCache) {
            for (i = 0; i < ii; ++i) {
              var _child3 = children[i];

              if (_child3) {
                _child3.returnToCache();
              }
            }
          }

          _this6.children = [];
        };

        if (rmPromises.length > 0) {
          return Promise.all(rmPromises).then(function () {
            return removeAction();
          });
        }

        return removeAction();
      };

      ViewSlot.prototype.attached = function attached() {
        var i = void 0;
        var ii = void 0;
        var children = void 0;
        var child = void 0;

        if (this.isAttached) {
          return;
        }

        this.isAttached = true;

        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          child = children[i];
          child.attached();
          this.animateView(child, 'enter');
        }
      };

      ViewSlot.prototype.detached = function detached() {
        var i = void 0;
        var ii = void 0;
        var children = void 0;

        if (this.isAttached) {
          this.isAttached = false;
          children = this.children;
          for (i = 0, ii = children.length; i < ii; ++i) {
            children[i].detached();
          }
        }
      };

      ViewSlot.prototype.projectTo = function projectTo(slots) {
        var _this7 = this;

        this.projectToSlots = slots;
        this.add = this._projectionAdd;
        this.insert = this._projectionInsert;
        this.move = this._projectionMove;
        this.remove = this._projectionRemove;
        this.removeAt = this._projectionRemoveAt;
        this.removeMany = this._projectionRemoveMany;
        this.removeAll = this._projectionRemoveAll;
        this.children.forEach(function (view) {
          return ShadowDOM.distributeView(view, slots, _this7);
        });
      };

      ViewSlot.prototype._projectionAdd = function _projectionAdd(view) {
        ShadowDOM.distributeView(view, this.projectToSlots, this);

        this.children.push(view);

        if (this.isAttached) {
          view.attached();
        }
      };

      ViewSlot.prototype._projectionInsert = function _projectionInsert(index, view) {
        if (index === 0 && !this.children.length || index >= this.children.length) {
          this.add(view);
        } else {
          ShadowDOM.distributeView(view, this.projectToSlots, this, index);

          this.children.splice(index, 0, view);

          if (this.isAttached) {
            view.attached();
          }
        }
      };

      ViewSlot.prototype._projectionMove = function _projectionMove(sourceIndex, targetIndex) {
        if (sourceIndex === targetIndex) {
          return;
        }

        var children = this.children;
        var view = children[sourceIndex];

        ShadowDOM.undistributeView(view, this.projectToSlots, this);
        ShadowDOM.distributeView(view, this.projectToSlots, this, targetIndex);

        children.splice(sourceIndex, 1);
        children.splice(targetIndex, 0, view);
      };

      ViewSlot.prototype._projectionRemove = function _projectionRemove(view, returnToCache) {
        ShadowDOM.undistributeView(view, this.projectToSlots, this);
        this.children.splice(this.children.indexOf(view), 1);

        if (this.isAttached) {
          view.detached();
        }
      };

      ViewSlot.prototype._projectionRemoveAt = function _projectionRemoveAt(index, returnToCache) {
        var view = this.children[index];

        ShadowDOM.undistributeView(view, this.projectToSlots, this);
        this.children.splice(index, 1);

        if (this.isAttached) {
          view.detached();
        }
      };

      ViewSlot.prototype._projectionRemoveMany = function _projectionRemoveMany(viewsToRemove, returnToCache) {
        var _this8 = this;

        viewsToRemove.forEach(function (view) {
          return _this8.remove(view, returnToCache);
        });
      };

      ViewSlot.prototype._projectionRemoveAll = function _projectionRemoveAll(returnToCache) {
        ShadowDOM.undistributeAll(this.projectToSlots, this);

        var children = this.children;

        if (this.isAttached) {
          for (var i = 0, ii = children.length; i < ii; ++i) {
            children[i].detached();
          }
        }

        this.children = [];
      };

      return ViewSlot;
    }();

    var ProviderResolver = (0, _aureliaDependencyInjection.resolver)(_class11 = function () {
      function ProviderResolver() {}

      ProviderResolver.prototype.get = function get(container, key) {
        var id = key.__providerId__;
        return id in container ? container[id] : container[id] = container.invoke(key);
      };

      return ProviderResolver;
    }()) || _class11;

    var providerResolverInstance = new ProviderResolver();

    function elementContainerGet(key) {
      if (key === _aureliaPal.DOM.Element) {
        return this.element;
      }

      if (key === BoundViewFactory) {
        if (this.boundViewFactory) {
          return this.boundViewFactory;
        }

        var factory = this.instruction.viewFactory;
        var _partReplacements = this.partReplacements;

        if (_partReplacements) {
          factory = _partReplacements[factory.part] || factory;
        }

        this.boundViewFactory = new BoundViewFactory(this, factory, _partReplacements);
        return this.boundViewFactory;
      }

      if (key === ViewSlot) {
        if (this.viewSlot === undefined) {
          this.viewSlot = new ViewSlot(this.element, this.instruction.anchorIsContainer);
          this.element.isContentProjectionSource = this.instruction.lifting;
          this.children.push(this.viewSlot);
        }

        return this.viewSlot;
      }

      if (key === ElementEvents) {
        return this.elementEvents || (this.elementEvents = new ElementEvents(this.element));
      }

      if (key === CompositionTransaction) {
        return this.compositionTransaction || (this.compositionTransaction = this.parent.get(key));
      }

      if (key === ViewResources) {
        return this.viewResources;
      }

      if (key === TargetInstruction) {
        return this.instruction;
      }

      return this.superGet(key);
    }

    function createElementContainer(parent, element, instruction, children, partReplacements, resources) {
      var container = parent.createChild();
      var providers = void 0;
      var i = void 0;

      container.element = element;
      container.instruction = instruction;
      container.children = children;
      container.viewResources = resources;
      container.partReplacements = partReplacements;

      providers = instruction.providers;
      i = providers.length;

      while (i--) {
        container._resolvers.set(providers[i], providerResolverInstance);
      }

      container.superGet = container.get;
      container.get = elementContainerGet;

      return container;
    }

    function hasAttribute(name) {
      return this._element.hasAttribute(name);
    }

    function getAttribute(name) {
      return this._element.getAttribute(name);
    }

    function setAttribute(name, value) {
      this._element.setAttribute(name, value);
    }

    function makeElementIntoAnchor(element, elementInstruction) {
      var anchor = _aureliaPal.DOM.createComment('anchor');

      if (elementInstruction) {
        var firstChild = element.firstChild;

        if (firstChild && firstChild.tagName === 'AU-CONTENT') {
          anchor.contentElement = firstChild;
        }

        anchor._element = element;

        anchor.hasAttribute = hasAttribute;
        anchor.getAttribute = getAttribute;
        anchor.setAttribute = setAttribute;
      }

      _aureliaPal.DOM.replaceNode(anchor, element);

      return anchor;
    }

    function applyInstructions(containers, element, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources) {
      var behaviorInstructions = instruction.behaviorInstructions;
      var expressions = instruction.expressions;
      var elementContainer = void 0;
      var i = void 0;
      var ii = void 0;
      var current = void 0;
      var instance = void 0;

      if (instruction.contentExpression) {
        bindings.push(instruction.contentExpression.createBinding(element.nextSibling));
        element.nextSibling.auInterpolationTarget = true;
        element.parentNode.removeChild(element);
        return;
      }

      if (instruction.shadowSlot) {
        var commentAnchor = _aureliaPal.DOM.createComment('slot');
        var slot = void 0;

        if (instruction.slotDestination) {
          slot = new PassThroughSlot(commentAnchor, instruction.slotName, instruction.slotDestination, instruction.slotFallbackFactory);
        } else {
          slot = new ShadowSlot(commentAnchor, instruction.slotName, instruction.slotFallbackFactory);
        }

        _aureliaPal.DOM.replaceNode(commentAnchor, element);
        shadowSlots[instruction.slotName] = slot;
        controllers.push(slot);
        return;
      }

      if (behaviorInstructions.length) {
        if (!instruction.anchorIsContainer) {
          element = makeElementIntoAnchor(element, instruction.elementInstruction);
        }

        containers[instruction.injectorId] = elementContainer = createElementContainer(containers[instruction.parentInjectorId], element, instruction, children, partReplacements, resources);

        for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
          current = behaviorInstructions[i];
          instance = current.type.create(elementContainer, current, element, bindings);
          controllers.push(instance);
        }
      }

      for (i = 0, ii = expressions.length; i < ii; ++i) {
        bindings.push(expressions[i].createBinding(element));
      }
    }

    function styleStringToObject(style, target) {
      var attributes = style.split(';');
      var firstIndexOfColon = void 0;
      var i = void 0;
      var current = void 0;
      var key = void 0;
      var value = void 0;

      target = target || {};

      for (i = 0; i < attributes.length; i++) {
        current = attributes[i];
        firstIndexOfColon = current.indexOf(':');
        key = current.substring(0, firstIndexOfColon).trim();
        value = current.substring(firstIndexOfColon + 1).trim();
        target[key] = value;
      }

      return target;
    }

    function styleObjectToString(obj) {
      var result = '';

      for (var key in obj) {
        result += key + ':' + obj[key] + ';';
      }

      return result;
    }

    function applySurrogateInstruction(container, element, instruction, controllers, bindings, children) {
      var behaviorInstructions = instruction.behaviorInstructions;
      var expressions = instruction.expressions;
      var providers = instruction.providers;
      var values = instruction.values;
      var i = void 0;
      var ii = void 0;
      var current = void 0;
      var instance = void 0;
      var currentAttributeValue = void 0;

      i = providers.length;
      while (i--) {
        container._resolvers.set(providers[i], providerResolverInstance);
      }

      for (var key in values) {
        currentAttributeValue = element.getAttribute(key);

        if (currentAttributeValue) {
          if (key === 'class') {
            element.setAttribute('class', currentAttributeValue + ' ' + values[key]);
          } else if (key === 'style') {
            var styleObject = styleStringToObject(values[key]);
            styleStringToObject(currentAttributeValue, styleObject);
            element.setAttribute('style', styleObjectToString(styleObject));
          }
        } else {
          element.setAttribute(key, values[key]);
        }
      }

      if (behaviorInstructions.length) {
        for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
          current = behaviorInstructions[i];
          instance = current.type.create(container, current, element, bindings);

          if (instance.contentView) {
            children.push(instance.contentView);
          }

          controllers.push(instance);
        }
      }

      for (i = 0, ii = expressions.length; i < ii; ++i) {
        bindings.push(expressions[i].createBinding(element));
      }
    }

    var BoundViewFactory = exports.BoundViewFactory = function () {
      function BoundViewFactory(parentContainer, viewFactory, partReplacements) {

        this.parentContainer = parentContainer;
        this.viewFactory = viewFactory;
        this.factoryCreateInstruction = { partReplacements: partReplacements };
      }

      BoundViewFactory.prototype.create = function create() {
        var view = this.viewFactory.create(this.parentContainer.createChild(), this.factoryCreateInstruction);
        view._isUserControlled = true;
        return view;
      };

      BoundViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
        this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
      };

      BoundViewFactory.prototype.getCachedView = function getCachedView() {
        return this.viewFactory.getCachedView();
      };

      BoundViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
        this.viewFactory.returnViewToCache(view);
      };

      _createClass(BoundViewFactory, [{
        key: 'isCaching',
        get: function get() {
          return this.viewFactory.isCaching;
        }
      }]);

      return BoundViewFactory;
    }();

    var ViewFactory = exports.ViewFactory = function () {
      function ViewFactory(template, instructions, resources) {

        this.isCaching = false;

        this.template = template;
        this.instructions = instructions;
        this.resources = resources;
        this.cacheSize = -1;
        this.cache = null;
      }

      ViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
        if (size) {
          if (size === '*') {
            size = Number.MAX_VALUE;
          } else if (typeof size === 'string') {
            size = parseInt(size, 10);
          }
        }

        if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {
          this.cacheSize = size;
        }

        if (this.cacheSize > 0) {
          this.cache = [];
        } else {
          this.cache = null;
        }

        this.isCaching = this.cacheSize > 0;
      };

      ViewFactory.prototype.getCachedView = function getCachedView() {
        return this.cache !== null ? this.cache.pop() || null : null;
      };

      ViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
        if (view.isAttached) {
          view.detached();
        }

        if (view.isBound) {
          view.unbind();
        }

        if (this.cache !== null && this.cache.length < this.cacheSize) {
          view.fromCache = true;
          this.cache.push(view);
        }
      };

      ViewFactory.prototype.create = function create(container, createInstruction, element) {
        createInstruction = createInstruction || BehaviorInstruction.normal;

        var cachedView = this.getCachedView();
        if (cachedView !== null) {
          return cachedView;
        }

        var fragment = createInstruction.enhance ? this.template : this.template.cloneNode(true);
        var instructables = fragment.querySelectorAll('.au-target');
        var instructions = this.instructions;
        var resources = this.resources;
        var controllers = [];
        var bindings = [];
        var children = [];
        var shadowSlots = Object.create(null);
        var containers = { root: container };
        var partReplacements = createInstruction.partReplacements;
        var i = void 0;
        var ii = void 0;
        var view = void 0;
        var instructable = void 0;
        var instruction = void 0;

        this.resources._invokeHook('beforeCreate', this, container, fragment, createInstruction);

        if (element && this.surrogateInstruction !== null) {
          applySurrogateInstruction(container, element, this.surrogateInstruction, controllers, bindings, children);
        }

        if (createInstruction.enhance && fragment.hasAttribute('au-target-id')) {
          instructable = fragment;
          instruction = instructions[instructable.getAttribute('au-target-id')];
          applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
        }

        for (i = 0, ii = instructables.length; i < ii; ++i) {
          instructable = instructables[i];
          instruction = instructions[instructable.getAttribute('au-target-id')];
          applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
        }

        view = new View(container, this, fragment, controllers, bindings, children, shadowSlots);

        if (!createInstruction.initiatedByBehavior) {
          view.created();
        }

        this.resources._invokeHook('afterCreate', view);

        return view;
      };

      return ViewFactory;
    }();

    var nextInjectorId = 0;
    function getNextInjectorId() {
      return ++nextInjectorId;
    }

    var lastAUTargetID = 0;
    function getNextAUTargetID() {
      return (++lastAUTargetID).toString();
    }

    function makeIntoInstructionTarget(element) {
      var value = element.getAttribute('class');
      var auTargetID = getNextAUTargetID();

      element.setAttribute('class', value ? value + ' au-target' : 'au-target');
      element.setAttribute('au-target-id', auTargetID);

      return auTargetID;
    }

    function makeShadowSlot(compiler, resources, node, instructions, parentInjectorId) {
      var auShadowSlot = _aureliaPal.DOM.createElement('au-shadow-slot');
      _aureliaPal.DOM.replaceNode(auShadowSlot, node);

      var auTargetID = makeIntoInstructionTarget(auShadowSlot);
      var instruction = TargetInstruction.shadowSlot(parentInjectorId);

      instruction.slotName = node.getAttribute('name') || ShadowDOM.defaultSlotKey;
      instruction.slotDestination = node.getAttribute('slot');

      if (node.innerHTML.trim()) {
        var fragment = _aureliaPal.DOM.createDocumentFragment();
        var _child4 = void 0;

        while (_child4 = node.firstChild) {
          fragment.appendChild(_child4);
        }

        instruction.slotFallbackFactory = compiler.compile(fragment, resources);
      }

      instructions[auTargetID] = instruction;

      return auShadowSlot;
    }

    var ViewCompiler = exports.ViewCompiler = (_dec7 = (0, _aureliaDependencyInjection.inject)(BindingLanguage, ViewResources), _dec7(_class13 = function () {
      function ViewCompiler(bindingLanguage, resources) {

        this.bindingLanguage = bindingLanguage;
        this.resources = resources;
      }

      ViewCompiler.prototype.compile = function compile(source, resources, compileInstruction) {
        resources = resources || this.resources;
        compileInstruction = compileInstruction || ViewCompileInstruction.normal;
        source = typeof source === 'string' ? _aureliaPal.DOM.createTemplateFromMarkup(source) : source;

        var content = void 0;
        var part = void 0;
        var cacheSize = void 0;

        if (source.content) {
          part = source.getAttribute('part');
          cacheSize = source.getAttribute('view-cache');
          content = _aureliaPal.DOM.adoptNode(source.content);
        } else {
          content = source;
        }

        compileInstruction.targetShadowDOM = compileInstruction.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
        resources._invokeHook('beforeCompile', content, resources, compileInstruction);

        var instructions = {};
        this._compileNode(content, resources, instructions, source, 'root', !compileInstruction.targetShadowDOM);

        var firstChild = content.firstChild;
        if (firstChild && firstChild.nodeType === 1) {
          var targetId = firstChild.getAttribute('au-target-id');
          if (targetId) {
            var ins = instructions[targetId];

            if (ins.shadowSlot || ins.lifting || ins.elementInstruction && !ins.elementInstruction.anchorIsContainer) {
              content.insertBefore(_aureliaPal.DOM.createComment('view'), firstChild);
            }
          }
        }

        var factory = new ViewFactory(content, instructions, resources);

        factory.surrogateInstruction = compileInstruction.compileSurrogate ? this._compileSurrogate(source, resources) : null;
        factory.part = part;

        if (cacheSize) {
          factory.setCacheSize(cacheSize);
        }

        resources._invokeHook('afterCompile', factory);

        return factory;
      };

      ViewCompiler.prototype._compileNode = function _compileNode(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
        switch (node.nodeType) {
          case 1:
            return this._compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM);
          case 3:
            var expression = resources.getBindingLanguage(this.bindingLanguage).inspectTextContent(resources, node.wholeText);
            if (expression) {
              var marker = _aureliaPal.DOM.createElement('au-marker');
              var auTargetID = makeIntoInstructionTarget(marker);
              (node.parentNode || parentNode).insertBefore(marker, node);
              node.textContent = ' ';
              instructions[auTargetID] = TargetInstruction.contentExpression(expression);

              while (node.nextSibling && node.nextSibling.nodeType === 3) {
                (node.parentNode || parentNode).removeChild(node.nextSibling);
              }
            } else {
              while (node.nextSibling && node.nextSibling.nodeType === 3) {
                node = node.nextSibling;
              }
            }
            return node.nextSibling;
          case 11:
            var currentChild = node.firstChild;
            while (currentChild) {
              currentChild = this._compileNode(currentChild, resources, instructions, node, parentInjectorId, targetLightDOM);
            }
            break;
          default:
            break;
        }

        return node.nextSibling;
      };

      ViewCompiler.prototype._compileSurrogate = function _compileSurrogate(node, resources) {
        var tagName = node.tagName.toLowerCase();
        var attributes = node.attributes;
        var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
        var knownAttribute = void 0;
        var property = void 0;
        var instruction = void 0;
        var i = void 0;
        var ii = void 0;
        var attr = void 0;
        var attrName = void 0;
        var attrValue = void 0;
        var info = void 0;
        var type = void 0;
        var expressions = [];
        var expression = void 0;
        var behaviorInstructions = [];
        var values = {};
        var hasValues = false;
        var providers = [];

        for (i = 0, ii = attributes.length; i < ii; ++i) {
          attr = attributes[i];
          attrName = attr.name;
          attrValue = attr.value;

          info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);
          type = resources.getAttribute(info.attrName);

          if (type) {
            knownAttribute = resources.mapAttribute(info.attrName);
            if (knownAttribute) {
              property = type.attributes[knownAttribute];

              if (property) {
                info.defaultBindingMode = property.defaultBindingMode;

                if (!info.command && !info.expression) {
                  info.command = property.hasOptions ? 'options' : null;
                }

                if (info.command && info.command !== 'options' && type.primaryProperty) {
                  var primaryProperty = type.primaryProperty;
                  attrName = info.attrName = primaryProperty.name;

                  info.defaultBindingMode = primaryProperty.defaultBindingMode;
                }
              }
            }
          }

          instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);

          if (instruction) {
            if (instruction.alteredAttr) {
              type = resources.getAttribute(instruction.attrName);
            }

            if (instruction.discrete) {
              expressions.push(instruction);
            } else {
              if (type) {
                instruction.type = type;
                this._configureProperties(instruction, resources);

                if (type.liftsContent) {
                  throw new Error('You cannot place a template controller on a surrogate element.');
                } else {
                  behaviorInstructions.push(instruction);
                }
              } else {
                expressions.push(instruction.attributes[instruction.attrName]);
              }
            }
          } else {
            if (type) {
              instruction = BehaviorInstruction.attribute(attrName, type);
              instruction.attributes[resources.mapAttribute(attrName)] = attrValue;

              if (type.liftsContent) {
                throw new Error('You cannot place a template controller on a surrogate element.');
              } else {
                behaviorInstructions.push(instruction);
              }
            } else if (attrName !== 'id' && attrName !== 'part' && attrName !== 'replace-part') {
              hasValues = true;
              values[attrName] = attrValue;
            }
          }
        }

        if (expressions.length || behaviorInstructions.length || hasValues) {
          for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
            instruction = behaviorInstructions[i];
            instruction.type.compile(this, resources, node, instruction);
            providers.push(instruction.type.target);
          }

          for (i = 0, ii = expressions.length; i < ii; ++i) {
            expression = expressions[i];
            if (expression.attrToRemove !== undefined) {
              node.removeAttribute(expression.attrToRemove);
            }
          }

          return TargetInstruction.surrogate(providers, behaviorInstructions, expressions, values);
        }

        return null;
      };

      ViewCompiler.prototype._compileElement = function _compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
        var tagName = node.tagName.toLowerCase();
        var attributes = node.attributes;
        var expressions = [];
        var expression = void 0;
        var behaviorInstructions = [];
        var providers = [];
        var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
        var liftingInstruction = void 0;
        var viewFactory = void 0;
        var type = void 0;
        var elementInstruction = void 0;
        var elementProperty = void 0;
        var i = void 0;
        var ii = void 0;
        var attr = void 0;
        var attrName = void 0;
        var attrValue = void 0;
        var instruction = void 0;
        var info = void 0;
        var property = void 0;
        var knownAttribute = void 0;
        var auTargetID = void 0;
        var injectorId = void 0;

        if (tagName === 'slot') {
          if (targetLightDOM) {
            node = makeShadowSlot(this, resources, node, instructions, parentInjectorId);
          }
          return node.nextSibling;
        } else if (tagName === 'template') {
          viewFactory = this.compile(node, resources);
          viewFactory.part = node.getAttribute('part');
        } else {
          type = resources.getElement(node.getAttribute('as-element') || tagName);
          if (type) {
            elementInstruction = BehaviorInstruction.element(node, type);
            type.processAttributes(this, resources, node, attributes, elementInstruction);
            behaviorInstructions.push(elementInstruction);
          }
        }

        for (i = 0, ii = attributes.length; i < ii; ++i) {
          attr = attributes[i];
          attrName = attr.name;
          attrValue = attr.value;
          info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);

          if (targetLightDOM && info.attrName === 'slot') {
            info.attrName = attrName = 'au-slot';
          }

          type = resources.getAttribute(info.attrName);
          elementProperty = null;

          if (type) {
            knownAttribute = resources.mapAttribute(info.attrName);
            if (knownAttribute) {
              property = type.attributes[knownAttribute];

              if (property) {
                info.defaultBindingMode = property.defaultBindingMode;

                if (!info.command && !info.expression) {
                  info.command = property.hasOptions ? 'options' : null;
                }

                if (info.command && info.command !== 'options' && type.primaryProperty) {
                  var primaryProperty = type.primaryProperty;
                  attrName = info.attrName = primaryProperty.name;

                  info.defaultBindingMode = primaryProperty.defaultBindingMode;
                }
              }
            }
          } else if (elementInstruction) {
            elementProperty = elementInstruction.type.attributes[info.attrName];
            if (elementProperty) {
              info.defaultBindingMode = elementProperty.defaultBindingMode;
            }
          }

          if (elementProperty) {
            instruction = bindingLanguage.createAttributeInstruction(resources, node, info, elementInstruction);
          } else {
            instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);
          }

          if (instruction) {
            if (instruction.alteredAttr) {
              type = resources.getAttribute(instruction.attrName);
            }

            if (instruction.discrete) {
              expressions.push(instruction);
            } else {
              if (type) {
                instruction.type = type;
                this._configureProperties(instruction, resources);

                if (type.liftsContent) {
                  instruction.originalAttrName = attrName;
                  liftingInstruction = instruction;
                  break;
                } else {
                  behaviorInstructions.push(instruction);
                }
              } else if (elementProperty) {
                elementInstruction.attributes[info.attrName].targetProperty = elementProperty.name;
              } else {
                expressions.push(instruction.attributes[instruction.attrName]);
              }
            }
          } else {
            if (type) {
              instruction = BehaviorInstruction.attribute(attrName, type);
              instruction.attributes[resources.mapAttribute(attrName)] = attrValue;

              if (type.liftsContent) {
                instruction.originalAttrName = attrName;
                liftingInstruction = instruction;
                break;
              } else {
                behaviorInstructions.push(instruction);
              }
            } else if (elementProperty) {
              elementInstruction.attributes[attrName] = attrValue;
            }
          }
        }

        if (liftingInstruction) {
          liftingInstruction.viewFactory = viewFactory;
          node = liftingInstruction.type.compile(this, resources, node, liftingInstruction, parentNode);
          auTargetID = makeIntoInstructionTarget(node);
          instructions[auTargetID] = TargetInstruction.lifting(parentInjectorId, liftingInstruction);
        } else {
          if (expressions.length || behaviorInstructions.length) {
            injectorId = behaviorInstructions.length ? getNextInjectorId() : false;

            for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
              instruction = behaviorInstructions[i];
              instruction.type.compile(this, resources, node, instruction, parentNode);
              providers.push(instruction.type.target);
            }

            for (i = 0, ii = expressions.length; i < ii; ++i) {
              expression = expressions[i];
              if (expression.attrToRemove !== undefined) {
                node.removeAttribute(expression.attrToRemove);
              }
            }

            auTargetID = makeIntoInstructionTarget(node);
            instructions[auTargetID] = TargetInstruction.normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction);
          }

          if (elementInstruction && elementInstruction.skipContentProcessing) {
            return node.nextSibling;
          }

          var currentChild = node.firstChild;
          while (currentChild) {
            currentChild = this._compileNode(currentChild, resources, instructions, node, injectorId || parentInjectorId, targetLightDOM);
          }
        }

        return node.nextSibling;
      };

      ViewCompiler.prototype._configureProperties = function _configureProperties(instruction, resources) {
        var type = instruction.type;
        var attrName = instruction.attrName;
        var attributes = instruction.attributes;
        var property = void 0;
        var key = void 0;
        var value = void 0;

        var knownAttribute = resources.mapAttribute(attrName);
        if (knownAttribute && attrName in attributes && knownAttribute !== attrName) {
          attributes[knownAttribute] = attributes[attrName];
          delete attributes[attrName];
        }

        for (key in attributes) {
          value = attributes[key];

          if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
            property = type.attributes[key];

            if (property !== undefined) {
              value.targetProperty = property.name;
            } else {
              value.targetProperty = key;
            }
          }
        }
      };

      return ViewCompiler;
    }()) || _class13);

    var ResourceModule = exports.ResourceModule = function () {
      function ResourceModule(moduleId) {

        this.id = moduleId;
        this.moduleInstance = null;
        this.mainResource = null;
        this.resources = null;
        this.viewStrategy = null;
        this.isInitialized = false;
        this.onLoaded = null;
        this.loadContext = null;
      }

      ResourceModule.prototype.initialize = function initialize(container) {
        var current = this.mainResource;
        var resources = this.resources;
        var vs = this.viewStrategy;

        if (this.isInitialized) {
          return;
        }

        this.isInitialized = true;

        if (current !== undefined) {
          current.metadata.viewStrategy = vs;
          current.initialize(container);
        }

        for (var i = 0, ii = resources.length; i < ii; ++i) {
          current = resources[i];
          current.metadata.viewStrategy = vs;
          current.initialize(container);
        }
      };

      ResourceModule.prototype.register = function register(registry, name) {
        var main = this.mainResource;
        var resources = this.resources;

        if (main !== undefined) {
          main.register(registry, name);
          name = null;
        }

        for (var i = 0, ii = resources.length; i < ii; ++i) {
          resources[i].register(registry, name);
          name = null;
        }
      };

      ResourceModule.prototype.load = function load(container, loadContext) {
        if (this.onLoaded !== null) {
          return this.loadContext === loadContext ? Promise.resolve() : this.onLoaded;
        }

        var main = this.mainResource;
        var resources = this.resources;
        var loads = void 0;

        if (main !== undefined) {
          loads = new Array(resources.length + 1);
          loads[0] = main.load(container, loadContext);
          for (var i = 0, ii = resources.length; i < ii; ++i) {
            loads[i + 1] = resources[i].load(container, loadContext);
          }
        } else {
          loads = new Array(resources.length);
          for (var _i = 0, _ii = resources.length; _i < _ii; ++_i) {
            loads[_i] = resources[_i].load(container, loadContext);
          }
        }

        this.loadContext = loadContext;
        this.onLoaded = Promise.all(loads);
        return this.onLoaded;
      };

      return ResourceModule;
    }();

    var ResourceDescription = exports.ResourceDescription = function () {
      function ResourceDescription(key, exportedValue, resourceTypeMeta) {

        if (!resourceTypeMeta) {
          resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);

          if (!resourceTypeMeta) {
            resourceTypeMeta = new HtmlBehaviorResource();
            resourceTypeMeta.elementName = _hyphenate(key);
            _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, resourceTypeMeta, exportedValue);
          }
        }

        if (resourceTypeMeta instanceof HtmlBehaviorResource) {
          if (resourceTypeMeta.elementName === undefined) {
            resourceTypeMeta.elementName = _hyphenate(key);
          } else if (resourceTypeMeta.attributeName === undefined) {
            resourceTypeMeta.attributeName = _hyphenate(key);
          } else if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
            HtmlBehaviorResource.convention(key, resourceTypeMeta);
          }
        } else if (!resourceTypeMeta.name) {
          resourceTypeMeta.name = _hyphenate(key);
        }

        this.metadata = resourceTypeMeta;
        this.value = exportedValue;
      }

      ResourceDescription.prototype.initialize = function initialize(container) {
        this.metadata.initialize(container, this.value);
      };

      ResourceDescription.prototype.register = function register(registry, name) {
        this.metadata.register(registry, name);
      };

      ResourceDescription.prototype.load = function load(container, loadContext) {
        return this.metadata.load(container, this.value, loadContext);
      };

      return ResourceDescription;
    }();

    var ModuleAnalyzer = exports.ModuleAnalyzer = function () {
      function ModuleAnalyzer() {

        this.cache = Object.create(null);
      }

      ModuleAnalyzer.prototype.getAnalysis = function getAnalysis(moduleId) {
        return this.cache[moduleId];
      };

      ModuleAnalyzer.prototype.analyze = function analyze(moduleId, moduleInstance, mainResourceKey) {
        var mainResource = void 0;
        var fallbackValue = void 0;
        var fallbackKey = void 0;
        var resourceTypeMeta = void 0;
        var key = void 0;
        var exportedValue = void 0;
        var resources = [];
        var conventional = void 0;
        var vs = void 0;
        var resourceModule = void 0;

        resourceModule = this.cache[moduleId];
        if (resourceModule) {
          return resourceModule;
        }

        resourceModule = new ResourceModule(moduleId);
        this.cache[moduleId] = resourceModule;

        if (typeof moduleInstance === 'function') {
          moduleInstance = { 'default': moduleInstance };
        }

        if (mainResourceKey) {
          mainResource = new ResourceDescription(mainResourceKey, moduleInstance[mainResourceKey]);
        }

        for (key in moduleInstance) {
          exportedValue = moduleInstance[key];

          if (key === mainResourceKey || typeof exportedValue !== 'function') {
            continue;
          }

          resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);

          if (resourceTypeMeta) {
            if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
              HtmlBehaviorResource.convention(key, resourceTypeMeta);
            }

            if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
              resourceTypeMeta.elementName = _hyphenate(key);
            }

            if (!mainResource && resourceTypeMeta instanceof HtmlBehaviorResource && resourceTypeMeta.elementName !== null) {
              mainResource = new ResourceDescription(key, exportedValue, resourceTypeMeta);
            } else {
              resources.push(new ResourceDescription(key, exportedValue, resourceTypeMeta));
            }
          } else if (viewStrategy.decorates(exportedValue)) {
            vs = exportedValue;
          } else if (exportedValue instanceof _aureliaLoader.TemplateRegistryEntry) {
            vs = new TemplateRegistryViewStrategy(moduleId, exportedValue);
          } else {
            if (conventional = HtmlBehaviorResource.convention(key)) {
              if (conventional.elementName !== null && !mainResource) {
                mainResource = new ResourceDescription(key, exportedValue, conventional);
              } else {
                resources.push(new ResourceDescription(key, exportedValue, conventional));
              }

              _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
            } else if (conventional = _aureliaBinding.ValueConverterResource.convention(key) || _aureliaBinding.BindingBehaviorResource.convention(key) || ViewEngineHooksResource.convention(key)) {
              resources.push(new ResourceDescription(key, exportedValue, conventional));
              _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
            } else if (!fallbackValue) {
              fallbackValue = exportedValue;
              fallbackKey = key;
            }
          }
        }

        if (!mainResource && fallbackValue) {
          mainResource = new ResourceDescription(fallbackKey, fallbackValue);
        }

        resourceModule.moduleInstance = moduleInstance;
        resourceModule.mainResource = mainResource;
        resourceModule.resources = resources;
        resourceModule.viewStrategy = vs;

        return resourceModule;
      };

      return ModuleAnalyzer;
    }();

    var logger = LogManager.getLogger('templating');

    function ensureRegistryEntry(loader, urlOrRegistryEntry) {
      if (urlOrRegistryEntry instanceof _aureliaLoader.TemplateRegistryEntry) {
        return Promise.resolve(urlOrRegistryEntry);
      }

      return loader.loadTemplate(urlOrRegistryEntry);
    }

    var ProxyViewFactory = function () {
      function ProxyViewFactory(promise) {
        var _this9 = this;

        promise.then(function (x) {
          return _this9.viewFactory = x;
        });
      }

      ProxyViewFactory.prototype.create = function create(container, bindingContext, createInstruction, element) {
        return this.viewFactory.create(container, bindingContext, createInstruction, element);
      };

      ProxyViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
        this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
      };

      ProxyViewFactory.prototype.getCachedView = function getCachedView() {
        return this.viewFactory.getCachedView();
      };

      ProxyViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
        this.viewFactory.returnViewToCache(view);
      };

      _createClass(ProxyViewFactory, [{
        key: 'isCaching',
        get: function get() {
          return this.viewFactory.isCaching;
        }
      }]);

      return ProxyViewFactory;
    }();

    var ViewEngine = exports.ViewEngine = (_dec8 = (0, _aureliaDependencyInjection.inject)(_aureliaLoader.Loader, _aureliaDependencyInjection.Container, ViewCompiler, ModuleAnalyzer, ViewResources), _dec8(_class14 = (_temp4 = _class15 = function () {
      function ViewEngine(loader, container, viewCompiler, moduleAnalyzer, appResources) {

        this.loader = loader;
        this.container = container;
        this.viewCompiler = viewCompiler;
        this.moduleAnalyzer = moduleAnalyzer;
        this.appResources = appResources;
        this._pluginMap = {};

        var auSlotBehavior = new HtmlBehaviorResource();
        auSlotBehavior.attributeName = 'au-slot';
        auSlotBehavior.initialize(container, SlotCustomAttribute);
        auSlotBehavior.register(appResources);
      }

      ViewEngine.prototype.addResourcePlugin = function addResourcePlugin(extension, implementation) {
        var name = extension.replace('.', '') + '-resource-plugin';
        this._pluginMap[extension] = name;
        this.loader.addPlugin(name, implementation);
      };

      ViewEngine.prototype.loadViewFactory = function loadViewFactory(urlOrRegistryEntry, compileInstruction, loadContext, target) {
        var _this10 = this;

        loadContext = loadContext || new ResourceLoadContext();

        return ensureRegistryEntry(this.loader, urlOrRegistryEntry).then(function (registryEntry) {
          if (registryEntry.onReady) {
            if (!loadContext.hasDependency(urlOrRegistryEntry)) {
              loadContext.addDependency(urlOrRegistryEntry);
              return registryEntry.onReady;
            }

            if (registryEntry.template === null) {
              return registryEntry.onReady;
            }

            return Promise.resolve(new ProxyViewFactory(registryEntry.onReady));
          }

          loadContext.addDependency(urlOrRegistryEntry);

          registryEntry.onReady = _this10.loadTemplateResources(registryEntry, compileInstruction, loadContext, target).then(function (resources) {
            registryEntry.resources = resources;

            if (registryEntry.template === null) {
              return registryEntry.factory = null;
            }

            var viewFactory = _this10.viewCompiler.compile(registryEntry.template, resources, compileInstruction);
            return registryEntry.factory = viewFactory;
          });

          return registryEntry.onReady;
        });
      };

      ViewEngine.prototype.loadTemplateResources = function loadTemplateResources(registryEntry, compileInstruction, loadContext, target) {
        var resources = new ViewResources(this.appResources, registryEntry.address);
        var dependencies = registryEntry.dependencies;
        var importIds = void 0;
        var names = void 0;

        compileInstruction = compileInstruction || ViewCompileInstruction.normal;

        if (dependencies.length === 0 && !compileInstruction.associatedModuleId) {
          return Promise.resolve(resources);
        }

        importIds = dependencies.map(function (x) {
          return x.src;
        });
        names = dependencies.map(function (x) {
          return x.name;
        });
        logger.debug('importing resources for ' + registryEntry.address, importIds);

        if (target) {
          var viewModelRequires = _aureliaMetadata.metadata.get(ViewEngine.viewModelRequireMetadataKey, target);
          if (viewModelRequires) {
            var templateImportCount = importIds.length;
            for (var i = 0, ii = viewModelRequires.length; i < ii; ++i) {
              var req = viewModelRequires[i];
              var importId = typeof req === 'function' ? _aureliaMetadata.Origin.get(req).moduleId : (0, _aureliaPath.relativeToFile)(req.src || req, registryEntry.address);

              if (importIds.indexOf(importId) === -1) {
                importIds.push(importId);
                names.push(req.as);
              }
            }
            logger.debug('importing ViewModel resources for ' + compileInstruction.associatedModuleId, importIds.slice(templateImportCount));
          }
        }

        return this.importViewResources(importIds, names, resources, compileInstruction, loadContext);
      };

      ViewEngine.prototype.importViewModelResource = function importViewModelResource(moduleImport, moduleMember) {
        var _this11 = this;

        return this.loader.loadModule(moduleImport).then(function (viewModelModule) {
          var normalizedId = _aureliaMetadata.Origin.get(viewModelModule).moduleId;
          var resourceModule = _this11.moduleAnalyzer.analyze(normalizedId, viewModelModule, moduleMember);

          if (!resourceModule.mainResource) {
            throw new Error('No view model found in module "' + moduleImport + '".');
          }

          resourceModule.initialize(_this11.container);

          return resourceModule.mainResource;
        });
      };

      ViewEngine.prototype.importViewResources = function importViewResources(moduleIds, names, resources, compileInstruction, loadContext) {
        var _this12 = this;

        loadContext = loadContext || new ResourceLoadContext();
        compileInstruction = compileInstruction || ViewCompileInstruction.normal;

        moduleIds = moduleIds.map(function (x) {
          return _this12._applyLoaderPlugin(x);
        });

        return this.loader.loadAllModules(moduleIds).then(function (imports) {
          var i = void 0;
          var ii = void 0;
          var analysis = void 0;
          var normalizedId = void 0;
          var current = void 0;
          var associatedModule = void 0;
          var container = _this12.container;
          var moduleAnalyzer = _this12.moduleAnalyzer;
          var allAnalysis = new Array(imports.length);

          for (i = 0, ii = imports.length; i < ii; ++i) {
            current = imports[i];
            normalizedId = _aureliaMetadata.Origin.get(current).moduleId;

            analysis = moduleAnalyzer.analyze(normalizedId, current);
            analysis.initialize(container);
            analysis.register(resources, names[i]);

            allAnalysis[i] = analysis;
          }

          if (compileInstruction.associatedModuleId) {
            associatedModule = moduleAnalyzer.getAnalysis(compileInstruction.associatedModuleId);

            if (associatedModule) {
              associatedModule.register(resources);
            }
          }

          for (i = 0, ii = allAnalysis.length; i < ii; ++i) {
            allAnalysis[i] = allAnalysis[i].load(container, loadContext);
          }

          return Promise.all(allAnalysis).then(function () {
            return resources;
          });
        });
      };

      ViewEngine.prototype._applyLoaderPlugin = function _applyLoaderPlugin(id) {
        var index = id.lastIndexOf('.');
        if (index !== -1) {
          var ext = id.substring(index);
          var pluginName = this._pluginMap[ext];

          if (pluginName === undefined) {
            return id;
          }

          return this.loader.applyPluginToUrl(id, pluginName);
        }

        return id;
      };

      return ViewEngine;
    }(), _class15.viewModelRequireMetadataKey = 'aurelia:view-model-require', _temp4)) || _class14);

    var Controller = exports.Controller = function () {
      function Controller(behavior, instruction, viewModel, container) {

        this.behavior = behavior;
        this.instruction = instruction;
        this.viewModel = viewModel;
        this.isAttached = false;
        this.view = null;
        this.isBound = false;
        this.scope = null;
        this.container = container;
        this.elementEvents = container.elementEvents || null;

        var observerLookup = behavior.observerLocator.getOrCreateObserversLookup(viewModel);
        var handlesBind = behavior.handlesBind;
        var attributes = instruction.attributes;
        var boundProperties = this.boundProperties = [];
        var properties = behavior.properties;
        var i = void 0;
        var ii = void 0;

        behavior._ensurePropertiesDefined(viewModel, observerLookup);

        for (i = 0, ii = properties.length; i < ii; ++i) {
          properties[i]._initialize(viewModel, observerLookup, attributes, handlesBind, boundProperties);
        }
      }

      Controller.prototype.created = function created(owningView) {
        if (this.behavior.handlesCreated) {
          this.viewModel.created(owningView, this.view);
        }
      };

      Controller.prototype.automate = function automate(overrideContext, owningView) {
        this.view.bindingContext = this.viewModel;
        this.view.overrideContext = overrideContext || (0, _aureliaBinding.createOverrideContext)(this.viewModel);
        this.view._isUserControlled = true;

        if (this.behavior.handlesCreated) {
          this.viewModel.created(owningView || null, this.view);
        }

        this.bind(this.view);
      };

      Controller.prototype.bind = function bind(scope) {
        var skipSelfSubscriber = this.behavior.handlesBind;
        var boundProperties = this.boundProperties;
        var i = void 0;
        var ii = void 0;
        var x = void 0;
        var observer = void 0;
        var selfSubscriber = void 0;

        if (this.isBound) {
          if (this.scope === scope) {
            return;
          }

          this.unbind();
        }

        this.isBound = true;
        this.scope = scope;

        for (i = 0, ii = boundProperties.length; i < ii; ++i) {
          x = boundProperties[i];
          observer = x.observer;
          selfSubscriber = observer.selfSubscriber;
          observer.publishing = false;

          if (skipSelfSubscriber) {
            observer.selfSubscriber = null;
          }

          x.binding.bind(scope);
          observer.call();

          observer.publishing = true;
          observer.selfSubscriber = selfSubscriber;
        }

        var overrideContext = void 0;
        if (this.view !== null) {
          if (skipSelfSubscriber) {
            this.view.viewModelScope = scope;
          }

          if (this.viewModel === scope.overrideContext.bindingContext) {
            overrideContext = scope.overrideContext;
          } else if (this.instruction.inheritBindingContext) {
            overrideContext = (0, _aureliaBinding.createOverrideContext)(this.viewModel, scope.overrideContext);
          } else {
            overrideContext = (0, _aureliaBinding.createOverrideContext)(this.viewModel);
            overrideContext.__parentOverrideContext = scope.overrideContext;
          }

          this.view.bind(this.viewModel, overrideContext);
        } else if (skipSelfSubscriber) {
          overrideContext = scope.overrideContext;

          if (scope.overrideContext.__parentOverrideContext !== undefined && this.viewModel.viewFactory && this.viewModel.viewFactory.factoryCreateInstruction.partReplacements) {
            overrideContext = Object.assign({}, scope.overrideContext);
            overrideContext.parentOverrideContext = scope.overrideContext.__parentOverrideContext;
          }
          this.viewModel.bind(scope.bindingContext, overrideContext);
        }
      };

      Controller.prototype.unbind = function unbind() {
        if (this.isBound) {
          var _boundProperties = this.boundProperties;
          var _i2 = void 0;
          var _ii2 = void 0;

          this.isBound = false;
          this.scope = null;

          if (this.view !== null) {
            this.view.unbind();
          }

          if (this.behavior.handlesUnbind) {
            this.viewModel.unbind();
          }

          if (this.elementEvents !== null) {
            this.elementEvents.disposeAll();
          }

          for (_i2 = 0, _ii2 = _boundProperties.length; _i2 < _ii2; ++_i2) {
            _boundProperties[_i2].binding.unbind();
          }
        }
      };

      Controller.prototype.attached = function attached() {
        if (this.isAttached) {
          return;
        }

        this.isAttached = true;

        if (this.behavior.handlesAttached) {
          this.viewModel.attached();
        }

        if (this.view !== null) {
          this.view.attached();
        }
      };

      Controller.prototype.detached = function detached() {
        if (this.isAttached) {
          this.isAttached = false;

          if (this.view !== null) {
            this.view.detached();
          }

          if (this.behavior.handlesDetached) {
            this.viewModel.detached();
          }
        }
      };

      return Controller;
    }();

    var BehaviorPropertyObserver = exports.BehaviorPropertyObserver = (_dec9 = (0, _aureliaBinding.subscriberCollection)(), _dec9(_class16 = function () {
      function BehaviorPropertyObserver(taskQueue, obj, propertyName, selfSubscriber, initialValue) {

        this.taskQueue = taskQueue;
        this.obj = obj;
        this.propertyName = propertyName;
        this.notqueued = true;
        this.publishing = false;
        this.selfSubscriber = selfSubscriber;
        this.currentValue = this.oldValue = initialValue;
      }

      BehaviorPropertyObserver.prototype.getValue = function getValue() {
        return this.currentValue;
      };

      BehaviorPropertyObserver.prototype.setValue = function setValue(newValue) {
        var oldValue = this.currentValue;

        if (oldValue !== newValue) {
          this.oldValue = oldValue;
          this.currentValue = newValue;

          if (this.publishing && this.notqueued) {
            if (this.taskQueue.flushing) {
              this.call();
            } else {
              this.notqueued = false;
              this.taskQueue.queueMicroTask(this);
            }
          }
        }
      };

      BehaviorPropertyObserver.prototype.call = function call() {
        var oldValue = this.oldValue;
        var newValue = this.currentValue;

        this.notqueued = true;

        if (newValue === oldValue) {
          return;
        }

        if (this.selfSubscriber) {
          this.selfSubscriber(newValue, oldValue);
        }

        this.callSubscribers(newValue, oldValue);
        this.oldValue = newValue;
      };

      BehaviorPropertyObserver.prototype.subscribe = function subscribe(context, callable) {
        this.addSubscriber(context, callable);
      };

      BehaviorPropertyObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
        this.removeSubscriber(context, callable);
      };

      return BehaviorPropertyObserver;
    }()) || _class16);

    function getObserver(behavior, instance, name) {
      var lookup = instance.__observers__;

      if (lookup === undefined) {
        if (!behavior.isInitialized) {
          behavior.initialize(_aureliaDependencyInjection.Container.instance || new _aureliaDependencyInjection.Container(), instance.constructor);
        }

        lookup = behavior.observerLocator.getOrCreateObserversLookup(instance);
        behavior._ensurePropertiesDefined(instance, lookup);
      }

      return lookup[name];
    }

    var BindableProperty = exports.BindableProperty = function () {
      function BindableProperty(nameOrConfig) {

        if (typeof nameOrConfig === 'string') {
          this.name = nameOrConfig;
        } else {
          Object.assign(this, nameOrConfig);
        }

        this.attribute = this.attribute || _hyphenate(this.name);
        if (this.defaultBindingMode === null || this.defaultBindingMode === undefined) {
          this.defaultBindingMode = _aureliaBinding.bindingMode.oneWay;
        }
        this.changeHandler = this.changeHandler || null;
        this.owner = null;
        this.descriptor = null;
      }

      BindableProperty.prototype.registerWith = function registerWith(target, behavior, descriptor) {
        behavior.properties.push(this);
        behavior.attributes[this.attribute] = this;
        this.owner = behavior;

        if (descriptor) {
          this.descriptor = descriptor;
          return this._configureDescriptor(behavior, descriptor);
        }

        return undefined;
      };

      BindableProperty.prototype._configureDescriptor = function _configureDescriptor(behavior, descriptor) {
        var name = this.name;

        descriptor.configurable = true;
        descriptor.enumerable = true;

        if ('initializer' in descriptor) {
          this.defaultValue = descriptor.initializer;
          delete descriptor.initializer;
          delete descriptor.writable;
        }

        if ('value' in descriptor) {
          this.defaultValue = descriptor.value;
          delete descriptor.value;
          delete descriptor.writable;
        }

        descriptor.get = function () {
          return getObserver(behavior, this, name).getValue();
        };

        descriptor.set = function (value) {
          getObserver(behavior, this, name).setValue(value);
        };

        descriptor.get.getObserver = function (obj) {
          return getObserver(behavior, obj, name);
        };

        return descriptor;
      };

      BindableProperty.prototype.defineOn = function defineOn(target, behavior) {
        var name = this.name;
        var handlerName = void 0;

        if (this.changeHandler === null) {
          handlerName = name + 'Changed';
          if (handlerName in target.prototype) {
            this.changeHandler = handlerName;
          }
        }

        if (this.descriptor === null) {
          Object.defineProperty(target.prototype, name, this._configureDescriptor(behavior, {}));
        }
      };

      BindableProperty.prototype.createObserver = function createObserver(viewModel) {
        var selfSubscriber = null;
        var defaultValue = this.defaultValue;
        var changeHandlerName = this.changeHandler;
        var name = this.name;
        var initialValue = void 0;

        if (this.hasOptions) {
          return undefined;
        }

        if (changeHandlerName in viewModel) {
          if ('propertyChanged' in viewModel) {
            selfSubscriber = function selfSubscriber(newValue, oldValue) {
              viewModel[changeHandlerName](newValue, oldValue);
              viewModel.propertyChanged(name, newValue, oldValue);
            };
          } else {
            selfSubscriber = function selfSubscriber(newValue, oldValue) {
              return viewModel[changeHandlerName](newValue, oldValue);
            };
          }
        } else if ('propertyChanged' in viewModel) {
          selfSubscriber = function selfSubscriber(newValue, oldValue) {
            return viewModel.propertyChanged(name, newValue, oldValue);
          };
        } else if (changeHandlerName !== null) {
          throw new Error('Change handler ' + changeHandlerName + ' was specified but not declared on the class.');
        }

        if (defaultValue !== undefined) {
          initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;
        }

        return new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, this.name, selfSubscriber, initialValue);
      };

      BindableProperty.prototype._initialize = function _initialize(viewModel, observerLookup, attributes, behaviorHandlesBind, boundProperties) {
        var selfSubscriber = void 0;
        var observer = void 0;
        var attribute = void 0;
        var defaultValue = this.defaultValue;

        if (this.isDynamic) {
          for (var key in attributes) {
            this._createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, key, attributes[key], boundProperties);
          }
        } else if (!this.hasOptions) {
          observer = observerLookup[this.name];

          if (attributes !== null) {
            selfSubscriber = observer.selfSubscriber;
            attribute = attributes[this.attribute];

            if (behaviorHandlesBind) {
              observer.selfSubscriber = null;
            }

            if (typeof attribute === 'string') {
              viewModel[this.name] = attribute;
              observer.call();
            } else if (attribute) {
              boundProperties.push({ observer: observer, binding: attribute.createBinding(viewModel) });
            } else if (defaultValue !== undefined) {
              observer.call();
            }

            observer.selfSubscriber = selfSubscriber;
          }

          observer.publishing = true;
        }
      };

      BindableProperty.prototype._createDynamicProperty = function _createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, name, attribute, boundProperties) {
        var changeHandlerName = name + 'Changed';
        var selfSubscriber = null;
        var observer = void 0;
        var info = void 0;

        if (changeHandlerName in viewModel) {
          if ('propertyChanged' in viewModel) {
            selfSubscriber = function selfSubscriber(newValue, oldValue) {
              viewModel[changeHandlerName](newValue, oldValue);
              viewModel.propertyChanged(name, newValue, oldValue);
            };
          } else {
            selfSubscriber = function selfSubscriber(newValue, oldValue) {
              return viewModel[changeHandlerName](newValue, oldValue);
            };
          }
        } else if ('propertyChanged' in viewModel) {
          selfSubscriber = function selfSubscriber(newValue, oldValue) {
            return viewModel.propertyChanged(name, newValue, oldValue);
          };
        }

        observer = observerLookup[name] = new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, name, selfSubscriber);

        Object.defineProperty(viewModel, name, {
          configurable: true,
          enumerable: true,
          get: observer.getValue.bind(observer),
          set: observer.setValue.bind(observer)
        });

        if (behaviorHandlesBind) {
          observer.selfSubscriber = null;
        }

        if (typeof attribute === 'string') {
          viewModel[name] = attribute;
          observer.call();
        } else if (attribute) {
          info = { observer: observer, binding: attribute.createBinding(viewModel) };
          boundProperties.push(info);
        }

        observer.publishing = true;
        observer.selfSubscriber = selfSubscriber;
      };

      return BindableProperty;
    }();

    var lastProviderId = 0;

    function nextProviderId() {
      return ++lastProviderId;
    }

    function doProcessContent() {
      return true;
    }
    function doProcessAttributes() {}

    var HtmlBehaviorResource = exports.HtmlBehaviorResource = function () {
      function HtmlBehaviorResource() {

        this.elementName = null;
        this.attributeName = null;
        this.attributeDefaultBindingMode = undefined;
        this.liftsContent = false;
        this.targetShadowDOM = false;
        this.shadowDOMOptions = null;
        this.processAttributes = doProcessAttributes;
        this.processContent = doProcessContent;
        this.usesShadowDOM = false;
        this.childBindings = null;
        this.hasDynamicOptions = false;
        this.containerless = false;
        this.properties = [];
        this.attributes = {};
        this.isInitialized = false;
        this.primaryProperty = null;
      }

      HtmlBehaviorResource.convention = function convention(name, existing) {
        var behavior = void 0;

        if (name.endsWith('CustomAttribute')) {
          behavior = existing || new HtmlBehaviorResource();
          behavior.attributeName = _hyphenate(name.substring(0, name.length - 15));
        }

        if (name.endsWith('CustomElement')) {
          behavior = existing || new HtmlBehaviorResource();
          behavior.elementName = _hyphenate(name.substring(0, name.length - 13));
        }

        return behavior;
      };

      HtmlBehaviorResource.prototype.addChildBinding = function addChildBinding(behavior) {
        if (this.childBindings === null) {
          this.childBindings = [];
        }

        this.childBindings.push(behavior);
      };

      HtmlBehaviorResource.prototype.initialize = function initialize(container, target) {
        var proto = target.prototype;
        var properties = this.properties;
        var attributeName = this.attributeName;
        var attributeDefaultBindingMode = this.attributeDefaultBindingMode;
        var i = void 0;
        var ii = void 0;
        var current = void 0;

        if (this.isInitialized) {
          return;
        }

        this.isInitialized = true;
        target.__providerId__ = nextProviderId();

        this.observerLocator = container.get(_aureliaBinding.ObserverLocator);
        this.taskQueue = container.get(_aureliaTaskQueue.TaskQueue);

        this.target = target;
        this.usesShadowDOM = this.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
        this.handlesCreated = 'created' in proto;
        this.handlesBind = 'bind' in proto;
        this.handlesUnbind = 'unbind' in proto;
        this.handlesAttached = 'attached' in proto;
        this.handlesDetached = 'detached' in proto;
        this.htmlName = this.elementName || this.attributeName;

        if (attributeName !== null) {
          if (properties.length === 0) {
            new BindableProperty({
              name: 'value',
              changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
              attribute: attributeName,
              defaultBindingMode: attributeDefaultBindingMode
            }).registerWith(target, this);
          }

          current = properties[0];

          if (properties.length === 1 && current.name === 'value') {
            current.isDynamic = current.hasOptions = this.hasDynamicOptions;
            current.defineOn(target, this);
          } else {
            for (i = 0, ii = properties.length; i < ii; ++i) {
              properties[i].defineOn(target, this);
              if (properties[i].primaryProperty) {
                if (this.primaryProperty) {
                  throw new Error('Only one bindable property on a custom element can be defined as the default');
                }
                this.primaryProperty = properties[i];
              }
            }

            current = new BindableProperty({
              name: 'value',
              changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
              attribute: attributeName,
              defaultBindingMode: attributeDefaultBindingMode
            });

            current.hasOptions = true;
            current.registerWith(target, this);
          }
        } else {
          for (i = 0, ii = properties.length; i < ii; ++i) {
            properties[i].defineOn(target, this);
          }
        }
      };

      HtmlBehaviorResource.prototype.register = function register(registry, name) {
        var _this13 = this;

        if (this.attributeName !== null) {
          registry.registerAttribute(name || this.attributeName, this, this.attributeName);

          if (Array.isArray(this.aliases)) {
            this.aliases.forEach(function (alias) {
              registry.registerAttribute(alias, _this13, _this13.attributeName);
            });
          }
        }

        if (this.elementName !== null) {
          registry.registerElement(name || this.elementName, this);
        }
      };

      HtmlBehaviorResource.prototype.load = function load(container, target, loadContext, viewStrategy, transientView) {
        var _this14 = this;

        var options = void 0;

        if (this.elementName !== null) {
          viewStrategy = container.get(ViewLocator).getViewStrategy(viewStrategy || this.viewStrategy || target);
          options = new ViewCompileInstruction(this.targetShadowDOM, true);

          if (!viewStrategy.moduleId) {
            viewStrategy.moduleId = _aureliaMetadata.Origin.get(target).moduleId;
          }

          return viewStrategy.loadViewFactory(container.get(ViewEngine), options, loadContext, target).then(function (viewFactory) {
            if (!transientView || !_this14.viewFactory) {
              _this14.viewFactory = viewFactory;
            }

            return viewFactory;
          });
        }

        return Promise.resolve(this);
      };

      HtmlBehaviorResource.prototype.compile = function compile(compiler, resources, node, instruction, parentNode) {
        if (this.liftsContent) {
          if (!instruction.viewFactory) {
            var template = _aureliaPal.DOM.createElement('template');
            var fragment = _aureliaPal.DOM.createDocumentFragment();
            var cacheSize = node.getAttribute('view-cache');
            var part = node.getAttribute('part');

            node.removeAttribute(instruction.originalAttrName);
            _aureliaPal.DOM.replaceNode(template, node, parentNode);
            fragment.appendChild(node);
            instruction.viewFactory = compiler.compile(fragment, resources);

            if (part) {
              instruction.viewFactory.part = part;
              node.removeAttribute('part');
            }

            if (cacheSize) {
              instruction.viewFactory.setCacheSize(cacheSize);
              node.removeAttribute('view-cache');
            }

            node = template;
          }
        } else if (this.elementName !== null) {
          var _partReplacements2 = {};

          if (this.processContent(compiler, resources, node, instruction) && node.hasChildNodes()) {
            var currentChild = node.firstChild;
            var contentElement = this.usesShadowDOM ? null : _aureliaPal.DOM.createElement('au-content');
            var nextSibling = void 0;
            var toReplace = void 0;

            while (currentChild) {
              nextSibling = currentChild.nextSibling;

              if (currentChild.tagName === 'TEMPLATE' && (toReplace = currentChild.getAttribute('replace-part'))) {
                _partReplacements2[toReplace] = compiler.compile(currentChild, resources);
                _aureliaPal.DOM.removeNode(currentChild, parentNode);
                instruction.partReplacements = _partReplacements2;
              } else if (contentElement !== null) {
                if (currentChild.nodeType === 3 && _isAllWhitespace(currentChild)) {
                  _aureliaPal.DOM.removeNode(currentChild, parentNode);
                } else {
                  contentElement.appendChild(currentChild);
                }
              }

              currentChild = nextSibling;
            }

            if (contentElement !== null && contentElement.hasChildNodes()) {
              node.appendChild(contentElement);
            }

            instruction.skipContentProcessing = false;
          } else {
            instruction.skipContentProcessing = true;
          }
        }

        return node;
      };

      HtmlBehaviorResource.prototype.create = function create(container, instruction, element, bindings) {
        var viewHost = void 0;
        var au = null;

        instruction = instruction || BehaviorInstruction.normal;
        element = element || null;
        bindings = bindings || null;

        if (this.elementName !== null && element) {
          if (this.usesShadowDOM) {
            viewHost = element.attachShadow(this.shadowDOMOptions);
            container.registerInstance(_aureliaPal.DOM.boundary, viewHost);
          } else {
            viewHost = element;
            if (this.targetShadowDOM) {
              container.registerInstance(_aureliaPal.DOM.boundary, viewHost);
            }
          }
        }

        if (element !== null) {
          element.au = au = element.au || {};
        }

        var viewModel = instruction.viewModel || container.get(this.target);
        var controller = new Controller(this, instruction, viewModel, container);
        var childBindings = this.childBindings;
        var viewFactory = void 0;

        if (this.liftsContent) {
          au.controller = controller;
        } else if (this.elementName !== null) {
          viewFactory = instruction.viewFactory || this.viewFactory;
          container.viewModel = viewModel;

          if (viewFactory) {
            controller.view = viewFactory.create(container, instruction, element);
          }

          if (element !== null) {
            au.controller = controller;

            if (controller.view) {
              if (!this.usesShadowDOM && (element.childNodes.length === 1 || element.contentElement)) {
                var contentElement = element.childNodes[0] || element.contentElement;
                controller.view.contentView = { fragment: contentElement };
                contentElement.parentNode && _aureliaPal.DOM.removeNode(contentElement);
              }

              if (instruction.anchorIsContainer) {
                if (childBindings !== null) {
                  for (var _i3 = 0, _ii3 = childBindings.length; _i3 < _ii3; ++_i3) {
                    controller.view.addBinding(childBindings[_i3].create(element, viewModel, controller));
                  }
                }

                controller.view.appendNodesTo(viewHost);
              } else {
                controller.view.insertNodesBefore(viewHost);
              }
            } else if (childBindings !== null) {
              for (var _i4 = 0, _ii4 = childBindings.length; _i4 < _ii4; ++_i4) {
                bindings.push(childBindings[_i4].create(element, viewModel, controller));
              }
            }
          } else if (controller.view) {
            controller.view.controller = controller;

            if (childBindings !== null) {
              for (var _i5 = 0, _ii5 = childBindings.length; _i5 < _ii5; ++_i5) {
                controller.view.addBinding(childBindings[_i5].create(instruction.host, viewModel, controller));
              }
            }
          } else if (childBindings !== null) {
            for (var _i6 = 0, _ii6 = childBindings.length; _i6 < _ii6; ++_i6) {
              bindings.push(childBindings[_i6].create(instruction.host, viewModel, controller));
            }
          }
        } else if (childBindings !== null) {
          for (var _i7 = 0, _ii7 = childBindings.length; _i7 < _ii7; ++_i7) {
            bindings.push(childBindings[_i7].create(element, viewModel, controller));
          }
        }

        if (au !== null) {
          au[this.htmlName] = controller;
        }

        if (instruction.initiatedByBehavior && viewFactory) {
          controller.view.created();
        }

        return controller;
      };

      HtmlBehaviorResource.prototype._ensurePropertiesDefined = function _ensurePropertiesDefined(instance, lookup) {
        var properties = void 0;
        var i = void 0;
        var ii = void 0;
        var observer = void 0;

        if ('__propertiesDefined__' in lookup) {
          return;
        }

        lookup.__propertiesDefined__ = true;
        properties = this.properties;

        for (i = 0, ii = properties.length; i < ii; ++i) {
          observer = properties[i].createObserver(instance);

          if (observer !== undefined) {
            lookup[observer.propertyName] = observer;
          }
        }
      };

      return HtmlBehaviorResource;
    }();

    function createChildObserverDecorator(selectorOrConfig, all) {
      return function (target, key, descriptor) {
        var actualTarget = typeof key === 'string' ? target.constructor : target;
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);

        if (typeof selectorOrConfig === 'string') {
          selectorOrConfig = {
            selector: selectorOrConfig,
            name: key
          };
        }

        if (descriptor) {
          descriptor.writable = true;
          descriptor.configurable = true;
        }

        selectorOrConfig.all = all;
        r.addChildBinding(new ChildObserver(selectorOrConfig));
      };
    }

    function children(selectorOrConfig) {
      return createChildObserverDecorator(selectorOrConfig, true);
    }

    function child(selectorOrConfig) {
      return createChildObserverDecorator(selectorOrConfig, false);
    }

    var ChildObserver = function () {
      function ChildObserver(config) {

        this.name = config.name;
        this.changeHandler = config.changeHandler || this.name + 'Changed';
        this.selector = config.selector;
        this.all = config.all;
      }

      ChildObserver.prototype.create = function create(viewHost, viewModel, controller) {
        return new ChildObserverBinder(this.selector, viewHost, this.name, viewModel, controller, this.changeHandler, this.all);
      };

      return ChildObserver;
    }();

    var noMutations = [];

    function trackMutation(groupedMutations, binder, record) {
      var mutations = groupedMutations.get(binder);

      if (!mutations) {
        mutations = [];
        groupedMutations.set(binder, mutations);
      }

      mutations.push(record);
    }

    function onChildChange(mutations, observer) {
      var binders = observer.binders;
      var bindersLength = binders.length;
      var groupedMutations = new Map();

      for (var _i8 = 0, _ii8 = mutations.length; _i8 < _ii8; ++_i8) {
        var record = mutations[_i8];
        var added = record.addedNodes;
        var removed = record.removedNodes;

        for (var j = 0, jj = removed.length; j < jj; ++j) {
          var node = removed[j];
          if (node.nodeType === 1) {
            for (var k = 0; k < bindersLength; ++k) {
              var binder = binders[k];
              if (binder.onRemove(node)) {
                trackMutation(groupedMutations, binder, record);
              }
            }
          }
        }

        for (var _j = 0, _jj = added.length; _j < _jj; ++_j) {
          var _node = added[_j];
          if (_node.nodeType === 1) {
            for (var _k = 0; _k < bindersLength; ++_k) {
              var _binder = binders[_k];
              if (_binder.onAdd(_node)) {
                trackMutation(groupedMutations, _binder, record);
              }
            }
          }
        }
      }

      groupedMutations.forEach(function (value, key) {
        if (key.changeHandler !== null) {
          key.viewModel[key.changeHandler](value);
        }
      });
    }

    var ChildObserverBinder = function () {
      function ChildObserverBinder(selector, viewHost, property, viewModel, controller, changeHandler, all) {

        this.selector = selector;
        this.viewHost = viewHost;
        this.property = property;
        this.viewModel = viewModel;
        this.controller = controller;
        this.changeHandler = changeHandler in viewModel ? changeHandler : null;
        this.usesShadowDOM = controller.behavior.usesShadowDOM;
        this.all = all;

        if (!this.usesShadowDOM && controller.view && controller.view.contentView) {
          this.contentView = controller.view.contentView;
        } else {
          this.contentView = null;
        }
      }

      ChildObserverBinder.prototype.matches = function matches(element) {
        if (element.matches(this.selector)) {
          if (this.contentView === null) {
            return true;
          }

          var contentView = this.contentView;
          var assignedSlot = element.auAssignedSlot;

          if (assignedSlot && assignedSlot.projectFromAnchors) {
            var anchors = assignedSlot.projectFromAnchors;

            for (var _i9 = 0, _ii9 = anchors.length; _i9 < _ii9; ++_i9) {
              if (anchors[_i9].auOwnerView === contentView) {
                return true;
              }
            }

            return false;
          }

          return element.auOwnerView === contentView;
        }

        return false;
      };

      ChildObserverBinder.prototype.bind = function bind(source) {
        var viewHost = this.viewHost;
        var viewModel = this.viewModel;
        var observer = viewHost.__childObserver__;

        if (!observer) {
          observer = viewHost.__childObserver__ = _aureliaPal.DOM.createMutationObserver(onChildChange);

          var options = {
            childList: true,
            subtree: !this.usesShadowDOM
          };

          observer.observe(viewHost, options);
          observer.binders = [];
        }

        observer.binders.push(this);

        if (this.usesShadowDOM) {
          var current = viewHost.firstElementChild;

          if (this.all) {
            var items = viewModel[this.property];
            if (!items) {
              items = viewModel[this.property] = [];
            } else {
              items.length = 0;
            }

            while (current) {
              if (this.matches(current)) {
                items.push(current.au && current.au.controller ? current.au.controller.viewModel : current);
              }

              current = current.nextElementSibling;
            }

            if (this.changeHandler !== null) {
              this.viewModel[this.changeHandler](noMutations);
            }
          } else {
            while (current) {
              if (this.matches(current)) {
                var value = current.au && current.au.controller ? current.au.controller.viewModel : current;
                this.viewModel[this.property] = value;

                if (this.changeHandler !== null) {
                  this.viewModel[this.changeHandler](value);
                }

                break;
              }

              current = current.nextElementSibling;
            }
          }
        }
      };

      ChildObserverBinder.prototype.onRemove = function onRemove(element) {
        if (this.matches(element)) {
          var value = element.au && element.au.controller ? element.au.controller.viewModel : element;

          if (this.all) {
            var items = this.viewModel[this.property] || (this.viewModel[this.property] = []);
            var index = items.indexOf(value);

            if (index !== -1) {
              items.splice(index, 1);
            }

            return true;
          }

          return false;
        }

        return false;
      };

      ChildObserverBinder.prototype.onAdd = function onAdd(element) {
        if (this.matches(element)) {
          var value = element.au && element.au.controller ? element.au.controller.viewModel : element;

          if (this.all) {
            var items = this.viewModel[this.property] || (this.viewModel[this.property] = []);
            var index = 0;
            var prev = element.previousElementSibling;

            while (prev) {
              if (this.matches(prev)) {
                index++;
              }

              prev = prev.previousElementSibling;
            }

            items.splice(index, 0, value);
            return true;
          }

          this.viewModel[this.property] = value;

          if (this.changeHandler !== null) {
            this.viewModel[this.changeHandler](value);
          }
        }

        return false;
      };

      ChildObserverBinder.prototype.unbind = function unbind() {
        if (this.viewHost.__childObserver__) {
          this.viewHost.__childObserver__.disconnect();
          this.viewHost.__childObserver__ = null;
        }
      };

      return ChildObserverBinder;
    }();

    function remove(viewSlot, previous) {
      return Array.isArray(previous) ? viewSlot.removeMany(previous, true) : viewSlot.remove(previous, true);
    }

    var SwapStrategies = exports.SwapStrategies = {
      before: function before(viewSlot, previous, callback) {
        return previous === undefined ? callback() : callback().then(function () {
          return remove(viewSlot, previous);
        });
      },
      with: function _with(viewSlot, previous, callback) {
        return previous === undefined ? callback() : Promise.all([remove(viewSlot, previous), callback()]);
      },
      after: function after(viewSlot, previous, callback) {
        return Promise.resolve(viewSlot.removeAll(true)).then(callback);
      }
    };

    function tryActivateViewModel(context) {
      if (context.skipActivation || typeof context.viewModel.activate !== 'function') {
        return Promise.resolve();
      }

      return context.viewModel.activate(context.model) || Promise.resolve();
    }

    var CompositionEngine = exports.CompositionEngine = (_dec10 = (0, _aureliaDependencyInjection.inject)(ViewEngine, ViewLocator), _dec10(_class17 = function () {
      function CompositionEngine(viewEngine, viewLocator) {

        this.viewEngine = viewEngine;
        this.viewLocator = viewLocator;
      }

      CompositionEngine.prototype._swap = function _swap(context, view) {
        var swapStrategy = SwapStrategies[context.swapOrder] || SwapStrategies.after;
        var previousViews = context.viewSlot.children.slice();

        return swapStrategy(context.viewSlot, previousViews, function () {
          return Promise.resolve(context.viewSlot.add(view)).then(function () {
            if (context.currentController) {
              context.currentController.unbind();
            }
          });
        }).then(function () {
          if (context.compositionTransactionNotifier) {
            context.compositionTransactionNotifier.done();
          }
        });
      };

      CompositionEngine.prototype._createControllerAndSwap = function _createControllerAndSwap(context) {
        var _this15 = this;

        return this.createController(context).then(function (controller) {
          controller.automate(context.overrideContext, context.owningView);

          if (context.compositionTransactionOwnershipToken) {
            return context.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
              return _this15._swap(context, controller.view);
            }).then(function () {
              return controller;
            });
          }

          return _this15._swap(context, controller.view).then(function () {
            return controller;
          });
        });
      };

      CompositionEngine.prototype.createController = function createController(context) {
        var _this16 = this;

        var childContainer = void 0;
        var viewModel = void 0;
        var viewModelResource = void 0;
        var m = void 0;

        return this.ensureViewModel(context).then(tryActivateViewModel).then(function () {
          childContainer = context.childContainer;
          viewModel = context.viewModel;
          viewModelResource = context.viewModelResource;
          m = viewModelResource.metadata;

          var viewStrategy = _this16.viewLocator.getViewStrategy(context.view || viewModel);

          if (context.viewResources) {
            viewStrategy.makeRelativeTo(context.viewResources.viewUrl);
          }

          return m.load(childContainer, viewModelResource.value, null, viewStrategy, true);
        }).then(function (viewFactory) {
          return m.create(childContainer, BehaviorInstruction.dynamic(context.host, viewModel, viewFactory));
        });
      };

      CompositionEngine.prototype.ensureViewModel = function ensureViewModel(context) {
        var childContainer = context.childContainer = context.childContainer || context.container.createChild();

        if (typeof context.viewModel === 'string') {
          context.viewModel = context.viewResources ? context.viewResources.relativeToView(context.viewModel) : context.viewModel;

          return this.viewEngine.importViewModelResource(context.viewModel).then(function (viewModelResource) {
            childContainer.autoRegister(viewModelResource.value);

            if (context.host) {
              childContainer.registerInstance(_aureliaPal.DOM.Element, context.host);
            }

            context.viewModel = childContainer.viewModel = childContainer.get(viewModelResource.value);
            context.viewModelResource = viewModelResource;
            return context;
          });
        }

        var m = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, context.viewModel.constructor);
        m.elementName = m.elementName || 'dynamic-element';
        m.initialize(context.container || childContainer, context.viewModel.constructor);
        context.viewModelResource = { metadata: m, value: context.viewModel.constructor };
        childContainer.viewModel = context.viewModel;
        return Promise.resolve(context);
      };

      CompositionEngine.prototype.compose = function compose(context) {
        var _this17 = this;

        context.childContainer = context.childContainer || context.container.createChild();
        context.view = this.viewLocator.getViewStrategy(context.view);

        var transaction = context.childContainer.get(CompositionTransaction);
        var compositionTransactionOwnershipToken = transaction.tryCapture();

        if (compositionTransactionOwnershipToken) {
          context.compositionTransactionOwnershipToken = compositionTransactionOwnershipToken;
        } else {
          context.compositionTransactionNotifier = transaction.enlist();
        }

        if (context.viewModel) {
          return this._createControllerAndSwap(context);
        } else if (context.view) {
          if (context.viewResources) {
            context.view.makeRelativeTo(context.viewResources.viewUrl);
          }

          return context.view.loadViewFactory(this.viewEngine, new ViewCompileInstruction()).then(function (viewFactory) {
            var result = viewFactory.create(context.childContainer);
            result.bind(context.bindingContext, context.overrideContext);

            if (context.compositionTransactionOwnershipToken) {
              return context.compositionTransactionOwnershipToken.waitForCompositionComplete().then(function () {
                return _this17._swap(context, result);
              }).then(function () {
                return result;
              });
            }

            return _this17._swap(context, result).then(function () {
              return result;
            });
          });
        } else if (context.viewSlot) {
          context.viewSlot.removeAll();

          if (context.compositionTransactionNotifier) {
            context.compositionTransactionNotifier.done();
          }

          return Promise.resolve(null);
        }

        return Promise.resolve(null);
      };

      return CompositionEngine;
    }()) || _class17);

    var ElementConfigResource = exports.ElementConfigResource = function () {
      function ElementConfigResource() {}

      ElementConfigResource.prototype.initialize = function initialize(container, target) {};

      ElementConfigResource.prototype.register = function register(registry, name) {};

      ElementConfigResource.prototype.load = function load(container, target) {
        var config = new target();
        var eventManager = container.get(_aureliaBinding.EventManager);
        eventManager.registerElementConfig(config);
      };

      return ElementConfigResource;
    }();

    function validateBehaviorName(name, type) {
      if (/[A-Z]/.test(name)) {
        var newName = _hyphenate(name);
        LogManager.getLogger('templating').warn('\'' + name + '\' is not a valid ' + type + ' name and has been converted to \'' + newName + '\'. Upper-case letters are not allowed because the DOM is not case-sensitive.');
        return newName;
      }
      return name;
    }

    function resource(instance) {
      return function (target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, instance, target);
      };
    }

    function behavior(override) {
      return function (target) {
        if (override instanceof HtmlBehaviorResource) {
          _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, override, target);
        } else {
          var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
          Object.assign(r, override);
        }
      };
    }

    function customElement(name) {
      return function (target) {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
        r.elementName = validateBehaviorName(name, 'custom element');
      };
    }

    function customAttribute(name, defaultBindingMode, aliases) {
      return function (target) {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
        r.attributeName = validateBehaviorName(name, 'custom attribute');
        r.attributeDefaultBindingMode = defaultBindingMode;
        r.aliases = aliases;
      };
    }

    function templateController(target) {
      var deco = function deco(t) {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
        r.liftsContent = true;
      };

      return target ? deco(target) : deco;
    }

    function bindable(nameOrConfigOrTarget, key, descriptor) {
      var deco = function deco(target, key2, descriptor2) {
        var actualTarget = key2 ? target.constructor : target;
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);
        var prop = void 0;

        if (key2) {
          nameOrConfigOrTarget = nameOrConfigOrTarget || {};
          nameOrConfigOrTarget.name = key2;
        }

        prop = new BindableProperty(nameOrConfigOrTarget);
        return prop.registerWith(actualTarget, r, descriptor2);
      };

      if (!nameOrConfigOrTarget) {
        return deco;
      }

      if (key) {
        var _target = nameOrConfigOrTarget;
        nameOrConfigOrTarget = null;
        return deco(_target, key, descriptor);
      }

      return deco;
    }

    function dynamicOptions(target) {
      var deco = function deco(t) {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
        r.hasDynamicOptions = true;
      };

      return target ? deco(target) : deco;
    }

    var defaultShadowDOMOptions = { mode: 'open' };
    function useShadowDOM(targetOrOptions) {
      var options = typeof targetOrOptions === 'function' || !targetOrOptions ? defaultShadowDOMOptions : targetOrOptions;

      var deco = function deco(t) {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
        r.targetShadowDOM = true;
        r.shadowDOMOptions = options;
      };

      return typeof targetOrOptions === 'function' ? deco(targetOrOptions) : deco;
    }

    function processAttributes(processor) {
      return function (t) {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
        r.processAttributes = function (compiler, resources, node, attributes, elementInstruction) {
          try {
            processor(compiler, resources, node, attributes, elementInstruction);
          } catch (error) {
            LogManager.getLogger('templating').error(error);
          }
        };
      };
    }

    function doNotProcessContent() {
      return false;
    }

    function processContent(processor) {
      return function (t) {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
        r.processContent = processor ? function (compiler, resources, node, instruction) {
          try {
            return processor(compiler, resources, node, instruction);
          } catch (error) {
            LogManager.getLogger('templating').error(error);
            return false;
          }
        } : doNotProcessContent;
      };
    }

    function containerless(target) {
      var deco = function deco(t) {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
        r.containerless = true;
      };

      return target ? deco(target) : deco;
    }

    function useViewStrategy(strategy) {
      return function (target) {
        _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, strategy, target);
      };
    }

    function useView(path) {
      return useViewStrategy(new RelativeViewStrategy(path));
    }

    function inlineView(markup, dependencies, dependencyBaseUrl) {
      return useViewStrategy(new InlineViewStrategy(markup, dependencies, dependencyBaseUrl));
    }

    function noView(targetOrDependencies, dependencyBaseUrl) {
      var target = void 0;
      var dependencies = void 0;
      if (typeof targetOrDependencies === 'function') {
        target = targetOrDependencies;
      } else {
        dependencies = targetOrDependencies;
        target = undefined;
      }

      var deco = function deco(t) {
        _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, new NoViewStrategy(dependencies, dependencyBaseUrl), t);
      };

      return target ? deco(target) : deco;
    }

    function elementConfig(target) {
      var deco = function deco(t) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ElementConfigResource(), t);
      };

      return target ? deco(target) : deco;
    }

    function viewResources() {
      for (var _len = arguments.length, resources = Array(_len), _key = 0; _key < _len; _key++) {
        resources[_key] = arguments[_key];
      }

      return function (target) {
        _aureliaMetadata.metadata.define(ViewEngine.viewModelRequireMetadataKey, resources, target);
      };
    }

    var TemplatingEngine = exports.TemplatingEngine = (_dec11 = (0, _aureliaDependencyInjection.inject)(_aureliaDependencyInjection.Container, ModuleAnalyzer, ViewCompiler, CompositionEngine), _dec11(_class18 = function () {
      function TemplatingEngine(container, moduleAnalyzer, viewCompiler, compositionEngine) {

        this._container = container;
        this._moduleAnalyzer = moduleAnalyzer;
        this._viewCompiler = viewCompiler;
        this._compositionEngine = compositionEngine;
        container.registerInstance(Animator, Animator.instance = new Animator());
      }

      TemplatingEngine.prototype.configureAnimator = function configureAnimator(animator) {
        this._container.unregister(Animator);
        this._container.registerInstance(Animator, Animator.instance = animator);
      };

      TemplatingEngine.prototype.compose = function compose(context) {
        return this._compositionEngine.compose(context);
      };

      TemplatingEngine.prototype.enhance = function enhance(instruction) {
        if (instruction instanceof _aureliaPal.DOM.Element) {
          instruction = { element: instruction };
        }

        var compilerInstructions = {};
        var resources = instruction.resources || this._container.get(ViewResources);

        this._viewCompiler._compileNode(instruction.element, resources, compilerInstructions, instruction.element.parentNode, 'root', true);

        var factory = new ViewFactory(instruction.element, compilerInstructions, resources);
        var container = instruction.container || this._container.createChild();
        var view = factory.create(container, BehaviorInstruction.enhance());

        view.bind(instruction.bindingContext || {}, instruction.overrideContext);

        view.firstChild = view.lastChild = view.fragment;
        view.fragment = _aureliaPal.DOM.createDocumentFragment();
        view.attached();

        return view;
      };

      return TemplatingEngine;
    }()) || _class18);
  }).call($__exports, $__exports, $__require('aurelia-logging'), $__require('aurelia-metadata'), $__require('aurelia-pal'), $__require('aurelia-path'), $__require('aurelia-loader'), $__require('aurelia-dependency-injection'), $__require('aurelia-binding'), $__require('aurelia-task-queue'));
});
System.registerDynamic("npm:aurelia-loader@1.0.0.json", [], true, function() {
  return {
    "main": "aurelia-loader",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-loader@1.0.0/aurelia-loader.js', ['aurelia-path', 'aurelia-metadata'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaPath, _aureliaMetadata) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Loader = exports.TemplateRegistryEntry = exports.TemplateDependency = undefined;

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var TemplateDependency = exports.TemplateDependency = function TemplateDependency(src, name) {

      this.src = src;
      this.name = name;
    };

    var TemplateRegistryEntry = exports.TemplateRegistryEntry = function () {
      function TemplateRegistryEntry(address) {

        this.templateIsLoaded = false;
        this.factoryIsReady = false;
        this.resources = null;
        this.dependencies = null;

        this.address = address;
        this.onReady = null;
        this._template = null;
        this._factory = null;
      }

      TemplateRegistryEntry.prototype.addDependency = function addDependency(src, name) {
        var finalSrc = typeof src === 'string' ? (0, _aureliaPath.relativeToFile)(src, this.address) : _aureliaMetadata.Origin.get(src).moduleId;

        this.dependencies.push(new TemplateDependency(finalSrc, name));
      };

      _createClass(TemplateRegistryEntry, [{
        key: 'template',
        get: function get() {
          return this._template;
        },
        set: function set(value) {
          var address = this.address;
          var requires = void 0;
          var current = void 0;
          var src = void 0;
          var dependencies = void 0;

          this._template = value;
          this.templateIsLoaded = true;

          requires = value.content.querySelectorAll('require');
          dependencies = this.dependencies = new Array(requires.length);

          for (var i = 0, ii = requires.length; i < ii; ++i) {
            current = requires[i];
            src = current.getAttribute('from');

            if (!src) {
              throw new Error('<require> element in ' + address + ' has no "from" attribute.');
            }

            dependencies[i] = new TemplateDependency((0, _aureliaPath.relativeToFile)(src, address), current.getAttribute('as'));

            if (current.parentNode) {
              current.parentNode.removeChild(current);
            }
          }
        }
      }, {
        key: 'factory',
        get: function get() {
          return this._factory;
        },
        set: function set(value) {
          this._factory = value;
          this.factoryIsReady = true;
        }
      }]);

      return TemplateRegistryEntry;
    }();

    var Loader = exports.Loader = function () {
      function Loader() {

        this.templateRegistry = {};
      }

      Loader.prototype.map = function map(id, source) {
        throw new Error('Loaders must implement map(id, source).');
      };

      Loader.prototype.normalizeSync = function normalizeSync(moduleId, relativeTo) {
        throw new Error('Loaders must implement normalizeSync(moduleId, relativeTo).');
      };

      Loader.prototype.normalize = function normalize(moduleId, relativeTo) {
        throw new Error('Loaders must implement normalize(moduleId: string, relativeTo: string): Promise<string>.');
      };

      Loader.prototype.loadModule = function loadModule(id) {
        throw new Error('Loaders must implement loadModule(id).');
      };

      Loader.prototype.loadAllModules = function loadAllModules(ids) {
        throw new Error('Loader must implement loadAllModules(ids).');
      };

      Loader.prototype.loadTemplate = function loadTemplate(url) {
        throw new Error('Loader must implement loadTemplate(url).');
      };

      Loader.prototype.loadText = function loadText(url) {
        throw new Error('Loader must implement loadText(url).');
      };

      Loader.prototype.applyPluginToUrl = function applyPluginToUrl(url, pluginName) {
        throw new Error('Loader must implement applyPluginToUrl(url, pluginName).');
      };

      Loader.prototype.addPlugin = function addPlugin(pluginName, implementation) {
        throw new Error('Loader must implement addPlugin(pluginName, implementation).');
      };

      Loader.prototype.getOrCreateTemplateRegistryEntry = function getOrCreateTemplateRegistryEntry(address) {
        return this.templateRegistry[address] || (this.templateRegistry[address] = new TemplateRegistryEntry(address));
      };

      return Loader;
    }();
  }).call($__exports, $__exports, $__require('aurelia-path'), $__require('aurelia-metadata'));
});
System.registerDynamic("npm:aurelia-task-queue@1.2.0.json", [], true, function() {
  return {
    "main": "aurelia-task-queue",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-task-queue@1.2.0/aurelia-task-queue.js', ['aurelia-pal'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaPal) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TaskQueue = undefined;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };

    var hasSetImmediate = typeof setImmediate === 'function';
    var stackSeparator = '\nEnqueued in TaskQueue by:\n';
    var microStackSeparator = '\nEnqueued in MicroTaskQueue by:\n';

    function makeRequestFlushFromMutationObserver(flush) {
      var toggle = 1;
      var observer = _aureliaPal.DOM.createMutationObserver(flush);
      var node = _aureliaPal.DOM.createTextNode('');
      observer.observe(node, { characterData: true });
      return function requestFlush() {
        toggle = -toggle;
        node.data = toggle;
      };
    }

    function makeRequestFlushFromTimer(flush) {
      return function requestFlush() {
        var timeoutHandle = setTimeout(handleFlushTimer, 0);

        var intervalHandle = setInterval(handleFlushTimer, 50);
        function handleFlushTimer() {
          clearTimeout(timeoutHandle);
          clearInterval(intervalHandle);
          flush();
        }
      };
    }

    function onError(error, task, longStacks) {
      if (longStacks && task.stack && (typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object' && error !== null) {
        error.stack = filterFlushStack(error.stack) + task.stack;
      }

      if ('onError' in task) {
        task.onError(error);
      } else if (hasSetImmediate) {
        setImmediate(function () {
          throw error;
        });
      } else {
        setTimeout(function () {
          throw error;
        }, 0);
      }
    }

    var TaskQueue = exports.TaskQueue = function () {
      function TaskQueue() {
        var _this = this;

        this.flushing = false;
        this.longStacks = false;

        this.microTaskQueue = [];
        this.microTaskQueueCapacity = 1024;
        this.taskQueue = [];

        if (_aureliaPal.FEATURE.mutationObserver) {
          this.requestFlushMicroTaskQueue = makeRequestFlushFromMutationObserver(function () {
            return _this.flushMicroTaskQueue();
          });
        } else {
          this.requestFlushMicroTaskQueue = makeRequestFlushFromTimer(function () {
            return _this.flushMicroTaskQueue();
          });
        }

        this.requestFlushTaskQueue = makeRequestFlushFromTimer(function () {
          return _this.flushTaskQueue();
        });
      }

      TaskQueue.prototype.queueMicroTask = function queueMicroTask(task) {
        if (this.microTaskQueue.length < 1) {
          this.requestFlushMicroTaskQueue();
        }

        if (this.longStacks) {
          task.stack = this.prepareQueueStack(microStackSeparator);
        }
        this.microTaskQueue.push(task);
      };

      TaskQueue.prototype.queueTask = function queueTask(task) {
        if (this.taskQueue.length < 1) {
          this.requestFlushTaskQueue();
        }

        if (this.longStacks) {
          task.stack = this.prepareQueueStack(stackSeparator);
        }
        this.taskQueue.push(task);
      };

      TaskQueue.prototype.flushTaskQueue = function flushTaskQueue() {
        var queue = this.taskQueue;
        var index = 0;
        var task = void 0;

        this.taskQueue = [];

        try {
          this.flushing = true;
          while (index < queue.length) {
            task = queue[index];
            if (this.longStacks) {
              this.stack = typeof task.stack === 'string' ? task.stack : undefined;
            }
            task.call();
            index++;
          }
        } catch (error) {
          onError(error, task, this.longStacks);
        } finally {
          this.flushing = false;
        }
      };

      TaskQueue.prototype.flushMicroTaskQueue = function flushMicroTaskQueue() {
        var queue = this.microTaskQueue;
        var capacity = this.microTaskQueueCapacity;
        var index = 0;
        var task = void 0;

        try {
          this.flushing = true;
          while (index < queue.length) {
            task = queue[index];
            if (this.longStacks) {
              this.stack = typeof task.stack === 'string' ? task.stack : undefined;
            }
            task.call();
            index++;

            if (index > capacity) {
              for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
              }

              queue.length -= index;
              index = 0;
            }
          }
        } catch (error) {
          onError(error, task, this.longStacks);
        } finally {
          this.flushing = false;
        }

        queue.length = 0;
      };

      TaskQueue.prototype.prepareQueueStack = function prepareQueueStack(separator) {
        var stack = separator + filterQueueStack(captureStack());
        if (typeof this.stack === 'string') {
          stack = filterFlushStack(stack) + this.stack;
        }
        return stack;
      };

      return TaskQueue;
    }();

    function captureStack() {
      var error = new Error();

      if (error.stack) {
        return error.stack;
      }

      try {
        throw error;
      } catch (e) {
        return e.stack;
      }
    }

    function filterQueueStack(stack) {
      return stack.replace(/^[\s\S]*?\bqueue(Micro)?Task\b[^\n]*\n/, '');
    }

    function filterFlushStack(stack) {
      var index = stack.lastIndexOf('flushMicroTaskQueue');
      if (index < 0) {
        index = stack.lastIndexOf('flushTaskQueue');
        if (index < 0) {
          return stack;
        }
      }
      index = stack.lastIndexOf('\n', index);
      return index < 0 ? stack : stack.substr(0, index);
    }
  }).call($__exports, $__exports, $__require('aurelia-pal'));
});
System.registerDynamic("npm:aurelia-framework@1.1.2.json", [], true, function() {
  return {
    "main": "aurelia-framework",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-framework@1.1.2/aurelia-framework.js', ['aurelia-dependency-injection', 'aurelia-binding', 'aurelia-metadata', 'aurelia-templating', 'aurelia-loader', 'aurelia-task-queue', 'aurelia-path', 'aurelia-pal', 'aurelia-logging'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaDependencyInjection, _aureliaBinding, _aureliaMetadata, _aureliaTemplating, _aureliaLoader, _aureliaTaskQueue, _aureliaPath, _aureliaPal, _aureliaLogging) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LogManager = exports.FrameworkConfiguration = exports.Aurelia = undefined;
    Object.keys(_aureliaDependencyInjection).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _aureliaDependencyInjection[key];
        }
      });
    });
    Object.keys(_aureliaBinding).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _aureliaBinding[key];
        }
      });
    });
    Object.keys(_aureliaMetadata).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _aureliaMetadata[key];
        }
      });
    });
    Object.keys(_aureliaTemplating).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _aureliaTemplating[key];
        }
      });
    });
    Object.keys(_aureliaLoader).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _aureliaLoader[key];
        }
      });
    });
    Object.keys(_aureliaTaskQueue).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _aureliaTaskQueue[key];
        }
      });
    });
    Object.keys(_aureliaPath).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _aureliaPath[key];
        }
      });
    });
    Object.keys(_aureliaPal).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _aureliaPal[key];
        }
      });
    });

    var TheLogManager = _interopRequireWildcard(_aureliaLogging);

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};

        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }

        newObj.default = obj;
        return newObj;
      }
    }

    function preventActionlessFormSubmit() {
      _aureliaPal.DOM.addEventListener('submit', function (evt) {
        var target = evt.target;
        var action = target.action;

        if (target.tagName.toLowerCase() === 'form' && !action) {
          evt.preventDefault();
        }
      });
    }

    var Aurelia = exports.Aurelia = function () {
      function Aurelia(loader, container, resources) {

        this.loader = loader || new _aureliaPal.PLATFORM.Loader();
        this.container = container || new _aureliaDependencyInjection.Container().makeGlobal();
        this.resources = resources || new _aureliaTemplating.ViewResources();
        this.use = new FrameworkConfiguration(this);
        this.logger = TheLogManager.getLogger('aurelia');
        this.hostConfigured = false;
        this.host = null;

        this.use.instance(Aurelia, this);
        this.use.instance(_aureliaLoader.Loader, this.loader);
        this.use.instance(_aureliaTemplating.ViewResources, this.resources);
      }

      Aurelia.prototype.start = function start() {
        var _this = this;

        if (this._started) {
          return this._started;
        }

        this.logger.info('Aurelia Starting');
        return this._started = this.use.apply().then(function () {
          preventActionlessFormSubmit();

          if (!_this.container.hasResolver(_aureliaTemplating.BindingLanguage)) {
            var message = 'You must configure Aurelia with a BindingLanguage implementation.';
            _this.logger.error(message);
            throw new Error(message);
          }

          _this.logger.info('Aurelia Started');
          var evt = _aureliaPal.DOM.createCustomEvent('aurelia-started', { bubbles: true, cancelable: true });
          _aureliaPal.DOM.dispatchEvent(evt);
          return _this;
        });
      };

      Aurelia.prototype.enhance = function enhance() {
        var _this2 = this;

        var bindingContext = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var applicationHost = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

        this._configureHost(applicationHost || _aureliaPal.DOM.querySelectorAll('body')[0]);

        return new Promise(function (resolve) {
          var engine = _this2.container.get(_aureliaTemplating.TemplatingEngine);
          _this2.root = engine.enhance({ container: _this2.container, element: _this2.host, resources: _this2.resources, bindingContext: bindingContext });
          _this2.root.attached();
          _this2._onAureliaComposed();
          resolve(_this2);
        });
      };

      Aurelia.prototype.setRoot = function setRoot() {
        var _this3 = this;

        var root = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
        var applicationHost = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

        var instruction = {};

        if (this.root && this.root.viewModel && this.root.viewModel.router) {
          this.root.viewModel.router.deactivate();
          this.root.viewModel.router.reset();
        }

        this._configureHost(applicationHost);

        var engine = this.container.get(_aureliaTemplating.TemplatingEngine);
        var transaction = this.container.get(_aureliaTemplating.CompositionTransaction);
        delete transaction.initialComposition;

        if (!root) {
          if (this.configModuleId) {
            root = (0, _aureliaPath.relativeToFile)('./app', this.configModuleId);
          } else {
            root = 'app';
          }
        }

        instruction.viewModel = root;
        instruction.container = instruction.childContainer = this.container;
        instruction.viewSlot = this.hostSlot;
        instruction.host = this.host;

        return engine.compose(instruction).then(function (r) {
          _this3.root = r;
          instruction.viewSlot.attached();
          _this3._onAureliaComposed();
          return _this3;
        });
      };

      Aurelia.prototype._configureHost = function _configureHost(applicationHost) {
        if (this.hostConfigured) {
          return;
        }
        applicationHost = applicationHost || this.host;

        if (!applicationHost || typeof applicationHost === 'string') {
          this.host = _aureliaPal.DOM.getElementById(applicationHost || 'applicationHost');
        } else {
          this.host = applicationHost;
        }

        if (!this.host) {
          throw new Error('No applicationHost was specified.');
        }

        this.hostConfigured = true;
        this.host.aurelia = this;
        this.hostSlot = new _aureliaTemplating.ViewSlot(this.host, true);
        this.hostSlot.transformChildNodesIntoView();
        this.container.registerInstance(_aureliaPal.DOM.boundary, this.host);
      };

      Aurelia.prototype._onAureliaComposed = function _onAureliaComposed() {
        var evt = _aureliaPal.DOM.createCustomEvent('aurelia-composed', { bubbles: true, cancelable: true });
        setTimeout(function () {
          return _aureliaPal.DOM.dispatchEvent(evt);
        }, 1);
      };

      return Aurelia;
    }();

    var logger = TheLogManager.getLogger('aurelia');
    var extPattern = /\.[^/.]+$/;

    function runTasks(config, tasks) {
      var current = void 0;
      var next = function next() {
        current = tasks.shift();
        if (current) {
          return Promise.resolve(current(config)).then(next);
        }

        return Promise.resolve();
      };

      return next();
    }

    function loadPlugin(config, loader, info) {
      logger.debug('Loading plugin ' + info.moduleId + '.');
      config.resourcesRelativeTo = info.resourcesRelativeTo;

      var id = info.moduleId;

      if (info.resourcesRelativeTo.length > 1) {
        return loader.normalize(info.moduleId, info.resourcesRelativeTo[1]).then(function (normalizedId) {
          return _loadPlugin(normalizedId);
        });
      }

      return _loadPlugin(id);

      function _loadPlugin(moduleId) {
        return loader.loadModule(moduleId).then(function (m) {
          if ('configure' in m) {
            return Promise.resolve(m.configure(config, info.config || {})).then(function () {
              config.resourcesRelativeTo = null;
              logger.debug('Configured plugin ' + info.moduleId + '.');
            });
          }

          config.resourcesRelativeTo = null;
          logger.debug('Loaded plugin ' + info.moduleId + '.');
        });
      }
    }

    function loadResources(aurelia, resourcesToLoad, appResources) {
      var viewEngine = aurelia.container.get(_aureliaTemplating.ViewEngine);

      return Promise.all(Object.keys(resourcesToLoad).map(function (n) {
        return _normalize(resourcesToLoad[n]);
      })).then(function (loads) {
        var names = [];
        var importIds = [];

        loads.forEach(function (l) {
          names.push(undefined);
          importIds.push(l.importId);
        });

        return viewEngine.importViewResources(importIds, names, appResources);
      });

      function _normalize(load) {
        var moduleId = load.moduleId;
        var ext = getExt(moduleId);

        if (isOtherResource(moduleId)) {
          moduleId = removeExt(moduleId);
        }

        return aurelia.loader.normalize(moduleId, load.relativeTo).then(function (normalized) {
          return {
            name: load.moduleId,
            importId: isOtherResource(load.moduleId) ? addOriginalExt(normalized, ext) : normalized
          };
        });
      }

      function isOtherResource(name) {
        var ext = getExt(name);
        if (!ext) return false;
        if (ext === '') return false;
        if (ext === '.js' || ext === '.ts') return false;
        return true;
      }

      function removeExt(name) {
        return name.replace(extPattern, '');
      }

      function addOriginalExt(normalized, ext) {
        return removeExt(normalized) + '.' + ext;
      }
    }

    function getExt(name) {
      var match = name.match(extPattern);
      if (match && match.length > 0) {
        return match[0].split('.')[1];
      }
    }

    function assertProcessed(plugins) {
      if (plugins.processed) {
        throw new Error('This config instance has already been applied. To load more plugins or global resources, create a new FrameworkConfiguration instance.');
      }
    }

    var FrameworkConfiguration = function () {
      function FrameworkConfiguration(aurelia) {
        var _this4 = this;

        this.aurelia = aurelia;
        this.container = aurelia.container;
        this.info = [];
        this.processed = false;
        this.preTasks = [];
        this.postTasks = [];
        this.resourcesToLoad = {};
        this.preTask(function () {
          return aurelia.loader.normalize('aurelia-bootstrapper').then(function (name) {
            return _this4.bootstrapperName = name;
          });
        });
        this.postTask(function () {
          return loadResources(aurelia, _this4.resourcesToLoad, aurelia.resources);
        });
      }

      FrameworkConfiguration.prototype.instance = function instance(type, _instance) {
        this.container.registerInstance(type, _instance);
        return this;
      };

      FrameworkConfiguration.prototype.singleton = function singleton(type, implementation) {
        this.container.registerSingleton(type, implementation);
        return this;
      };

      FrameworkConfiguration.prototype.transient = function transient(type, implementation) {
        this.container.registerTransient(type, implementation);
        return this;
      };

      FrameworkConfiguration.prototype.preTask = function preTask(task) {
        assertProcessed(this);
        this.preTasks.push(task);
        return this;
      };

      FrameworkConfiguration.prototype.postTask = function postTask(task) {
        assertProcessed(this);
        this.postTasks.push(task);
        return this;
      };

      FrameworkConfiguration.prototype.feature = function feature(plugin) {
        var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        var hasIndex = /\/index$/i.test(plugin);
        var moduleId = hasIndex || getExt(plugin) ? plugin : plugin + '/index';
        var root = hasIndex ? plugin.substr(0, plugin.length - 6) : plugin;
        return this.plugin({ moduleId: moduleId, resourcesRelativeTo: [root, ''], config: config });
      };

      FrameworkConfiguration.prototype.globalResources = function globalResources(resources) {
        assertProcessed(this);

        var toAdd = Array.isArray(resources) ? resources : arguments;
        var resource = void 0;
        var resourcesRelativeTo = this.resourcesRelativeTo || ['', ''];

        for (var i = 0, ii = toAdd.length; i < ii; ++i) {
          resource = toAdd[i];
          if (typeof resource !== 'string') {
            throw new Error('Invalid resource path [' + resource + ']. Resources must be specified as relative module IDs.');
          }

          var parent = resourcesRelativeTo[0];
          var grandParent = resourcesRelativeTo[1];
          var name = resource;

          if ((resource.startsWith('./') || resource.startsWith('../')) && parent !== '') {
            name = (0, _aureliaPath.join)(parent, resource);
          }

          this.resourcesToLoad[name] = { moduleId: name, relativeTo: grandParent };
        }

        return this;
      };

      FrameworkConfiguration.prototype.globalName = function globalName(resourcePath, newName) {
        assertProcessed(this);
        this.resourcesToLoad[resourcePath] = { moduleId: newName, relativeTo: '' };
        return this;
      };

      FrameworkConfiguration.prototype.plugin = function plugin(_plugin, config) {
        assertProcessed(this);

        if (typeof _plugin === 'string') {
          return this.plugin({ moduleId: _plugin, resourcesRelativeTo: [_plugin, ''], config: config || {} });
        }

        this.info.push(_plugin);
        return this;
      };

      FrameworkConfiguration.prototype._addNormalizedPlugin = function _addNormalizedPlugin(name, config) {
        var _this5 = this;

        var plugin = { moduleId: name, resourcesRelativeTo: [name, ''], config: config || {} };
        this.plugin(plugin);

        this.preTask(function () {
          var relativeTo = [name, _this5.bootstrapperName];
          plugin.moduleId = name;
          plugin.resourcesRelativeTo = relativeTo;
          return Promise.resolve();
        });

        return this;
      };

      FrameworkConfiguration.prototype.defaultBindingLanguage = function defaultBindingLanguage() {
        return this._addNormalizedPlugin('aurelia-templating-binding');
      };

      FrameworkConfiguration.prototype.router = function router() {
        return this._addNormalizedPlugin('aurelia-templating-router');
      };

      FrameworkConfiguration.prototype.history = function history() {
        return this._addNormalizedPlugin('aurelia-history-browser');
      };

      FrameworkConfiguration.prototype.defaultResources = function defaultResources() {
        return this._addNormalizedPlugin('aurelia-templating-resources');
      };

      FrameworkConfiguration.prototype.eventAggregator = function eventAggregator() {
        return this._addNormalizedPlugin('aurelia-event-aggregator');
      };

      FrameworkConfiguration.prototype.basicConfiguration = function basicConfiguration() {
        return this.defaultBindingLanguage().defaultResources().eventAggregator();
      };

      FrameworkConfiguration.prototype.standardConfiguration = function standardConfiguration() {
        return this.basicConfiguration().history().router();
      };

      FrameworkConfiguration.prototype.developmentLogging = function developmentLogging() {
        var _this6 = this;

        this.preTask(function () {
          return _this6.aurelia.loader.normalize('aurelia-logging-console', _this6.bootstrapperName).then(function (name) {
            return _this6.aurelia.loader.loadModule(name).then(function (m) {
              TheLogManager.addAppender(new m.ConsoleAppender());
              TheLogManager.setLevel(TheLogManager.logLevel.debug);
            });
          });
        });

        return this;
      };

      FrameworkConfiguration.prototype.apply = function apply() {
        var _this7 = this;

        if (this.processed) {
          return Promise.resolve();
        }

        return runTasks(this, this.preTasks).then(function () {
          var loader = _this7.aurelia.loader;
          var info = _this7.info;
          var current = void 0;

          var next = function next() {
            current = info.shift();
            if (current) {
              return loadPlugin(_this7, loader, current).then(next);
            }

            _this7.processed = true;
            return Promise.resolve();
          };

          return next().then(function () {
            return runTasks(_this7, _this7.postTasks);
          });
        });
      };

      return FrameworkConfiguration;
    }();

    exports.FrameworkConfiguration = FrameworkConfiguration;
    var LogManager = exports.LogManager = TheLogManager;
  }).call($__exports, $__exports, $__require('aurelia-dependency-injection'), $__require('aurelia-binding'), $__require('aurelia-metadata'), $__require('aurelia-templating'), $__require('aurelia-loader'), $__require('aurelia-task-queue'), $__require('aurelia-path'), $__require('aurelia-pal'), $__require('aurelia-logging'));
});
System.registerDynamic("npm:aurelia-path@1.1.1.json", [], true, function() {
  return {
    "main": "aurelia-path",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-path@1.1.1/aurelia-path.js', [], false, function ($__require, $__exports, $__module) {
  return (function (exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.relativeToFile = relativeToFile;
    exports.join = join;
    exports.buildQueryString = buildQueryString;
    exports.parseQueryString = parseQueryString;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };

    function trimDots(ary) {
      for (var i = 0; i < ary.length; ++i) {
        var part = ary[i];
        if (part === '.') {
          ary.splice(i, 1);
          i -= 1;
        } else if (part === '..') {
          if (i === 0 || i === 1 && ary[2] === '..' || ary[i - 1] === '..') {
            continue;
          } else if (i > 0) {
            ary.splice(i - 1, 2);
            i -= 2;
          }
        }
      }
    }

    function relativeToFile(name, file) {
      var fileParts = file && file.split('/');
      var nameParts = name.trim().split('/');

      if (nameParts[0].charAt(0) === '.' && fileParts) {
        var normalizedBaseParts = fileParts.slice(0, fileParts.length - 1);
        nameParts.unshift.apply(nameParts, normalizedBaseParts);
      }

      trimDots(nameParts);

      return nameParts.join('/');
    }

    function join(path1, path2) {
      if (!path1) {
        return path2;
      }

      if (!path2) {
        return path1;
      }

      var schemeMatch = path1.match(/^([^/]*?:)\//);
      var scheme = schemeMatch && schemeMatch.length > 0 ? schemeMatch[1] : '';
      path1 = path1.substr(scheme.length);

      var urlPrefix = void 0;
      if (path1.indexOf('///') === 0 && scheme === 'file:') {
        urlPrefix = '///';
      } else if (path1.indexOf('//') === 0) {
        urlPrefix = '//';
      } else if (path1.indexOf('/') === 0) {
        urlPrefix = '/';
      } else {
        urlPrefix = '';
      }

      var trailingSlash = path2.slice(-1) === '/' ? '/' : '';

      var url1 = path1.split('/');
      var url2 = path2.split('/');
      var url3 = [];

      for (var i = 0, ii = url1.length; i < ii; ++i) {
        if (url1[i] === '..') {
          url3.pop();
        } else if (url1[i] === '.' || url1[i] === '') {
          continue;
        } else {
          url3.push(url1[i]);
        }
      }

      for (var _i = 0, _ii = url2.length; _i < _ii; ++_i) {
        if (url2[_i] === '..') {
          url3.pop();
        } else if (url2[_i] === '.' || url2[_i] === '') {
          continue;
        } else {
          url3.push(url2[_i]);
        }
      }

      return scheme + urlPrefix + url3.join('/') + trailingSlash;
    }

    var encode = encodeURIComponent;
    var encodeKey = function encodeKey(k) {
      return encode(k).replace('%24', '$');
    };

    function buildParam(key, value, traditional) {
      var result = [];
      if (value === null || value === undefined) {
        return result;
      }
      if (Array.isArray(value)) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (traditional) {
            result.push(encodeKey(key) + '=' + encode(value[i]));
          } else {
            var arrayKey = key + '[' + (_typeof(value[i]) === 'object' && value[i] !== null ? i : '') + ']';
            result = result.concat(buildParam(arrayKey, value[i]));
          }
        }
      } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !traditional) {
        for (var propertyName in value) {
          result = result.concat(buildParam(key + '[' + propertyName + ']', value[propertyName]));
        }
      } else {
        result.push(encodeKey(key) + '=' + encode(value));
      }
      return result;
    }

    function buildQueryString(params, traditional) {
      var pairs = [];
      var keys = Object.keys(params || {}).sort();
      for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        pairs = pairs.concat(buildParam(key, params[key], traditional));
      }

      if (pairs.length === 0) {
        return '';
      }

      return pairs.join('&');
    }

    function processScalarParam(existedParam, value) {
      if (Array.isArray(existedParam)) {
        existedParam.push(value);
        return existedParam;
      }
      if (existedParam !== undefined) {
        return [existedParam, value];
      }

      return value;
    }

    function parseComplexParam(queryParams, keys, value) {
      var currentParams = queryParams;
      var keysLastIndex = keys.length - 1;
      for (var j = 0; j <= keysLastIndex; j++) {
        var key = keys[j] === '' ? currentParams.length : keys[j];
        if (j < keysLastIndex) {
          var prevValue = !currentParams[key] || _typeof(currentParams[key]) === 'object' ? currentParams[key] : [currentParams[key]];
          currentParams = currentParams[key] = prevValue || (isNaN(keys[j + 1]) ? {} : []);
        } else {
          currentParams = currentParams[key] = value;
        }
      }
    }

    function parseQueryString(queryString) {
      var queryParams = {};
      if (!queryString || typeof queryString !== 'string') {
        return queryParams;
      }

      var query = queryString;
      if (query.charAt(0) === '?') {
        query = query.substr(1);
      }

      var pairs = query.replace(/\+/g, ' ').split('&');
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i].split('=');
        var key = decodeURIComponent(pair[0]);
        if (!key) {
          continue;
        }

        var keys = key.split('][');
        var keysLastIndex = keys.length - 1;

        if (/\[/.test(keys[0]) && /\]$/.test(keys[keysLastIndex])) {
          keys[keysLastIndex] = keys[keysLastIndex].replace(/\]$/, '');
          keys = keys.shift().split('[').concat(keys);
          keysLastIndex = keys.length - 1;
        } else {
          keysLastIndex = 0;
        }

        if (pair.length >= 2) {
          var value = pair[1] ? decodeURIComponent(pair[1]) : '';
          if (keysLastIndex) {
            parseComplexParam(queryParams, keys, value);
          } else {
            queryParams[key] = processScalarParam(queryParams[key], value);
          }
        } else {
          queryParams[key] = true;
        }
      }
      return queryParams;
    }
  }).call($__exports, $__exports, $__require);
});
System.registerDynamic("npm:aurelia-route-recognizer@1.1.0.json", [], true, function() {
  return {
    "main": "aurelia-route-recognizer",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-route-recognizer@1.1.0/aurelia-route-recognizer.js', ['aurelia-path'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaPath) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RouteRecognizer = exports.EpsilonSegment = exports.StarSegment = exports.DynamicSegment = exports.StaticSegment = exports.State = undefined;

    var State = exports.State = function () {
      function State(charSpec) {

        this.charSpec = charSpec;
        this.nextStates = [];
      }

      State.prototype.get = function get(charSpec) {
        for (var _iterator = this.nextStates, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var child = _ref;

          var isEqual = child.charSpec.validChars === charSpec.validChars && child.charSpec.invalidChars === charSpec.invalidChars;

          if (isEqual) {
            return child;
          }
        }

        return undefined;
      };

      State.prototype.put = function put(charSpec) {
        var state = this.get(charSpec);

        if (state) {
          return state;
        }

        state = new State(charSpec);

        this.nextStates.push(state);

        if (charSpec.repeat) {
          state.nextStates.push(state);
        }

        return state;
      };

      State.prototype.match = function match(ch) {
        var nextStates = this.nextStates;
        var results = [];

        for (var i = 0, l = nextStates.length; i < l; i++) {
          var child = nextStates[i];
          var charSpec = child.charSpec;

          if (charSpec.validChars !== undefined) {
            if (charSpec.validChars.indexOf(ch) !== -1) {
              results.push(child);
            }
          } else if (charSpec.invalidChars !== undefined) {
            if (charSpec.invalidChars.indexOf(ch) === -1) {
              results.push(child);
            }
          }
        }

        return results;
      };

      return State;
    }();

    var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];

    var escapeRegex = new RegExp('(\\' + specials.join('|\\') + ')', 'g');

    var StaticSegment = exports.StaticSegment = function () {
      function StaticSegment(string, caseSensitive) {

        this.string = string;
        this.caseSensitive = caseSensitive;
      }

      StaticSegment.prototype.eachChar = function eachChar(callback) {
        var s = this.string;
        for (var i = 0, ii = s.length; i < ii; ++i) {
          var ch = s[i];
          callback({ validChars: this.caseSensitive ? ch : ch.toUpperCase() + ch.toLowerCase() });
        }
      };

      StaticSegment.prototype.regex = function regex() {
        return this.string.replace(escapeRegex, '\\$1');
      };

      StaticSegment.prototype.generate = function generate() {
        return this.string;
      };

      return StaticSegment;
    }();

    var DynamicSegment = exports.DynamicSegment = function () {
      function DynamicSegment(name, optional) {

        this.name = name;
        this.optional = optional;
      }

      DynamicSegment.prototype.eachChar = function eachChar(callback) {
        callback({ invalidChars: '/', repeat: true });
      };

      DynamicSegment.prototype.regex = function regex() {
        return this.optional ? '([^/]+)?' : '([^/]+)';
      };

      DynamicSegment.prototype.generate = function generate(params, consumed) {
        consumed[this.name] = true;
        return params[this.name];
      };

      return DynamicSegment;
    }();

    var StarSegment = exports.StarSegment = function () {
      function StarSegment(name) {

        this.name = name;
      }

      StarSegment.prototype.eachChar = function eachChar(callback) {
        callback({ invalidChars: '', repeat: true });
      };

      StarSegment.prototype.regex = function regex() {
        return '(.+)';
      };

      StarSegment.prototype.generate = function generate(params, consumed) {
        consumed[this.name] = true;
        return params[this.name];
      };

      return StarSegment;
    }();

    var EpsilonSegment = exports.EpsilonSegment = function () {
      function EpsilonSegment() {}

      EpsilonSegment.prototype.eachChar = function eachChar() {};

      EpsilonSegment.prototype.regex = function regex() {
        return '';
      };

      EpsilonSegment.prototype.generate = function generate() {
        return '';
      };

      return EpsilonSegment;
    }();

    var RouteRecognizer = exports.RouteRecognizer = function () {
      function RouteRecognizer() {

        this.rootState = new State();
        this.names = {};
      }

      RouteRecognizer.prototype.add = function add(route) {
        var _this = this;

        if (Array.isArray(route)) {
          route.forEach(function (r) {
            return _this.add(r);
          });
          return undefined;
        }

        var currentState = this.rootState;
        var regex = '^';
        var types = { statics: 0, dynamics: 0, stars: 0 };
        var names = [];
        var routeName = route.handler.name;
        var isEmpty = true;
        var isAllOptional = true;
        var segments = parse(route.path, names, types, route.caseSensitive);

        for (var i = 0, ii = segments.length; i < ii; i++) {
          var segment = segments[i];
          if (segment instanceof EpsilonSegment) {
            continue;
          }

          isEmpty = false;
          isAllOptional = isAllOptional && segment.optional;

          currentState = addSegment(currentState, segment);
          regex += segment.optional ? '/?' : '/';
          regex += segment.regex();
        }

        if (isAllOptional) {
          if (isEmpty) {
            currentState = currentState.put({ validChars: '/' });
            regex += '/';
          } else {
            var finalState = this.rootState.put({ validChars: '/' });
            currentState.epsilon = [finalState];
            currentState = finalState;
          }
        }

        var handlers = [{ handler: route.handler, names: names }];

        if (routeName) {
          var routeNames = Array.isArray(routeName) ? routeName : [routeName];
          for (var _i2 = 0; _i2 < routeNames.length; _i2++) {
            this.names[routeNames[_i2]] = {
              segments: segments,
              handlers: handlers
            };
          }
        }

        currentState.handlers = handlers;
        currentState.regex = new RegExp(regex + '$', route.caseSensitive ? '' : 'i');
        currentState.types = types;

        return currentState;
      };

      RouteRecognizer.prototype.handlersFor = function handlersFor(name) {
        var route = this.names[name];
        if (!route) {
          throw new Error('There is no route named ' + name);
        }

        return [].concat(route.handlers);
      };

      RouteRecognizer.prototype.hasRoute = function hasRoute(name) {
        return !!this.names[name];
      };

      RouteRecognizer.prototype.generate = function generate(name, params) {
        var route = this.names[name];
        if (!route) {
          throw new Error('There is no route named ' + name);
        }

        var handler = route.handlers[0].handler;
        if (handler.generationUsesHref) {
          return handler.href;
        }

        var routeParams = Object.assign({}, params);
        var segments = route.segments;
        var consumed = {};
        var output = '';

        for (var i = 0, l = segments.length; i < l; i++) {
          var segment = segments[i];

          if (segment instanceof EpsilonSegment) {
            continue;
          }

          var segmentValue = segment.generate(routeParams, consumed);
          if (segmentValue === null || segmentValue === undefined) {
            if (!segment.optional) {
              throw new Error('A value is required for route parameter \'' + segment.name + '\' in route \'' + name + '\'.');
            }
          } else {
            output += '/';
            output += segmentValue;
          }
        }

        if (output.charAt(0) !== '/') {
          output = '/' + output;
        }

        for (var param in consumed) {
          delete routeParams[param];
        }

        var queryString = (0, _aureliaPath.buildQueryString)(routeParams);
        output += queryString ? '?' + queryString : '';

        return output;
      };

      RouteRecognizer.prototype.recognize = function recognize(path) {
        var states = [this.rootState];
        var queryParams = {};
        var isSlashDropped = false;
        var normalizedPath = path;

        var queryStart = normalizedPath.indexOf('?');
        if (queryStart !== -1) {
          var queryString = normalizedPath.substr(queryStart + 1, normalizedPath.length);
          normalizedPath = normalizedPath.substr(0, queryStart);
          queryParams = (0, _aureliaPath.parseQueryString)(queryString);
        }

        normalizedPath = decodeURI(normalizedPath);

        if (normalizedPath.charAt(0) !== '/') {
          normalizedPath = '/' + normalizedPath;
        }

        var pathLen = normalizedPath.length;
        if (pathLen > 1 && normalizedPath.charAt(pathLen - 1) === '/') {
          normalizedPath = normalizedPath.substr(0, pathLen - 1);
          isSlashDropped = true;
        }

        for (var i = 0, l = normalizedPath.length; i < l; i++) {
          states = recognizeChar(states, normalizedPath.charAt(i));
          if (!states.length) {
            break;
          }
        }

        var solutions = [];
        for (var _i3 = 0, _l = states.length; _i3 < _l; _i3++) {
          if (states[_i3].handlers) {
            solutions.push(states[_i3]);
          }
        }

        states = sortSolutions(solutions);

        var state = solutions[0];
        if (state && state.handlers) {
          if (isSlashDropped && state.regex.source.slice(-5) === '(.+)$') {
            normalizedPath = normalizedPath + '/';
          }

          return findHandler(state, normalizedPath, queryParams);
        }

        return undefined;
      };

      return RouteRecognizer;
    }();

    var RecognizeResults = function RecognizeResults(queryParams) {

      this.splice = Array.prototype.splice;
      this.slice = Array.prototype.slice;
      this.push = Array.prototype.push;
      this.length = 0;
      this.queryParams = queryParams || {};
    };

    function parse(route, names, types, caseSensitive) {
      var normalizedRoute = route;
      if (route.charAt(0) === '/') {
        normalizedRoute = route.substr(1);
      }

      var results = [];

      var splitRoute = normalizedRoute.split('/');
      for (var i = 0, ii = splitRoute.length; i < ii; ++i) {
        var segment = splitRoute[i];

        var match = segment.match(/^:([^?]+)(\?)?$/);
        if (match) {
          var _match = match;
          var _name = _match[1];
          var optional = _match[2];

          if (_name.indexOf('=') !== -1) {
            throw new Error('Parameter ' + _name + ' in route ' + route + ' has a default value, which is not supported.');
          }
          results.push(new DynamicSegment(_name, !!optional));
          names.push(_name);
          types.dynamics++;
          continue;
        }

        match = segment.match(/^\*(.+)$/);
        if (match) {
          results.push(new StarSegment(match[1]));
          names.push(match[1]);
          types.stars++;
        } else if (segment === '') {
          results.push(new EpsilonSegment());
        } else {
          results.push(new StaticSegment(segment, caseSensitive));
          types.statics++;
        }
      }

      return results;
    }

    function sortSolutions(states) {
      return states.sort(function (a, b) {
        if (a.types.stars !== b.types.stars) {
          return a.types.stars - b.types.stars;
        }

        if (a.types.stars) {
          if (a.types.statics !== b.types.statics) {
            return b.types.statics - a.types.statics;
          }
          if (a.types.dynamics !== b.types.dynamics) {
            return b.types.dynamics - a.types.dynamics;
          }
        }

        if (a.types.dynamics !== b.types.dynamics) {
          return a.types.dynamics - b.types.dynamics;
        }

        if (a.types.statics !== b.types.statics) {
          return b.types.statics - a.types.statics;
        }

        return 0;
      });
    }

    function recognizeChar(states, ch) {
      var nextStates = [];

      for (var i = 0, l = states.length; i < l; i++) {
        var state = states[i];
        nextStates.push.apply(nextStates, state.match(ch));
      }

      var skippableStates = nextStates.filter(function (s) {
        return s.epsilon;
      });

      var _loop = function _loop() {
        var newStates = [];
        skippableStates.forEach(function (s) {
          nextStates.push.apply(nextStates, s.epsilon);
          newStates.push.apply(newStates, s.epsilon);
        });
        skippableStates = newStates.filter(function (s) {
          return s.epsilon;
        });
      };

      while (skippableStates.length > 0) {
        _loop();
      }

      return nextStates;
    }

    function findHandler(state, path, queryParams) {
      var handlers = state.handlers;
      var regex = state.regex;
      var captures = path.match(regex);
      var currentCapture = 1;
      var result = new RecognizeResults(queryParams);

      for (var i = 0, l = handlers.length; i < l; i++) {
        var _handler = handlers[i];
        var _names = _handler.names;
        var _params = {};

        for (var j = 0, m = _names.length; j < m; j++) {
          _params[_names[j]] = captures[currentCapture++];
        }

        result.push({ handler: _handler.handler, params: _params, isDynamic: !!_names.length });
      }

      return result;
    }

    function addSegment(currentState, segment) {
      var state = currentState.put({ validChars: '/' });
      segment.eachChar(function (ch) {
        state = state.put(ch);
      });

      if (segment.optional) {
        currentState.epsilon = currentState.epsilon || [];
        currentState.epsilon.push(state);
      }

      return state;
    }
  }).call($__exports, $__exports, $__require('aurelia-path'));
});
System.registerDynamic("npm:aurelia-metadata@1.0.3.json", [], true, function() {
  return {
    "main": "aurelia-metadata",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-metadata@1.0.3/aurelia-metadata.js', ['aurelia-pal'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaPal) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Origin = exports.metadata = undefined;
    exports.decorators = decorators;
    exports.deprecated = deprecated;
    exports.mixin = mixin;
    exports.protocol = protocol;

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };

    function isObject(val) {
      return val && (typeof val === 'function' || (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object');
    }

    var metadata = exports.metadata = {
      resource: 'aurelia:resource',
      paramTypes: 'design:paramtypes',
      propertyType: 'design:type',
      properties: 'design:properties',
      get: function get(metadataKey, target, targetKey) {
        if (!isObject(target)) {
          return undefined;
        }
        var result = metadata.getOwn(metadataKey, target, targetKey);
        return result === undefined ? metadata.get(metadataKey, Object.getPrototypeOf(target), targetKey) : result;
      },
      getOwn: function getOwn(metadataKey, target, targetKey) {
        if (!isObject(target)) {
          return undefined;
        }
        return Reflect.getOwnMetadata(metadataKey, target, targetKey);
      },
      define: function define(metadataKey, metadataValue, target, targetKey) {
        Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
      },
      getOrCreateOwn: function getOrCreateOwn(metadataKey, Type, target, targetKey) {
        var result = metadata.getOwn(metadataKey, target, targetKey);

        if (result === undefined) {
          result = new Type();
          Reflect.defineMetadata(metadataKey, result, target, targetKey);
        }

        return result;
      }
    };

    var originStorage = new Map();
    var unknownOrigin = Object.freeze({ moduleId: undefined, moduleMember: undefined });

    var Origin = exports.Origin = function () {
      function Origin(moduleId, moduleMember) {

        this.moduleId = moduleId;
        this.moduleMember = moduleMember;
      }

      Origin.get = function get(fn) {
        var origin = originStorage.get(fn);

        if (origin === undefined) {
          _aureliaPal.PLATFORM.eachModule(function (key, value) {
            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
              for (var name in value) {
                var exp = value[name];
                if (exp === fn) {
                  originStorage.set(fn, origin = new Origin(key, name));
                  return true;
                }
              }
            }

            if (value === fn) {
              originStorage.set(fn, origin = new Origin(key, 'default'));
              return true;
            }

            return false;
          });
        }

        return origin || unknownOrigin;
      };

      Origin.set = function set(fn, origin) {
        originStorage.set(fn, origin);
      };

      return Origin;
    }();

    function decorators() {
      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      var applicator = function applicator(target, key, descriptor) {
        var i = rest.length;

        if (key) {
          descriptor = descriptor || {
            value: target[key],
            writable: true,
            configurable: true,
            enumerable: true
          };

          while (i--) {
            descriptor = rest[i](target, key, descriptor) || descriptor;
          }

          Object.defineProperty(target, key, descriptor);
        } else {
          while (i--) {
            target = rest[i](target) || target;
          }
        }

        return target;
      };

      applicator.on = applicator;
      return applicator;
    }

    function deprecated(optionsOrTarget, maybeKey, maybeDescriptor) {
      function decorator(target, key, descriptor) {
        var methodSignature = target.constructor.name + '#' + key;
        var options = maybeKey ? {} : optionsOrTarget || {};
        var message = 'DEPRECATION - ' + methodSignature;

        if (typeof descriptor.value !== 'function') {
          throw new SyntaxError('Only methods can be marked as deprecated.');
        }

        if (options.message) {
          message += ' - ' + options.message;
        }

        return _extends({}, descriptor, {
          value: function deprecationWrapper() {
            if (options.error) {
              throw new Error(message);
            } else {
              console.warn(message);
            }

            return descriptor.value.apply(this, arguments);
          }
        });
      }

      return maybeKey ? decorator(optionsOrTarget, maybeKey, maybeDescriptor) : decorator;
    }

    function mixin(behavior) {
      var instanceKeys = Object.keys(behavior);

      function _mixin(possible) {
        var decorator = function decorator(target) {
          var resolvedTarget = typeof target === 'function' ? target.prototype : target;

          var i = instanceKeys.length;
          while (i--) {
            var property = instanceKeys[i];
            Object.defineProperty(resolvedTarget, property, {
              value: behavior[property],
              writable: true
            });
          }
        };

        return possible ? decorator(possible) : decorator;
      }

      return _mixin;
    }

    function alwaysValid() {
      return true;
    }
    function noCompose() {}

    function ensureProtocolOptions(options) {
      if (options === undefined) {
        options = {};
      } else if (typeof options === 'function') {
        options = {
          validate: options
        };
      }

      if (!options.validate) {
        options.validate = alwaysValid;
      }

      if (!options.compose) {
        options.compose = noCompose;
      }

      return options;
    }

    function createProtocolValidator(validate) {
      return function (target) {
        var result = validate(target);
        return result === true;
      };
    }

    function createProtocolAsserter(name, validate) {
      return function (target) {
        var result = validate(target);
        if (result !== true) {
          throw new Error(result || name + ' was not correctly implemented.');
        }
      };
    }

    function protocol(name, options) {
      options = ensureProtocolOptions(options);

      var result = function result(target) {
        var resolvedTarget = typeof target === 'function' ? target.prototype : target;

        options.compose(resolvedTarget);
        result.assert(resolvedTarget);

        Object.defineProperty(resolvedTarget, 'protocol:' + name, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: true
        });
      };

      result.validate = createProtocolValidator(options.validate);
      result.assert = createProtocolAsserter(name, options.validate);

      return result;
    }

    protocol.create = function (name, options) {
      options = ensureProtocolOptions(options);
      var hidden = 'protocol:' + name;
      var result = function result(target) {
        var decorator = protocol(name, options);
        return target ? decorator(target) : decorator;
      };

      result.decorates = function (obj) {
        return obj[hidden] === true;
      };
      result.validate = createProtocolValidator(options.validate);
      result.assert = createProtocolAsserter(name, options.validate);

      return result;
    };
  }).call($__exports, $__exports, $__require('aurelia-pal'));
});
System.registerDynamic("npm:aurelia-pal@1.3.0.json", [], true, function() {
  return {
    "main": "aurelia-pal",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-pal@1.3.0/aurelia-pal.js', [], false, function ($__require, $__exports, $__module) {
  return (function (exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AggregateError = AggregateError;
    exports.initializePAL = initializePAL;
    exports.reset = reset;
    function AggregateError(message, innerError, skipIfAlreadyAggregate) {
      if (innerError) {
        if (innerError.innerError && skipIfAlreadyAggregate) {
          return innerError;
        }

        var separator = '\n------------------------------------------------\n';

        message += separator + 'Inner Error:\n';

        if (typeof innerError === 'string') {
          message += 'Message: ' + innerError;
        } else {
          if (innerError.message) {
            message += 'Message: ' + innerError.message;
          } else {
            message += 'Unknown Inner Error Type. Displaying Inner Error as JSON:\n ' + JSON.stringify(innerError, null, '  ');
          }

          if (innerError.stack) {
            message += '\nInner Error Stack:\n' + innerError.stack;
            message += '\nEnd Inner Error Stack';
          }
        }

        message += separator;
      }

      var e = new Error(message);
      if (innerError) {
        e.innerError = innerError;
      }

      return e;
    }

    var FEATURE = exports.FEATURE = {};

    var PLATFORM = exports.PLATFORM = {
      noop: function noop() {},
      eachModule: function eachModule() {},
      moduleName: function (_moduleName) {
        function moduleName(_x) {
          return _moduleName.apply(this, arguments);
        }

        moduleName.toString = function () {
          return _moduleName.toString();
        };

        return moduleName;
      }(function (moduleName) {
        return moduleName;
      })
    };

    PLATFORM.global = function () {
      if (typeof self !== 'undefined') {
        return self;
      }

      if (typeof global !== 'undefined') {
        return global;
      }

      return new Function('return this')();
    }();

    var DOM = exports.DOM = {};
    var isInitialized = exports.isInitialized = false;
    function initializePAL(callback) {
      if (isInitialized) {
        return;
      }
      exports.isInitialized = isInitialized = true;
      if (typeof Object.getPropertyDescriptor !== 'function') {
        Object.getPropertyDescriptor = function (subject, name) {
          var pd = Object.getOwnPropertyDescriptor(subject, name);
          var proto = Object.getPrototypeOf(subject);
          while (typeof pd === 'undefined' && proto !== null) {
            pd = Object.getOwnPropertyDescriptor(proto, name);
            proto = Object.getPrototypeOf(proto);
          }
          return pd;
        };
      }

      callback(PLATFORM, FEATURE, DOM);
    }
    function reset() {
      exports.isInitialized = isInitialized = false;
    }
  }).call($__exports, $__exports, $__require);
});
System.registerDynamic("npm:aurelia-dependency-injection@1.3.1.json", [], true, function() {
  return {
    "main": "aurelia-dependency-injection",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-dependency-injection@1.3.1/aurelia-dependency-injection.js', ['aurelia-metadata', 'aurelia-pal'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaMetadata, _aureliaPal) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Container = exports.InvocationHandler = exports._emptyParameters = exports.SingletonRegistration = exports.TransientRegistration = exports.FactoryInvoker = exports.NewInstance = exports.Factory = exports.StrategyResolver = exports.Parent = exports.Optional = exports.All = exports.Lazy = exports.resolver = undefined;
    exports.getDecoratorDependencies = getDecoratorDependencies;
    exports.lazy = lazy;
    exports.all = all;
    exports.optional = optional;
    exports.parent = parent;
    exports.factory = factory;
    exports.newInstance = newInstance;
    exports.invoker = invoker;
    exports.invokeAsFactory = invokeAsFactory;
    exports.registration = registration;
    exports.transient = transient;
    exports.singleton = singleton;
    exports.autoinject = autoinject;
    exports.inject = inject;

    var _dec, _class, _dec2, _class3, _dec3, _class5, _dec4, _class7, _dec5, _class9, _dec6, _class11, _dec7, _class13, _classInvokers;

    var resolver = exports.resolver = _aureliaMetadata.protocol.create('aurelia:resolver', function (target) {
      if (!(typeof target.get === 'function')) {
        return 'Resolvers must implement: get(container: Container, key: any): any';
      }

      return true;
    });

    var Lazy = exports.Lazy = (_dec = resolver(), _dec(_class = function () {
      function Lazy(key) {

        this._key = key;
      }

      Lazy.prototype.get = function get(container) {
        var _this = this;

        return function () {
          return container.get(_this._key);
        };
      };

      Lazy.of = function of(key) {
        return new Lazy(key);
      };

      return Lazy;
    }()) || _class);
    var All = exports.All = (_dec2 = resolver(), _dec2(_class3 = function () {
      function All(key) {

        this._key = key;
      }

      All.prototype.get = function get(container) {
        return container.getAll(this._key);
      };

      All.of = function of(key) {
        return new All(key);
      };

      return All;
    }()) || _class3);
    var Optional = exports.Optional = (_dec3 = resolver(), _dec3(_class5 = function () {
      function Optional(key) {
        var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        this._key = key;
        this._checkParent = checkParent;
      }

      Optional.prototype.get = function get(container) {
        if (container.hasResolver(this._key, this._checkParent)) {
          return container.get(this._key);
        }

        return null;
      };

      Optional.of = function of(key) {
        var checkParent = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

        return new Optional(key, checkParent);
      };

      return Optional;
    }()) || _class5);
    var Parent = exports.Parent = (_dec4 = resolver(), _dec4(_class7 = function () {
      function Parent(key) {

        this._key = key;
      }

      Parent.prototype.get = function get(container) {
        return container.parent ? container.parent.get(this._key) : null;
      };

      Parent.of = function of(key) {
        return new Parent(key);
      };

      return Parent;
    }()) || _class7);
    var StrategyResolver = exports.StrategyResolver = (_dec5 = resolver(), _dec5(_class9 = function () {
      function StrategyResolver(strategy, state) {

        this.strategy = strategy;
        this.state = state;
      }

      StrategyResolver.prototype.get = function get(container, key) {
        switch (this.strategy) {
          case 0:
            return this.state;
          case 1:
            var singleton = container.invoke(this.state);
            this.state = singleton;
            this.strategy = 0;
            return singleton;
          case 2:
            return container.invoke(this.state);
          case 3:
            return this.state(container, key, this);
          case 4:
            return this.state[0].get(container, key);
          case 5:
            return container.get(this.state);
          default:
            throw new Error('Invalid strategy: ' + this.strategy);
        }
      };

      return StrategyResolver;
    }()) || _class9);
    var Factory = exports.Factory = (_dec6 = resolver(), _dec6(_class11 = function () {
      function Factory(key) {

        this._key = key;
      }

      Factory.prototype.get = function get(container) {
        var _this2 = this;

        return function () {
          for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
            rest[_key] = arguments[_key];
          }

          return container.invoke(_this2._key, rest);
        };
      };

      Factory.of = function of(key) {
        return new Factory(key);
      };

      return Factory;
    }()) || _class11);
    var NewInstance = exports.NewInstance = (_dec7 = resolver(), _dec7(_class13 = function () {
      function NewInstance(key) {

        this.key = key;
        this.asKey = key;

        for (var _len2 = arguments.length, dynamicDependencies = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          dynamicDependencies[_key2 - 1] = arguments[_key2];
        }

        this.dynamicDependencies = dynamicDependencies;
      }

      NewInstance.prototype.get = function get(container) {
        var dynamicDependencies = this.dynamicDependencies.length > 0 ? this.dynamicDependencies.map(function (dependency) {
          return dependency['protocol:aurelia:resolver'] ? dependency.get(container) : container.get(dependency);
        }) : undefined;
        var instance = container.invoke(this.key, dynamicDependencies);
        container.registerInstance(this.asKey, instance);
        return instance;
      };

      NewInstance.prototype.as = function as(key) {
        this.asKey = key;
        return this;
      };

      NewInstance.of = function of(key) {
        for (var _len3 = arguments.length, dynamicDependencies = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          dynamicDependencies[_key3 - 1] = arguments[_key3];
        }

        return new (Function.prototype.bind.apply(NewInstance, [null].concat([key], dynamicDependencies)))();
      };

      return NewInstance;
    }()) || _class13);
    function getDecoratorDependencies(target, name) {
      var dependencies = target.inject;
      if (typeof dependencies === 'function') {
        throw new Error('Decorator ' + name + ' cannot be used with "inject()".  Please use an array instead.');
      }
      if (!dependencies) {
        dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target).slice();
        target.inject = dependencies;
      }

      return dependencies;
    }

    function lazy(keyValue) {
      return function (target, key, index) {
        var params = getDecoratorDependencies(target, 'lazy');
        params[index] = Lazy.of(keyValue);
      };
    }

    function all(keyValue) {
      return function (target, key, index) {
        var params = getDecoratorDependencies(target, 'all');
        params[index] = All.of(keyValue);
      };
    }

    function optional() {
      var checkParentOrTarget = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      var deco = function deco(checkParent) {
        return function (target, key, index) {
          var params = getDecoratorDependencies(target, 'optional');
          params[index] = Optional.of(params[index], checkParent);
        };
      };
      if (typeof checkParentOrTarget === 'boolean') {
        return deco(checkParentOrTarget);
      }
      return deco(true);
    }

    function parent(target, key, index) {
      var params = getDecoratorDependencies(target, 'parent');
      params[index] = Parent.of(params[index]);
    }

    function factory(keyValue, asValue) {
      return function (target, key, index) {
        var params = getDecoratorDependencies(target, 'factory');
        var factory = Factory.of(keyValue);
        params[index] = asValue ? factory.as(asValue) : factory;
      };
    }

    function newInstance(asKeyOrTarget) {
      for (var _len4 = arguments.length, dynamicDependencies = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        dynamicDependencies[_key4 - 1] = arguments[_key4];
      }

      var deco = function deco(asKey) {
        return function (target, key, index) {
          var params = getDecoratorDependencies(target, 'newInstance');
          params[index] = NewInstance.of.apply(NewInstance, [params[index]].concat(dynamicDependencies));
          if (!!asKey) {
            params[index].as(asKey);
          }
        };
      };
      if (arguments.length >= 1) {
        return deco(asKeyOrTarget);
      }
      return deco();
    }

    function invoker(value) {
      return function (target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, value, target);
      };
    }

    function invokeAsFactory(potentialTarget) {
      var deco = function deco(target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, FactoryInvoker.instance, target);
      };

      return potentialTarget ? deco(potentialTarget) : deco;
    }

    var FactoryInvoker = exports.FactoryInvoker = function () {
      function FactoryInvoker() {}

      FactoryInvoker.prototype.invoke = function invoke(container, fn, dependencies) {
        var i = dependencies.length;
        var args = new Array(i);

        while (i--) {
          args[i] = container.get(dependencies[i]);
        }

        return fn.apply(undefined, args);
      };

      FactoryInvoker.prototype.invokeWithDynamicDependencies = function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
        var i = staticDependencies.length;
        var args = new Array(i);

        while (i--) {
          args[i] = container.get(staticDependencies[i]);
        }

        if (dynamicDependencies !== undefined) {
          args = args.concat(dynamicDependencies);
        }

        return fn.apply(undefined, args);
      };

      return FactoryInvoker;
    }();

    FactoryInvoker.instance = new FactoryInvoker();

    function registration(value) {
      return function (target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.registration, value, target);
      };
    }

    function transient(key) {
      return registration(new TransientRegistration(key));
    }

    function singleton(keyOrRegisterInChild) {
      var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      return registration(new SingletonRegistration(keyOrRegisterInChild, registerInChild));
    }

    var TransientRegistration = exports.TransientRegistration = function () {
      function TransientRegistration(key) {

        this._key = key;
      }

      TransientRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
        var existingResolver = container.getResolver(this._key || key);
        return existingResolver === undefined ? container.registerTransient(this._key || key, fn) : existingResolver;
      };

      return TransientRegistration;
    }();

    var SingletonRegistration = exports.SingletonRegistration = function () {
      function SingletonRegistration(keyOrRegisterInChild) {
        var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        if (typeof keyOrRegisterInChild === 'boolean') {
          this._registerInChild = keyOrRegisterInChild;
        } else {
          this._key = keyOrRegisterInChild;
          this._registerInChild = registerInChild;
        }
      }

      SingletonRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
        var targetContainer = this._registerInChild ? container : container.root;
        var existingResolver = targetContainer.getResolver(this._key || key);
        return existingResolver === undefined ? targetContainer.registerSingleton(this._key || key, fn) : existingResolver;
      };

      return SingletonRegistration;
    }();

    function validateKey(key) {
      if (key === null || key === undefined) {
        throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
      }
    }
    var _emptyParameters = exports._emptyParameters = Object.freeze([]);

    _aureliaMetadata.metadata.registration = 'aurelia:registration';
    _aureliaMetadata.metadata.invoker = 'aurelia:invoker';

    var resolverDecorates = resolver.decorates;

    var InvocationHandler = exports.InvocationHandler = function () {
      function InvocationHandler(fn, invoker, dependencies) {

        this.fn = fn;
        this.invoker = invoker;
        this.dependencies = dependencies;
      }

      InvocationHandler.prototype.invoke = function invoke(container, dynamicDependencies) {
        return dynamicDependencies !== undefined ? this.invoker.invokeWithDynamicDependencies(container, this.fn, this.dependencies, dynamicDependencies) : this.invoker.invoke(container, this.fn, this.dependencies);
      };

      return InvocationHandler;
    }();

    function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
      var i = staticDependencies.length;
      var args = new Array(i);

      while (i--) {
        args[i] = container.get(staticDependencies[i]);
      }

      if (dynamicDependencies !== undefined) {
        args = args.concat(dynamicDependencies);
      }

      return Reflect.construct(fn, args);
    }

    var classInvokers = (_classInvokers = {}, _classInvokers[0] = {
      invoke: function invoke(container, Type) {
        return new Type();
      },

      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[1] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]));
      },

      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[2] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]), container.get(deps[1]));
      },

      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[3] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));
      },

      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[4] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]));
      },

      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[5] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]), container.get(deps[4]));
      },

      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers.fallback = {
      invoke: invokeWithDynamicDependencies,
      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers);

    function getDependencies(f) {
      if (!f.hasOwnProperty('inject')) {
        return [];
      }

      if (typeof f.inject === 'function') {
        return f.inject();
      }

      return f.inject;
    }

    var Container = exports.Container = function () {
      function Container(configuration) {

        if (configuration === undefined) {
          configuration = {};
        }

        this._configuration = configuration;
        this._onHandlerCreated = configuration.onHandlerCreated;
        this._handlers = configuration.handlers || (configuration.handlers = new Map());
        this._resolvers = new Map();
        this.root = this;
        this.parent = null;
      }

      Container.prototype.makeGlobal = function makeGlobal() {
        Container.instance = this;
        return this;
      };

      Container.prototype.setHandlerCreatedCallback = function setHandlerCreatedCallback(onHandlerCreated) {
        this._onHandlerCreated = onHandlerCreated;
        this._configuration.onHandlerCreated = onHandlerCreated;
      };

      Container.prototype.registerInstance = function registerInstance(key, instance) {
        return this.registerResolver(key, new StrategyResolver(0, instance === undefined ? key : instance));
      };

      Container.prototype.registerSingleton = function registerSingleton(key, fn) {
        return this.registerResolver(key, new StrategyResolver(1, fn === undefined ? key : fn));
      };

      Container.prototype.registerTransient = function registerTransient(key, fn) {
        return this.registerResolver(key, new StrategyResolver(2, fn === undefined ? key : fn));
      };

      Container.prototype.registerHandler = function registerHandler(key, handler) {
        return this.registerResolver(key, new StrategyResolver(3, handler));
      };

      Container.prototype.registerAlias = function registerAlias(originalKey, aliasKey) {
        return this.registerResolver(aliasKey, new StrategyResolver(5, originalKey));
      };

      Container.prototype.registerResolver = function registerResolver(key, resolver) {
        validateKey(key);

        var allResolvers = this._resolvers;
        var result = allResolvers.get(key);

        if (result === undefined) {
          allResolvers.set(key, resolver);
        } else if (result.strategy === 4) {
          result.state.push(resolver);
        } else {
          allResolvers.set(key, new StrategyResolver(4, [result, resolver]));
        }

        return resolver;
      };

      Container.prototype.autoRegister = function autoRegister(key, fn) {
        fn = fn === undefined ? key : fn;

        if (typeof fn === 'function') {
          var _registration = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, fn);

          if (_registration === undefined) {
            return this.registerResolver(key, new StrategyResolver(1, fn));
          }

          return _registration.registerResolver(this, key, fn);
        }

        return this.registerResolver(key, new StrategyResolver(0, fn));
      };

      Container.prototype.autoRegisterAll = function autoRegisterAll(fns) {
        var i = fns.length;
        while (i--) {
          this.autoRegister(fns[i]);
        }
      };

      Container.prototype.unregister = function unregister(key) {
        this._resolvers.delete(key);
      };

      Container.prototype.hasResolver = function hasResolver(key) {
        var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        validateKey(key);

        return this._resolvers.has(key) || checkParent && this.parent !== null && this.parent.hasResolver(key, checkParent);
      };

      Container.prototype.getResolver = function getResolver(key) {
        return this._resolvers.get(key);
      };

      Container.prototype.get = function get(key) {
        validateKey(key);

        if (key === Container) {
          return this;
        }

        if (resolverDecorates(key)) {
          return key.get(this, key);
        }

        var resolver = this._resolvers.get(key);

        if (resolver === undefined) {
          if (this.parent === null) {
            return this.autoRegister(key).get(this, key);
          }

          var _registration2 = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, key);

          if (_registration2 === undefined) {
            return this.parent._get(key);
          }

          return _registration2.registerResolver(this, key, key).get(this, key);
        }

        return resolver.get(this, key);
      };

      Container.prototype._get = function _get(key) {
        var resolver = this._resolvers.get(key);

        if (resolver === undefined) {
          if (this.parent === null) {
            return this.autoRegister(key).get(this, key);
          }

          return this.parent._get(key);
        }

        return resolver.get(this, key);
      };

      Container.prototype.getAll = function getAll(key) {
        validateKey(key);

        var resolver = this._resolvers.get(key);

        if (resolver === undefined) {
          if (this.parent === null) {
            return _emptyParameters;
          }

          return this.parent.getAll(key);
        }

        if (resolver.strategy === 4) {
          var state = resolver.state;
          var i = state.length;
          var results = new Array(i);

          while (i--) {
            results[i] = state[i].get(this, key);
          }

          return results;
        }

        return [resolver.get(this, key)];
      };

      Container.prototype.createChild = function createChild() {
        var child = new Container(this._configuration);
        child.root = this.root;
        child.parent = this;
        return child;
      };

      Container.prototype.invoke = function invoke(fn, dynamicDependencies) {
        try {
          var _handler = this._handlers.get(fn);

          if (_handler === undefined) {
            _handler = this._createInvocationHandler(fn);
            this._handlers.set(fn, _handler);
          }

          return _handler.invoke(this, dynamicDependencies);
        } catch (e) {
          throw new _aureliaPal.AggregateError('Error invoking ' + fn.name + '. Check the inner error for details.', e, true);
        }
      };

      Container.prototype._createInvocationHandler = function _createInvocationHandler(fn) {
        var dependencies = void 0;

        if (fn.inject === undefined) {
          dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, fn) || _emptyParameters;
        } else {
          dependencies = [];
          var ctor = fn;
          while (typeof ctor === 'function') {
            var _dependencies;

            (_dependencies = dependencies).push.apply(_dependencies, getDependencies(ctor));
            ctor = Object.getPrototypeOf(ctor);
          }
        }

        var invoker = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.invoker, fn) || classInvokers[dependencies.length] || classInvokers.fallback;

        var handler = new InvocationHandler(fn, invoker, dependencies);
        return this._onHandlerCreated !== undefined ? this._onHandlerCreated(handler) : handler;
      };

      return Container;
    }();

    function autoinject(potentialTarget) {
      var deco = function deco(target) {
        var previousInject = target.inject ? target.inject.slice() : null;
        var autoInject = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target) || _emptyParameters;
        if (!previousInject) {
          target.inject = autoInject;
        } else {
          for (var i = 0; i < autoInject.length; i++) {
            if (previousInject[i] && previousInject[i] !== autoInject[i]) {
              var prevIndex = previousInject.indexOf(autoInject[i]);
              if (prevIndex > -1) {
                previousInject.splice(prevIndex, 1);
              }
              previousInject.splice(prevIndex > -1 && prevIndex < i ? i - 1 : i, 0, autoInject[i]);
            } else if (!previousInject[i]) {
              previousInject[i] = autoInject[i];
            }
          }
          target.inject = previousInject;
        }
      };

      return potentialTarget ? deco(potentialTarget) : deco;
    }

    function inject() {
      for (var _len5 = arguments.length, rest = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        rest[_key5] = arguments[_key5];
      }

      return function (target, key, descriptor) {
        if (typeof descriptor === 'number' && rest.length === 1) {
          var params = target.inject;
          if (typeof params === 'function') {
            throw new Error('Decorator inject cannot be used with "inject()".  Please use an array instead.');
          }
          if (!params) {
            params = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target).slice();
            target.inject = params;
          }
          params[descriptor] = rest[0];
          return;
        }

        if (descriptor) {
          var _fn = descriptor.value;
          _fn.inject = rest;
        } else {
          target.inject = rest;
        }
      };
    }
  }).call($__exports, $__exports, $__require('aurelia-metadata'), $__require('aurelia-pal'));
});
System.registerDynamic("npm:aurelia-history@1.0.0.json", [], true, function() {
  return {
    "main": "aurelia-history",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-history@1.0.0/aurelia-history.js', [], false, function ($__require, $__exports, $__module) {
  return (function (exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function mi(name) {
      throw new Error('History must implement ' + name + '().');
    }

    var History = exports.History = function () {
      function History() {}

      History.prototype.activate = function activate(options) {
        mi('activate');
      };

      History.prototype.deactivate = function deactivate() {
        mi('deactivate');
      };

      History.prototype.getAbsoluteRoot = function getAbsoluteRoot() {
        mi('getAbsoluteRoot');
      };

      History.prototype.navigate = function navigate(fragment, options) {
        mi('navigate');
      };

      History.prototype.navigateBack = function navigateBack() {
        mi('navigateBack');
      };

      History.prototype.setTitle = function setTitle(title) {
        mi('setTitle');
      };

      return History;
    }();
  }).call($__exports, $__exports, $__require);
});
System.registerDynamic("npm:aurelia-logging@1.3.1.json", [], true, function() {
  return {
    "main": "aurelia-logging",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-logging@1.3.1/aurelia-logging.js', [], false, function ($__require, $__exports, $__module) {
  return (function (exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getLogger = getLogger;
    exports.addAppender = addAppender;
    exports.removeAppender = removeAppender;
    exports.setLevel = setLevel;
    exports.getLevel = getLevel;

    var logLevel = exports.logLevel = {
      none: 0,
      error: 1,
      warn: 2,
      info: 3,
      debug: 4
    };

    var loggers = {};
    var appenders = [];
    var globalDefaultLevel = logLevel.none;

    function appendArgs() {
      return [this].concat(Array.prototype.slice.call(arguments));
    }

    function logFactory(level) {
      var threshold = logLevel[level];
      return function () {
        if (this.level < threshold) {
          return;
        }

        var args = appendArgs.apply(this, arguments);
        var i = appenders.length;
        while (i--) {
          var _appenders$i;

          (_appenders$i = appenders[i])[level].apply(_appenders$i, args);
        }
      };
    }

    function connectLoggers() {
      var proto = Logger.prototype;
      proto.debug = logFactory('debug');
      proto.info = logFactory('info');
      proto.warn = logFactory('warn');
      proto.error = logFactory('error');
    }

    function getLogger(id) {
      return loggers[id] || new Logger(id);
    }

    function addAppender(appender) {
      if (appenders.push(appender) === 1) {
        connectLoggers();
      }
    }

    function removeAppender(appender) {
      appenders = appenders.filter(function (a) {
        return a !== appender;
      });
    }

    function setLevel(level) {
      globalDefaultLevel = level;
      for (var key in loggers) {
        loggers[key].setLevel(level);
      }
    }

    function getLevel() {
      return globalDefaultLevel;
    }

    var Logger = exports.Logger = function () {
      function Logger(id) {

        var cached = loggers[id];
        if (cached) {
          return cached;
        }

        loggers[id] = this;
        this.id = id;
        this.level = globalDefaultLevel;
      }

      Logger.prototype.debug = function debug(message) {};

      Logger.prototype.info = function info(message) {};

      Logger.prototype.warn = function warn(message) {};

      Logger.prototype.error = function error(message) {};

      Logger.prototype.setLevel = function setLevel(level) {
        this.level = level;
      };

      return Logger;
    }();
  }).call($__exports, $__exports, $__require);
});
System.registerDynamic("npm:aurelia-event-aggregator@1.0.1.json", [], true, function() {
  return {
    "main": "aurelia-event-aggregator",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-event-aggregator@1.0.1/aurelia-event-aggregator.js', ['aurelia-logging'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaLogging) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EventAggregator = undefined;
    exports.includeEventsIn = includeEventsIn;
    exports.configure = configure;

    var LogManager = _interopRequireWildcard(_aureliaLogging);

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};

        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }

        newObj.default = obj;
        return newObj;
      }
    }

    var logger = LogManager.getLogger('event-aggregator');

    var Handler = function () {
      function Handler(messageType, callback) {

        this.messageType = messageType;
        this.callback = callback;
      }

      Handler.prototype.handle = function handle(message) {
        if (message instanceof this.messageType) {
          this.callback.call(null, message);
        }
      };

      return Handler;
    }();

    function invokeCallback(callback, data, event) {
      try {
        callback(data, event);
      } catch (e) {
        logger.error(e);
      }
    }

    function invokeHandler(handler, data) {
      try {
        handler.handle(data);
      } catch (e) {
        logger.error(e);
      }
    }

    var EventAggregator = exports.EventAggregator = function () {
      function EventAggregator() {

        this.eventLookup = {};
        this.messageHandlers = [];
      }

      EventAggregator.prototype.publish = function publish(event, data) {
        var subscribers = void 0;
        var i = void 0;

        if (!event) {
          throw new Error('Event was invalid.');
        }

        if (typeof event === 'string') {
          subscribers = this.eventLookup[event];
          if (subscribers) {
            subscribers = subscribers.slice();
            i = subscribers.length;

            while (i--) {
              invokeCallback(subscribers[i], data, event);
            }
          }
        } else {
          subscribers = this.messageHandlers.slice();
          i = subscribers.length;

          while (i--) {
            invokeHandler(subscribers[i], event);
          }
        }
      };

      EventAggregator.prototype.subscribe = function subscribe(event, callback) {
        var handler = void 0;
        var subscribers = void 0;

        if (!event) {
          throw new Error('Event channel/type was invalid.');
        }

        if (typeof event === 'string') {
          handler = callback;
          subscribers = this.eventLookup[event] || (this.eventLookup[event] = []);
        } else {
          handler = new Handler(event, callback);
          subscribers = this.messageHandlers;
        }

        subscribers.push(handler);

        return {
          dispose: function dispose() {
            var idx = subscribers.indexOf(handler);
            if (idx !== -1) {
              subscribers.splice(idx, 1);
            }
          }
        };
      };

      EventAggregator.prototype.subscribeOnce = function subscribeOnce(event, callback) {
        var sub = this.subscribe(event, function (a, b) {
          sub.dispose();
          return callback(a, b);
        });

        return sub;
      };

      return EventAggregator;
    }();

    function includeEventsIn(obj) {
      var ea = new EventAggregator();

      obj.subscribeOnce = function (event, callback) {
        return ea.subscribeOnce(event, callback);
      };

      obj.subscribe = function (event, callback) {
        return ea.subscribe(event, callback);
      };

      obj.publish = function (event, data) {
        ea.publish(event, data);
      };

      return ea;
    }

    function configure(config) {
      config.instance(EventAggregator, includeEventsIn(config.aurelia));
    }
  }).call($__exports, $__exports, $__require('aurelia-logging'));
});
System.registerDynamic("npm:aurelia-router@1.3.0.json", [], true, function() {
  return {
    "main": "aurelia-router",
    "format": "amd"
  };
});

System.registerDynamic('npm:aurelia-router@1.3.0/aurelia-router.js', ['aurelia-logging', 'aurelia-route-recognizer', 'aurelia-dependency-injection', 'aurelia-history', 'aurelia-event-aggregator'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaLogging, _aureliaRouteRecognizer, _aureliaDependencyInjection, _aureliaHistory, _aureliaEventAggregator) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AppRouter = exports.PipelineProvider = exports.LoadRouteStep = exports.RouteLoader = exports.ActivateNextStep = exports.DeactivatePreviousStep = exports.CanActivateNextStep = exports.CanDeactivatePreviousStep = exports.Router = exports.BuildNavigationPlanStep = exports.activationStrategy = exports.RouterConfiguration = exports.RedirectToRoute = exports.Redirect = exports.NavModel = exports.NavigationInstruction = exports.CommitChangesStep = exports.Pipeline = exports.pipelineStatus = undefined;
    exports._normalizeAbsolutePath = _normalizeAbsolutePath;
    exports._createRootedPath = _createRootedPath;
    exports._resolveUrl = _resolveUrl;
    exports.isNavigationCommand = isNavigationCommand;
    exports._buildNavigationPlan = _buildNavigationPlan;

    var LogManager = _interopRequireWildcard(_aureliaLogging);

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};

        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }

        newObj.default = obj;
        return newObj;
      }
    }

    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    function _normalizeAbsolutePath(path, hasPushState) {
      var absolute = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      if (!hasPushState && path[0] !== '#') {
        path = '#' + path;
      }

      if (hasPushState && absolute) {
        path = path.substring(1, path.length);
      }

      return path;
    }

    function _createRootedPath(fragment, baseUrl, hasPushState, absolute) {
      if (isAbsoluteUrl.test(fragment)) {
        return fragment;
      }

      var path = '';

      if (baseUrl.length && baseUrl[0] !== '/') {
        path += '/';
      }

      path += baseUrl;

      if ((!path.length || path[path.length - 1] !== '/') && fragment[0] !== '/') {
        path += '/';
      }

      if (path.length && path[path.length - 1] === '/' && fragment[0] === '/') {
        path = path.substring(0, path.length - 1);
      }

      return _normalizeAbsolutePath(path + fragment, hasPushState, absolute);
    }

    function _resolveUrl(fragment, baseUrl, hasPushState) {
      if (isRootedPath.test(fragment)) {
        return _normalizeAbsolutePath(fragment, hasPushState);
      }

      return _createRootedPath(fragment, baseUrl, hasPushState);
    }

    var isRootedPath = /^#?\//;
    var isAbsoluteUrl = /^([a-z][a-z0-9+\-.]*:)?\/\//i;

    var pipelineStatus = exports.pipelineStatus = {
      completed: 'completed',
      canceled: 'canceled',
      rejected: 'rejected',
      running: 'running'
    };

    var Pipeline = exports.Pipeline = function () {
      function Pipeline() {

        this.steps = [];
      }

      Pipeline.prototype.addStep = function addStep(step) {
        var run = void 0;

        if (typeof step === 'function') {
          run = step;
        } else if (typeof step.getSteps === 'function') {
          var steps = step.getSteps();
          for (var i = 0, l = steps.length; i < l; i++) {
            this.addStep(steps[i]);
          }

          return this;
        } else {
          run = step.run.bind(step);
        }

        this.steps.push(run);

        return this;
      };

      Pipeline.prototype.run = function run(instruction) {
        var index = -1;
        var steps = this.steps;

        function next() {
          index++;

          if (index < steps.length) {
            var currentStep = steps[index];

            try {
              return currentStep(instruction, next);
            } catch (e) {
              return next.reject(e);
            }
          } else {
            return next.complete();
          }
        }

        next.complete = createCompletionHandler(next, pipelineStatus.completed);
        next.cancel = createCompletionHandler(next, pipelineStatus.canceled);
        next.reject = createCompletionHandler(next, pipelineStatus.rejected);

        return next();
      };

      return Pipeline;
    }();

    function createCompletionHandler(next, status) {
      return function (output) {
        return Promise.resolve({ status: status, output: output, completed: status === pipelineStatus.completed });
      };
    }

    var CommitChangesStep = exports.CommitChangesStep = function () {
      function CommitChangesStep() {}

      CommitChangesStep.prototype.run = function run(navigationInstruction, next) {
        return navigationInstruction._commitChanges(true).then(function () {
          navigationInstruction._updateTitle();
          return next();
        });
      };

      return CommitChangesStep;
    }();

    var NavigationInstruction = exports.NavigationInstruction = function () {
      function NavigationInstruction(init) {

        this.plan = null;
        this.options = {};

        Object.assign(this, init);

        this.params = this.params || {};
        this.viewPortInstructions = {};

        var ancestorParams = [];
        var current = this;
        do {
          var currentParams = Object.assign({}, current.params);
          if (current.config && current.config.hasChildRouter) {
            delete currentParams[current.getWildCardName()];
          }

          ancestorParams.unshift(currentParams);
          current = current.parentInstruction;
        } while (current);

        var allParams = Object.assign.apply(Object, [{}, this.queryParams].concat(ancestorParams));
        this.lifecycleArgs = [allParams, this.config, this];
      }

      NavigationInstruction.prototype.getAllInstructions = function getAllInstructions() {
        var instructions = [this];
        for (var key in this.viewPortInstructions) {
          var childInstruction = this.viewPortInstructions[key].childNavigationInstruction;
          if (childInstruction) {
            instructions.push.apply(instructions, childInstruction.getAllInstructions());
          }
        }

        return instructions;
      };

      NavigationInstruction.prototype.getAllPreviousInstructions = function getAllPreviousInstructions() {
        return this.getAllInstructions().map(function (c) {
          return c.previousInstruction;
        }).filter(function (c) {
          return c;
        });
      };

      NavigationInstruction.prototype.addViewPortInstruction = function addViewPortInstruction(viewPortName, strategy, moduleId, component) {
        var config = Object.assign({}, this.lifecycleArgs[1], { currentViewPort: viewPortName });
        var viewportInstruction = this.viewPortInstructions[viewPortName] = {
          name: viewPortName,
          strategy: strategy,
          moduleId: moduleId,
          component: component,
          childRouter: component.childRouter,
          lifecycleArgs: [].concat(this.lifecycleArgs[0], config, this.lifecycleArgs[2])
        };

        return viewportInstruction;
      };

      NavigationInstruction.prototype.getWildCardName = function getWildCardName() {
        var wildcardIndex = this.config.route.lastIndexOf('*');
        return this.config.route.substr(wildcardIndex + 1);
      };

      NavigationInstruction.prototype.getWildcardPath = function getWildcardPath() {
        var wildcardName = this.getWildCardName();
        var path = this.params[wildcardName] || '';

        if (this.queryString) {
          path += '?' + this.queryString;
        }

        return path;
      };

      NavigationInstruction.prototype.getBaseUrl = function getBaseUrl() {
        var _this = this;

        var fragment = this.fragment;

        if (fragment === '') {
          var nonEmptyRoute = this.router.routes.find(function (route) {
            return route.name === _this.config.name && route.route !== '';
          });
          if (nonEmptyRoute) {
            fragment = nonEmptyRoute.route;
          }
        }

        if (!this.params) {
          return fragment;
        }

        var wildcardName = this.getWildCardName();
        var path = this.params[wildcardName] || '';

        if (!path) {
          return fragment;
        }

        path = encodeURI(path);
        return fragment.substr(0, fragment.lastIndexOf(path));
      };

      NavigationInstruction.prototype._commitChanges = function _commitChanges(waitToSwap) {
        var _this2 = this;

        var router = this.router;
        router.currentInstruction = this;

        if (this.previousInstruction) {
          this.previousInstruction.config.navModel.isActive = false;
        }

        this.config.navModel.isActive = true;

        router._refreshBaseUrl();
        router.refreshNavigation();

        var loads = [];
        var delaySwaps = [];

        var _loop = function _loop(viewPortName) {
          var viewPortInstruction = _this2.viewPortInstructions[viewPortName];
          var viewPort = router.viewPorts[viewPortName];

          if (!viewPort) {
            throw new Error('There was no router-view found in the view for ' + viewPortInstruction.moduleId + '.');
          }

          if (viewPortInstruction.strategy === activationStrategy.replace) {
            if (waitToSwap) {
              delaySwaps.push({ viewPort: viewPort, viewPortInstruction: viewPortInstruction });
            }

            loads.push(viewPort.process(viewPortInstruction, waitToSwap).then(function (x) {
              if (viewPortInstruction.childNavigationInstruction) {
                return viewPortInstruction.childNavigationInstruction._commitChanges();
              }

              return undefined;
            }));
          } else {
            if (viewPortInstruction.childNavigationInstruction) {
              loads.push(viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap));
            }
          }
        };

        for (var viewPortName in this.viewPortInstructions) {
          _loop(viewPortName);
        }

        return Promise.all(loads).then(function () {
          delaySwaps.forEach(function (x) {
            return x.viewPort.swap(x.viewPortInstruction);
          });
          return null;
        }).then(function () {
          return prune(_this2);
        });
      };

      NavigationInstruction.prototype._updateTitle = function _updateTitle() {
        var title = this._buildTitle();
        if (title) {
          this.router.history.setTitle(title);
        }
      };

      NavigationInstruction.prototype._buildTitle = function _buildTitle() {
        var separator = arguments.length <= 0 || arguments[0] === undefined ? ' | ' : arguments[0];

        var title = '';
        var childTitles = [];

        if (this.config.navModel.title) {
          title = this.router.transformTitle(this.config.navModel.title);
        }

        for (var viewPortName in this.viewPortInstructions) {
          var _viewPortInstruction = this.viewPortInstructions[viewPortName];

          if (_viewPortInstruction.childNavigationInstruction) {
            var childTitle = _viewPortInstruction.childNavigationInstruction._buildTitle(separator);
            if (childTitle) {
              childTitles.push(childTitle);
            }
          }
        }

        if (childTitles.length) {
          title = childTitles.join(separator) + (title ? separator : '') + title;
        }

        if (this.router.title) {
          title += (title ? separator : '') + this.router.transformTitle(this.router.title);
        }

        return title;
      };

      return NavigationInstruction;
    }();

    function prune(instruction) {
      instruction.previousInstruction = null;
      instruction.plan = null;
    }

    var NavModel = exports.NavModel = function () {
      function NavModel(router, relativeHref) {

        this.isActive = false;
        this.title = null;
        this.href = null;
        this.relativeHref = null;
        this.settings = {};
        this.config = null;

        this.router = router;
        this.relativeHref = relativeHref;
      }

      NavModel.prototype.setTitle = function setTitle(title) {
        this.title = title;

        if (this.isActive) {
          this.router.updateTitle();
        }
      };

      return NavModel;
    }();

    function isNavigationCommand(obj) {
      return obj && typeof obj.navigate === 'function';
    }

    var Redirect = exports.Redirect = function () {
      function Redirect(url) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        this.url = url;
        this.options = Object.assign({ trigger: true, replace: true }, options);
        this.shouldContinueProcessing = false;
      }

      Redirect.prototype.setRouter = function setRouter(router) {
        this.router = router;
      };

      Redirect.prototype.navigate = function navigate(appRouter) {
        var navigatingRouter = this.options.useAppRouter ? appRouter : this.router || appRouter;
        navigatingRouter.navigate(this.url, this.options);
      };

      return Redirect;
    }();

    var RedirectToRoute = exports.RedirectToRoute = function () {
      function RedirectToRoute(route) {
        var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        this.route = route;
        this.params = params;
        this.options = Object.assign({ trigger: true, replace: true }, options);
        this.shouldContinueProcessing = false;
      }

      RedirectToRoute.prototype.setRouter = function setRouter(router) {
        this.router = router;
      };

      RedirectToRoute.prototype.navigate = function navigate(appRouter) {
        var navigatingRouter = this.options.useAppRouter ? appRouter : this.router || appRouter;
        navigatingRouter.navigateToRoute(this.route, this.params, this.options);
      };

      return RedirectToRoute;
    }();

    var RouterConfiguration = exports.RouterConfiguration = function () {
      function RouterConfiguration() {

        this.instructions = [];
        this.options = {};
        this.pipelineSteps = [];
      }

      RouterConfiguration.prototype.addPipelineStep = function addPipelineStep(name, step) {
        this.pipelineSteps.push({ name: name, step: step });
        return this;
      };

      RouterConfiguration.prototype.addAuthorizeStep = function addAuthorizeStep(step) {
        return this.addPipelineStep('authorize', step);
      };

      RouterConfiguration.prototype.addPreActivateStep = function addPreActivateStep(step) {
        return this.addPipelineStep('preActivate', step);
      };

      RouterConfiguration.prototype.addPreRenderStep = function addPreRenderStep(step) {
        return this.addPipelineStep('preRender', step);
      };

      RouterConfiguration.prototype.addPostRenderStep = function addPostRenderStep(step) {
        return this.addPipelineStep('postRender', step);
      };

      RouterConfiguration.prototype.fallbackRoute = function fallbackRoute(fragment) {
        this._fallbackRoute = fragment;
        return this;
      };

      RouterConfiguration.prototype.map = function map(route) {
        if (Array.isArray(route)) {
          route.forEach(this.map.bind(this));
          return this;
        }

        return this.mapRoute(route);
      };

      RouterConfiguration.prototype.mapRoute = function mapRoute(config) {
        this.instructions.push(function (router) {
          var routeConfigs = [];

          if (Array.isArray(config.route)) {
            for (var i = 0, ii = config.route.length; i < ii; ++i) {
              var current = Object.assign({}, config);
              current.route = config.route[i];
              routeConfigs.push(current);
            }
          } else {
            routeConfigs.push(Object.assign({}, config));
          }

          var navModel = void 0;
          for (var _i = 0, _ii = routeConfigs.length; _i < _ii; ++_i) {
            var _routeConfig = routeConfigs[_i];
            _routeConfig.settings = _routeConfig.settings || {};
            if (!navModel) {
              navModel = router.createNavModel(_routeConfig);
            }

            router.addRoute(_routeConfig, navModel);
          }
        });

        return this;
      };

      RouterConfiguration.prototype.mapUnknownRoutes = function mapUnknownRoutes(config) {
        this.unknownRouteConfig = config;
        return this;
      };

      RouterConfiguration.prototype.exportToRouter = function exportToRouter(router) {
        var instructions = this.instructions;
        for (var i = 0, ii = instructions.length; i < ii; ++i) {
          instructions[i](router);
        }

        if (this.title) {
          router.title = this.title;
        }

        if (this.unknownRouteConfig) {
          router.handleUnknownRoutes(this.unknownRouteConfig);
        }

        if (this._fallbackRoute) {
          router.fallbackRoute = this._fallbackRoute;
        }

        router.options = this.options;

        var pipelineSteps = this.pipelineSteps;
        if (pipelineSteps.length) {
          if (!router.isRoot) {
            throw new Error('Pipeline steps can only be added to the root router');
          }

          var pipelineProvider = router.pipelineProvider;
          for (var _i2 = 0, _ii2 = pipelineSteps.length; _i2 < _ii2; ++_i2) {
            var _pipelineSteps$_i = pipelineSteps[_i2];
            var _name = _pipelineSteps$_i.name;
            var step = _pipelineSteps$_i.step;

            pipelineProvider.addStep(_name, step);
          }
        }
      };

      return RouterConfiguration;
    }();

    var activationStrategy = exports.activationStrategy = {
      noChange: 'no-change',
      invokeLifecycle: 'invoke-lifecycle',
      replace: 'replace'
    };

    var BuildNavigationPlanStep = exports.BuildNavigationPlanStep = function () {
      function BuildNavigationPlanStep() {}

      BuildNavigationPlanStep.prototype.run = function run(navigationInstruction, next) {
        return _buildNavigationPlan(navigationInstruction).then(function (plan) {
          navigationInstruction.plan = plan;
          return next();
        }).catch(next.cancel);
      };

      return BuildNavigationPlanStep;
    }();

    function _buildNavigationPlan(instruction, forceLifecycleMinimum) {
      var prev = instruction.previousInstruction;
      var config = instruction.config;
      var plan = {};

      if ('redirect' in config) {
        var redirectLocation = _resolveUrl(config.redirect, getInstructionBaseUrl(instruction));
        if (instruction.queryString) {
          redirectLocation += '?' + instruction.queryString;
        }

        return Promise.reject(new Redirect(redirectLocation));
      }

      if (prev) {
        var newParams = hasDifferentParameterValues(prev, instruction);
        var pending = [];

        var _loop2 = function _loop2(viewPortName) {
          var prevViewPortInstruction = prev.viewPortInstructions[viewPortName];
          var nextViewPortConfig = config.viewPorts[viewPortName];

          if (!nextViewPortConfig) throw new Error('Invalid Route Config: Configuration for viewPort "' + viewPortName + '" was not found for route: "' + instruction.config.route + '."');

          var viewPortPlan = plan[viewPortName] = {
            name: viewPortName,
            config: nextViewPortConfig,
            prevComponent: prevViewPortInstruction.component,
            prevModuleId: prevViewPortInstruction.moduleId
          };

          if (prevViewPortInstruction.moduleId !== nextViewPortConfig.moduleId) {
            viewPortPlan.strategy = activationStrategy.replace;
          } else if ('determineActivationStrategy' in prevViewPortInstruction.component.viewModel) {
            var _prevViewPortInstruct;

            viewPortPlan.strategy = (_prevViewPortInstruct = prevViewPortInstruction.component.viewModel).determineActivationStrategy.apply(_prevViewPortInstruct, instruction.lifecycleArgs);
          } else if (config.activationStrategy) {
            viewPortPlan.strategy = config.activationStrategy;
          } else if (newParams || forceLifecycleMinimum) {
            viewPortPlan.strategy = activationStrategy.invokeLifecycle;
          } else {
            viewPortPlan.strategy = activationStrategy.noChange;
          }

          if (viewPortPlan.strategy !== activationStrategy.replace && prevViewPortInstruction.childRouter) {
            var path = instruction.getWildcardPath();
            var task = prevViewPortInstruction.childRouter._createNavigationInstruction(path, instruction).then(function (childInstruction) {
              viewPortPlan.childNavigationInstruction = childInstruction;

              return _buildNavigationPlan(childInstruction, viewPortPlan.strategy === activationStrategy.invokeLifecycle).then(function (childPlan) {
                childInstruction.plan = childPlan;
              });
            });

            pending.push(task);
          }
        };

        for (var viewPortName in prev.viewPortInstructions) {
          _loop2(viewPortName);
        }

        return Promise.all(pending).then(function () {
          return plan;
        });
      }

      for (var _viewPortName in config.viewPorts) {
        plan[_viewPortName] = {
          name: _viewPortName,
          strategy: activationStrategy.replace,
          config: instruction.config.viewPorts[_viewPortName]
        };
      }

      return Promise.resolve(plan);
    }

    function hasDifferentParameterValues(prev, next) {
      var prevParams = prev.params;
      var nextParams = next.params;
      var nextWildCardName = next.config.hasChildRouter ? next.getWildCardName() : null;

      for (var key in nextParams) {
        if (key === nextWildCardName) {
          continue;
        }

        if (prevParams[key] !== nextParams[key]) {
          return true;
        }
      }

      for (var _key in prevParams) {
        if (_key === nextWildCardName) {
          continue;
        }

        if (prevParams[_key] !== nextParams[_key]) {
          return true;
        }
      }

      if (!next.options.compareQueryParams) {
        return false;
      }

      var prevQueryParams = prev.queryParams;
      var nextQueryParams = next.queryParams;
      for (var _key2 in nextQueryParams) {
        if (prevQueryParams[_key2] !== nextQueryParams[_key2]) {
          return true;
        }
      }

      for (var _key3 in prevQueryParams) {
        if (prevQueryParams[_key3] !== nextQueryParams[_key3]) {
          return true;
        }
      }

      return false;
    }

    function getInstructionBaseUrl(instruction) {
      var instructionBaseUrlParts = [];
      instruction = instruction.parentInstruction;

      while (instruction) {
        instructionBaseUrlParts.unshift(instruction.getBaseUrl());
        instruction = instruction.parentInstruction;
      }

      instructionBaseUrlParts.unshift('/');
      return instructionBaseUrlParts.join('');
    }

    var Router = exports.Router = function () {
      function Router(container, history) {
        var _this3 = this;

        this.parent = null;
        this.options = {};

        this.transformTitle = function (title) {
          if (_this3.parent) {
            return _this3.parent.transformTitle(title);
          }
          return title;
        };

        this.container = container;
        this.history = history;
        this.reset();
      }

      Router.prototype.reset = function reset() {
        var _this4 = this;

        this.viewPorts = {};
        this.routes = [];
        this.baseUrl = '';
        this.isConfigured = false;
        this.isNavigating = false;
        this.isExplicitNavigation = false;
        this.isExplicitNavigationBack = false;
        this.navigation = [];
        this.currentInstruction = null;
        this._fallbackOrder = 100;
        this._recognizer = new _aureliaRouteRecognizer.RouteRecognizer();
        this._childRecognizer = new _aureliaRouteRecognizer.RouteRecognizer();
        this._configuredPromise = new Promise(function (resolve) {
          _this4._resolveConfiguredPromise = resolve;
        });
      };

      Router.prototype.registerViewPort = function registerViewPort(viewPort, name) {
        name = name || 'default';
        this.viewPorts[name] = viewPort;
      };

      Router.prototype.ensureConfigured = function ensureConfigured() {
        return this._configuredPromise;
      };

      Router.prototype.configure = function configure(callbackOrConfig) {
        var _this5 = this;

        this.isConfigured = true;

        var result = callbackOrConfig;
        var config = void 0;
        if (typeof callbackOrConfig === 'function') {
          config = new RouterConfiguration();
          result = callbackOrConfig(config);
        }

        return Promise.resolve(result).then(function (c) {
          if (c && c.exportToRouter) {
            config = c;
          }

          config.exportToRouter(_this5);
          _this5.isConfigured = true;
          _this5._resolveConfiguredPromise();
        });
      };

      Router.prototype.navigate = function navigate(fragment, options) {
        if (!this.isConfigured && this.parent) {
          return this.parent.navigate(fragment, options);
        }

        this.isExplicitNavigation = true;
        return this.history.navigate(_resolveUrl(fragment, this.baseUrl, this.history._hasPushState), options);
      };

      Router.prototype.navigateToRoute = function navigateToRoute(route, params, options) {
        var path = this.generate(route, params);
        return this.navigate(path, options);
      };

      Router.prototype.navigateBack = function navigateBack() {
        this.isExplicitNavigationBack = true;
        this.history.navigateBack();
      };

      Router.prototype.createChild = function createChild(container) {
        var childRouter = new Router(container || this.container.createChild(), this.history);
        childRouter.parent = this;
        return childRouter;
      };

      Router.prototype.generate = function generate(name, params) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        var hasRoute = this._recognizer.hasRoute(name);
        if ((!this.isConfigured || !hasRoute) && this.parent) {
          return this.parent.generate(name, params);
        }

        if (!hasRoute) {
          throw new Error('A route with name \'' + name + '\' could not be found. Check that `name: \'' + name + '\'` was specified in the route\'s config.');
        }

        var path = this._recognizer.generate(name, params);
        var rootedPath = _createRootedPath(path, this.baseUrl, this.history._hasPushState, options.absolute);
        return options.absolute ? '' + this.history.getAbsoluteRoot() + rootedPath : rootedPath;
      };

      Router.prototype.createNavModel = function createNavModel(config) {
        var navModel = new NavModel(this, 'href' in config ? config.href : config.route);
        navModel.title = config.title;
        navModel.order = config.nav;
        navModel.href = config.href;
        navModel.settings = config.settings;
        navModel.config = config;

        return navModel;
      };

      Router.prototype.addRoute = function addRoute(config, navModel) {
        validateRouteConfig(config, this.routes);

        if (!('viewPorts' in config) && !config.navigationStrategy) {
          config.viewPorts = {
            'default': {
              moduleId: config.moduleId,
              view: config.view
            }
          };
        }

        if (!navModel) {
          navModel = this.createNavModel(config);
        }

        this.routes.push(config);

        var path = config.route;
        if (path.charAt(0) === '/') {
          path = path.substr(1);
        }
        var caseSensitive = config.caseSensitive === true;
        var state = this._recognizer.add({ path: path, handler: config, caseSensitive: caseSensitive });

        if (path) {
          var _settings = config.settings;
          delete config.settings;
          var withChild = JSON.parse(JSON.stringify(config));
          config.settings = _settings;
          withChild.route = path + '/*childRoute';
          withChild.hasChildRouter = true;
          this._childRecognizer.add({
            path: withChild.route,
            handler: withChild,
            caseSensitive: caseSensitive
          });

          withChild.navModel = navModel;
          withChild.settings = config.settings;
          withChild.navigationStrategy = config.navigationStrategy;
        }

        config.navModel = navModel;

        if ((navModel.order || navModel.order === 0) && this.navigation.indexOf(navModel) === -1) {
          if (!navModel.href && navModel.href !== '' && (state.types.dynamics || state.types.stars)) {
            throw new Error('Invalid route config for "' + config.route + '" : dynamic routes must specify an "href:" to be included in the navigation model.');
          }

          if (typeof navModel.order !== 'number') {
            navModel.order = ++this._fallbackOrder;
          }

          this.navigation.push(navModel);
          this.navigation = this.navigation.sort(function (a, b) {
            return a.order - b.order;
          });
        }
      };

      Router.prototype.hasRoute = function hasRoute(name) {
        return !!(this._recognizer.hasRoute(name) || this.parent && this.parent.hasRoute(name));
      };

      Router.prototype.hasOwnRoute = function hasOwnRoute(name) {
        return this._recognizer.hasRoute(name);
      };

      Router.prototype.handleUnknownRoutes = function handleUnknownRoutes(config) {
        var _this6 = this;

        if (!config) {
          throw new Error('Invalid unknown route handler');
        }

        this.catchAllHandler = function (instruction) {
          return _this6._createRouteConfig(config, instruction).then(function (c) {
            instruction.config = c;
            return instruction;
          });
        };
      };

      Router.prototype.updateTitle = function updateTitle() {
        if (this.parent) {
          return this.parent.updateTitle();
        }

        if (this.currentInstruction) {
          this.currentInstruction._updateTitle();
        }
        return undefined;
      };

      Router.prototype.refreshNavigation = function refreshNavigation() {
        var nav = this.navigation;

        for (var i = 0, length = nav.length; i < length; i++) {
          var current = nav[i];
          if (!current.config.href) {
            current.href = _createRootedPath(current.relativeHref, this.baseUrl, this.history._hasPushState);
          } else {
            current.href = _normalizeAbsolutePath(current.config.href, this.history._hasPushState);
          }
        }
      };

      Router.prototype._refreshBaseUrl = function _refreshBaseUrl() {
        if (this.parent) {
          var baseUrl = this.parent.currentInstruction.getBaseUrl();
          this.baseUrl = this.parent.baseUrl + baseUrl;
        }
      };

      Router.prototype._createNavigationInstruction = function _createNavigationInstruction() {
        var url = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
        var parentInstruction = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

        var fragment = url;
        var queryString = '';

        var queryIndex = url.indexOf('?');
        if (queryIndex !== -1) {
          fragment = url.substr(0, queryIndex);
          queryString = url.substr(queryIndex + 1);
        }

        var results = this._recognizer.recognize(url);
        if (!results || !results.length) {
          results = this._childRecognizer.recognize(url);
        }

        var instructionInit = {
          fragment: fragment,
          queryString: queryString,
          config: null,
          parentInstruction: parentInstruction,
          previousInstruction: this.currentInstruction,
          router: this,
          options: {
            compareQueryParams: this.options.compareQueryParams
          }
        };

        if (results && results.length) {
          var first = results[0];
          var _instruction = new NavigationInstruction(Object.assign({}, instructionInit, {
            params: first.params,
            queryParams: first.queryParams || results.queryParams,
            config: first.config || first.handler
          }));

          if (typeof first.handler === 'function') {
            return evaluateNavigationStrategy(_instruction, first.handler, first);
          } else if (first.handler && typeof first.handler.navigationStrategy === 'function') {
            return evaluateNavigationStrategy(_instruction, first.handler.navigationStrategy, first.handler);
          }

          return Promise.resolve(_instruction);
        } else if (this.catchAllHandler) {
          var _instruction2 = new NavigationInstruction(Object.assign({}, instructionInit, {
            params: { path: fragment },
            queryParams: results && results.queryParams,
            config: null }));

          return evaluateNavigationStrategy(_instruction2, this.catchAllHandler);
        }

        return Promise.reject(new Error('Route not found: ' + url));
      };

      Router.prototype._createRouteConfig = function _createRouteConfig(config, instruction) {
        var _this7 = this;

        return Promise.resolve(config).then(function (c) {
          if (typeof c === 'string') {
            return { moduleId: c };
          } else if (typeof c === 'function') {
            return c(instruction);
          }

          return c;
        }).then(function (c) {
          return typeof c === 'string' ? { moduleId: c } : c;
        }).then(function (c) {
          c.route = instruction.params.path;
          validateRouteConfig(c, _this7.routes);

          if (!c.navModel) {
            c.navModel = _this7.createNavModel(c);
          }

          return c;
        });
      };

      _createClass(Router, [{
        key: 'isRoot',
        get: function get() {
          return !this.parent;
        }
      }]);

      return Router;
    }();

    function validateRouteConfig(config, routes) {
      if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
        throw new Error('Invalid Route Config');
      }

      if (typeof config.route !== 'string') {
        var _name2 = config.name || '(no name)';
        throw new Error('Invalid Route Config for "' + _name2 + '": You must specify a "route:" pattern.');
      }

      if (!('redirect' in config || config.moduleId || config.navigationStrategy || config.viewPorts)) {
        throw new Error('Invalid Route Config for "' + config.route + '": You must specify a "moduleId:", "redirect:", "navigationStrategy:", or "viewPorts:".');
      }
    }

    function evaluateNavigationStrategy(instruction, evaluator, context) {
      return Promise.resolve(evaluator.call(context, instruction)).then(function () {
        if (!('viewPorts' in instruction.config)) {
          instruction.config.viewPorts = {
            'default': {
              moduleId: instruction.config.moduleId
            }
          };
        }

        return instruction;
      });
    }

    var CanDeactivatePreviousStep = exports.CanDeactivatePreviousStep = function () {
      function CanDeactivatePreviousStep() {}

      CanDeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {
        return processDeactivatable(navigationInstruction.plan, 'canDeactivate', next);
      };

      return CanDeactivatePreviousStep;
    }();

    var CanActivateNextStep = exports.CanActivateNextStep = function () {
      function CanActivateNextStep() {}

      CanActivateNextStep.prototype.run = function run(navigationInstruction, next) {
        return processActivatable(navigationInstruction, 'canActivate', next);
      };

      return CanActivateNextStep;
    }();

    var DeactivatePreviousStep = exports.DeactivatePreviousStep = function () {
      function DeactivatePreviousStep() {}

      DeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {
        return processDeactivatable(navigationInstruction.plan, 'deactivate', next, true);
      };

      return DeactivatePreviousStep;
    }();

    var ActivateNextStep = exports.ActivateNextStep = function () {
      function ActivateNextStep() {}

      ActivateNextStep.prototype.run = function run(navigationInstruction, next) {
        return processActivatable(navigationInstruction, 'activate', next, true);
      };

      return ActivateNextStep;
    }();

    function processDeactivatable(plan, callbackName, next, ignoreResult) {
      var infos = findDeactivatable(plan, callbackName);
      var i = infos.length;

      function inspect(val) {
        if (ignoreResult || shouldContinue(val)) {
          return iterate();
        }

        return next.cancel(val);
      }

      function iterate() {
        if (i--) {
          try {
            var viewModel = infos[i];
            var _result = viewModel[callbackName]();
            return processPotential(_result, inspect, next.cancel);
          } catch (error) {
            return next.cancel(error);
          }
        }

        return next();
      }

      return iterate();
    }

    function findDeactivatable(plan, callbackName) {
      var list = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

      for (var viewPortName in plan) {
        var _viewPortPlan = plan[viewPortName];
        var prevComponent = _viewPortPlan.prevComponent;

        if ((_viewPortPlan.strategy === activationStrategy.invokeLifecycle || _viewPortPlan.strategy === activationStrategy.replace) && prevComponent) {
          var viewModel = prevComponent.viewModel;

          if (callbackName in viewModel) {
            list.push(viewModel);
          }
        }

        if (_viewPortPlan.childNavigationInstruction) {
          findDeactivatable(_viewPortPlan.childNavigationInstruction.plan, callbackName, list);
        } else if (prevComponent) {
          addPreviousDeactivatable(prevComponent, callbackName, list);
        }
      }

      return list;
    }

    function addPreviousDeactivatable(component, callbackName, list) {
      var childRouter = component.childRouter;

      if (childRouter && childRouter.currentInstruction) {
        var viewPortInstructions = childRouter.currentInstruction.viewPortInstructions;

        for (var viewPortName in viewPortInstructions) {
          var _viewPortInstruction2 = viewPortInstructions[viewPortName];
          var prevComponent = _viewPortInstruction2.component;
          var prevViewModel = prevComponent.viewModel;

          if (callbackName in prevViewModel) {
            list.push(prevViewModel);
          }

          addPreviousDeactivatable(prevComponent, callbackName, list);
        }
      }
    }

    function processActivatable(navigationInstruction, callbackName, next, ignoreResult) {
      var infos = findActivatable(navigationInstruction, callbackName);
      var length = infos.length;
      var i = -1;

      function inspect(val, router) {
        if (ignoreResult || shouldContinue(val, router)) {
          return iterate();
        }

        return next.cancel(val);
      }

      function iterate() {
        i++;

        if (i < length) {
          try {
            var _ret3 = function () {
              var _current$viewModel;

              var current = infos[i];
              var result = (_current$viewModel = current.viewModel)[callbackName].apply(_current$viewModel, current.lifecycleArgs);
              return {
                v: processPotential(result, function (val) {
                  return inspect(val, current.router);
                }, next.cancel)
              };
            }();

            if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === "object") return _ret3.v;
          } catch (error) {
            return next.cancel(error);
          }
        }

        return next();
      }

      return iterate();
    }

    function findActivatable(navigationInstruction, callbackName) {
      var list = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
      var router = arguments[3];

      var plan = navigationInstruction.plan;

      Object.keys(plan).filter(function (viewPortName) {
        var viewPortPlan = plan[viewPortName];
        var viewPortInstruction = navigationInstruction.viewPortInstructions[viewPortName];
        var viewModel = viewPortInstruction.component.viewModel;

        if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle || viewPortPlan.strategy === activationStrategy.replace) && callbackName in viewModel) {
          list.push({
            viewModel: viewModel,
            lifecycleArgs: viewPortInstruction.lifecycleArgs,
            router: router
          });
        }

        if (viewPortPlan.childNavigationInstruction) {
          findActivatable(viewPortPlan.childNavigationInstruction, callbackName, list, viewPortInstruction.component.childRouter || router);
        }
      });

      return list;
    }

    function shouldContinue(output, router) {
      if (output instanceof Error) {
        return false;
      }

      if (isNavigationCommand(output)) {
        if (typeof output.setRouter === 'function') {
          output.setRouter(router);
        }

        return !!output.shouldContinueProcessing;
      }

      if (output === undefined) {
        return true;
      }

      return output;
    }

    var SafeSubscription = function () {
      function SafeSubscription(subscriptionFunc) {

        this._subscribed = true;
        this._subscription = subscriptionFunc(this);

        if (!this._subscribed) this.unsubscribe();
      }

      SafeSubscription.prototype.unsubscribe = function unsubscribe() {
        if (this._subscribed && this._subscription) this._subscription.unsubscribe();

        this._subscribed = false;
      };

      _createClass(SafeSubscription, [{
        key: 'subscribed',
        get: function get() {
          return this._subscribed;
        }
      }]);

      return SafeSubscription;
    }();

    function processPotential(obj, resolve, reject) {
      if (obj && typeof obj.then === 'function') {
        return Promise.resolve(obj).then(resolve).catch(reject);
      }

      if (obj && typeof obj.subscribe === 'function') {
        var _ret4 = function () {
          var obs = obj;
          return {
            v: new SafeSubscription(function (sub) {
              return obs.subscribe({
                next: function next() {
                  if (sub.subscribed) {
                    sub.unsubscribe();
                    resolve(obj);
                  }
                },
                error: function error(_error) {
                  if (sub.subscribed) {
                    sub.unsubscribe();
                    reject(_error);
                  }
                },
                complete: function complete() {
                  if (sub.subscribed) {
                    sub.unsubscribe();
                    resolve(obj);
                  }
                }
              });
            })
          };
        }();

        if ((typeof _ret4 === 'undefined' ? 'undefined' : _typeof(_ret4)) === "object") return _ret4.v;
      }

      try {
        return resolve(obj);
      } catch (error) {
        return reject(error);
      }
    }

    var RouteLoader = exports.RouteLoader = function () {
      function RouteLoader() {}

      RouteLoader.prototype.loadRoute = function loadRoute(router, config, navigationInstruction) {
        throw Error('Route loaders must implement "loadRoute(router, config, navigationInstruction)".');
      };

      return RouteLoader;
    }();

    var LoadRouteStep = exports.LoadRouteStep = function () {
      LoadRouteStep.inject = function inject() {
        return [RouteLoader];
      };

      function LoadRouteStep(routeLoader) {

        this.routeLoader = routeLoader;
      }

      LoadRouteStep.prototype.run = function run(navigationInstruction, next) {
        return loadNewRoute(this.routeLoader, navigationInstruction).then(next).catch(next.cancel);
      };

      return LoadRouteStep;
    }();

    function loadNewRoute(routeLoader, navigationInstruction) {
      var toLoad = determineWhatToLoad(navigationInstruction);
      var loadPromises = toLoad.map(function (current) {
        return loadRoute(routeLoader, current.navigationInstruction, current.viewPortPlan);
      });

      return Promise.all(loadPromises);
    }

    function determineWhatToLoad(navigationInstruction) {
      var toLoad = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

      var plan = navigationInstruction.plan;

      for (var viewPortName in plan) {
        var _viewPortPlan2 = plan[viewPortName];

        if (_viewPortPlan2.strategy === activationStrategy.replace) {
          toLoad.push({ viewPortPlan: _viewPortPlan2, navigationInstruction: navigationInstruction });

          if (_viewPortPlan2.childNavigationInstruction) {
            determineWhatToLoad(_viewPortPlan2.childNavigationInstruction, toLoad);
          }
        } else {
          var _viewPortInstruction3 = navigationInstruction.addViewPortInstruction(viewPortName, _viewPortPlan2.strategy, _viewPortPlan2.prevModuleId, _viewPortPlan2.prevComponent);

          if (_viewPortPlan2.childNavigationInstruction) {
            _viewPortInstruction3.childNavigationInstruction = _viewPortPlan2.childNavigationInstruction;
            determineWhatToLoad(_viewPortPlan2.childNavigationInstruction, toLoad);
          }
        }
      }

      return toLoad;
    }

    function loadRoute(routeLoader, navigationInstruction, viewPortPlan) {
      var moduleId = viewPortPlan.config.moduleId;

      return loadComponent(routeLoader, navigationInstruction, viewPortPlan.config).then(function (component) {
        var viewPortInstruction = navigationInstruction.addViewPortInstruction(viewPortPlan.name, viewPortPlan.strategy, moduleId, component);

        var childRouter = component.childRouter;
        if (childRouter) {
          var path = navigationInstruction.getWildcardPath();

          return childRouter._createNavigationInstruction(path, navigationInstruction).then(function (childInstruction) {
            viewPortPlan.childNavigationInstruction = childInstruction;

            return _buildNavigationPlan(childInstruction).then(function (childPlan) {
              childInstruction.plan = childPlan;
              viewPortInstruction.childNavigationInstruction = childInstruction;

              return loadNewRoute(routeLoader, childInstruction);
            });
          });
        }

        return undefined;
      });
    }

    function loadComponent(routeLoader, navigationInstruction, config) {
      var router = navigationInstruction.router;
      var lifecycleArgs = navigationInstruction.lifecycleArgs;

      return routeLoader.loadRoute(router, config, navigationInstruction).then(function (component) {
        var viewModel = component.viewModel;
        var childContainer = component.childContainer;

        component.router = router;
        component.config = config;

        if ('configureRouter' in viewModel) {
          var _ret5 = function () {
            var childRouter = childContainer.getChildRouter();
            component.childRouter = childRouter;

            return {
              v: childRouter.configure(function (c) {
                return viewModel.configureRouter.apply(viewModel, [c, childRouter].concat(lifecycleArgs));
              }).then(function () {
                return component;
              })
            };
          }();

          if ((typeof _ret5 === 'undefined' ? 'undefined' : _typeof(_ret5)) === "object") return _ret5.v;
        }

        return component;
      });
    }

    var PipelineSlot = function () {
      function PipelineSlot(container, name, alias) {

        this.steps = [];

        this.container = container;
        this.slotName = name;
        this.slotAlias = alias;
      }

      PipelineSlot.prototype.getSteps = function getSteps() {
        var _this8 = this;

        return this.steps.map(function (x) {
          return _this8.container.get(x);
        });
      };

      return PipelineSlot;
    }();

    var PipelineProvider = exports.PipelineProvider = function () {
      PipelineProvider.inject = function inject() {
        return [_aureliaDependencyInjection.Container];
      };

      function PipelineProvider(container) {

        this.container = container;
        this.steps = [BuildNavigationPlanStep, CanDeactivatePreviousStep, LoadRouteStep, this._createPipelineSlot('authorize'), CanActivateNextStep, this._createPipelineSlot('preActivate', 'modelbind'), DeactivatePreviousStep, ActivateNextStep, this._createPipelineSlot('preRender', 'precommit'), CommitChangesStep, this._createPipelineSlot('postRender', 'postcomplete')];
      }

      PipelineProvider.prototype.createPipeline = function createPipeline() {
        var _this9 = this;

        var pipeline = new Pipeline();
        this.steps.forEach(function (step) {
          return pipeline.addStep(_this9.container.get(step));
        });
        return pipeline;
      };

      PipelineProvider.prototype._findStep = function _findStep(name) {
        return this.steps.find(function (x) {
          return x.slotName === name || x.slotAlias === name;
        });
      };

      PipelineProvider.prototype.addStep = function addStep(name, step) {
        var found = this._findStep(name);
        if (found) {
          if (!found.steps.includes(step)) {
            found.steps.push(step);
          }
        } else {
          throw new Error('Invalid pipeline slot name: ' + name + '.');
        }
      };

      PipelineProvider.prototype.removeStep = function removeStep(name, step) {
        var slot = this._findStep(name);
        if (slot) {
          slot.steps.splice(slot.steps.indexOf(step), 1);
        }
      };

      PipelineProvider.prototype._clearSteps = function _clearSteps() {
        var name = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

        var slot = this._findStep(name);
        if (slot) {
          slot.steps = [];
        }
      };

      PipelineProvider.prototype.reset = function reset() {
        this._clearSteps('authorize');
        this._clearSteps('preActivate');
        this._clearSteps('preRender');
        this._clearSteps('postRender');
      };

      PipelineProvider.prototype._createPipelineSlot = function _createPipelineSlot(name, alias) {
        return new PipelineSlot(this.container, name, alias);
      };

      return PipelineProvider;
    }();

    var logger = LogManager.getLogger('app-router');

    var AppRouter = exports.AppRouter = function (_Router) {
      _inherits(AppRouter, _Router);

      AppRouter.inject = function inject() {
        return [_aureliaDependencyInjection.Container, _aureliaHistory.History, PipelineProvider, _aureliaEventAggregator.EventAggregator];
      };

      function AppRouter(container, history, pipelineProvider, events) {

        var _this10 = _possibleConstructorReturn(this, _Router.call(this, container, history));

        _this10.pipelineProvider = pipelineProvider;
        _this10.events = events;
        return _this10;
      }

      AppRouter.prototype.reset = function reset() {
        _Router.prototype.reset.call(this);
        this.maxInstructionCount = 10;
        if (!this._queue) {
          this._queue = [];
        } else {
          this._queue.length = 0;
        }
      };

      AppRouter.prototype.loadUrl = function loadUrl(url) {
        var _this11 = this;

        return this._createNavigationInstruction(url).then(function (instruction) {
          return _this11._queueInstruction(instruction);
        }).catch(function (error) {
          logger.error(error);
          restorePreviousLocation(_this11);
        });
      };

      AppRouter.prototype.registerViewPort = function registerViewPort(viewPort, name) {
        var _this12 = this;

        _Router.prototype.registerViewPort.call(this, viewPort, name);

        if (!this.isActive) {
          var _ret6 = function () {
            var viewModel = _this12._findViewModel(viewPort);
            if ('configureRouter' in viewModel) {
              if (!_this12.isConfigured) {
                var _ret7 = function () {
                  var resolveConfiguredPromise = _this12._resolveConfiguredPromise;
                  _this12._resolveConfiguredPromise = function () {};
                  return {
                    v: {
                      v: _this12.configure(function (config) {
                        return viewModel.configureRouter(config, _this12);
                      }).then(function () {
                        _this12.activate();
                        resolveConfiguredPromise();
                      })
                    }
                  };
                }();

                if ((typeof _ret7 === 'undefined' ? 'undefined' : _typeof(_ret7)) === "object") return _ret7.v;
              }
            } else {
              _this12.activate();
            }
          }();

          if ((typeof _ret6 === 'undefined' ? 'undefined' : _typeof(_ret6)) === "object") return _ret6.v;
        } else {
          this._dequeueInstruction();
        }

        return Promise.resolve();
      };

      AppRouter.prototype.activate = function activate(options) {
        if (this.isActive) {
          return;
        }

        this.isActive = true;
        this.options = Object.assign({ routeHandler: this.loadUrl.bind(this) }, this.options, options);
        this.history.activate(this.options);
        this._dequeueInstruction();
      };

      AppRouter.prototype.deactivate = function deactivate() {
        this.isActive = false;
        this.history.deactivate();
      };

      AppRouter.prototype._queueInstruction = function _queueInstruction(instruction) {
        var _this13 = this;

        return new Promise(function (resolve) {
          instruction.resolve = resolve;
          _this13._queue.unshift(instruction);
          _this13._dequeueInstruction();
        });
      };

      AppRouter.prototype._dequeueInstruction = function _dequeueInstruction() {
        var _this14 = this;

        var instructionCount = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

        return Promise.resolve().then(function () {
          if (_this14.isNavigating && !instructionCount) {
            return undefined;
          }

          var instruction = _this14._queue.shift();
          _this14._queue.length = 0;

          if (!instruction) {
            return undefined;
          }

          _this14.isNavigating = true;
          instruction.previousInstruction = _this14.currentInstruction;

          if (!instructionCount) {
            _this14.events.publish('router:navigation:processing', { instruction: instruction });
          } else if (instructionCount === _this14.maxInstructionCount - 1) {
            logger.error(instructionCount + 1 + ' navigation instructions have been attempted without success. Restoring last known good location.');
            restorePreviousLocation(_this14);
            return _this14._dequeueInstruction(instructionCount + 1);
          } else if (instructionCount > _this14.maxInstructionCount) {
            throw new Error('Maximum navigation attempts exceeded. Giving up.');
          }

          var pipeline = _this14.pipelineProvider.createPipeline();

          return pipeline.run(instruction).then(function (result) {
            return processResult(instruction, result, instructionCount, _this14);
          }).catch(function (error) {
            return { output: error instanceof Error ? error : new Error(error) };
          }).then(function (result) {
            return resolveInstruction(instruction, result, !!instructionCount, _this14);
          });
        });
      };

      AppRouter.prototype._findViewModel = function _findViewModel(viewPort) {
        if (this.container.viewModel) {
          return this.container.viewModel;
        }

        if (viewPort.container) {
          var container = viewPort.container;

          while (container) {
            if (container.viewModel) {
              this.container.viewModel = container.viewModel;
              return container.viewModel;
            }

            container = container.parent;
          }
        }

        return undefined;
      };

      return AppRouter;
    }(Router);

    function processResult(instruction, result, instructionCount, router) {
      if (!(result && 'completed' in result && 'output' in result)) {
        result = result || {};
        result.output = new Error('Expected router pipeline to return a navigation result, but got [' + JSON.stringify(result) + '] instead.');
      }

      var finalResult = null;
      if (isNavigationCommand(result.output)) {
        result.output.navigate(router);
      } else {
        finalResult = result;

        if (!result.completed) {
          if (result.output instanceof Error) {
            logger.error(result.output);
          }

          restorePreviousLocation(router);
        }
      }

      return router._dequeueInstruction(instructionCount + 1).then(function (innerResult) {
        return finalResult || innerResult || result;
      });
    }

    function resolveInstruction(instruction, result, isInnerInstruction, router) {
      instruction.resolve(result);

      var eventArgs = { instruction: instruction, result: result };
      if (!isInnerInstruction) {
        router.isNavigating = false;
        router.isExplicitNavigation = false;
        router.isExplicitNavigationBack = false;

        var eventName = void 0;

        if (result.output instanceof Error) {
          eventName = 'error';
        } else if (!result.completed) {
          eventName = 'canceled';
        } else {
          var _queryString = instruction.queryString ? '?' + instruction.queryString : '';
          router.history.previousLocation = instruction.fragment + _queryString;
          eventName = 'success';
        }

        router.events.publish('router:navigation:' + eventName, eventArgs);
        router.events.publish('router:navigation:complete', eventArgs);
      } else {
        router.events.publish('router:navigation:child:complete', eventArgs);
      }

      return result;
    }

    function restorePreviousLocation(router) {
      var previousLocation = router.history.previousLocation;
      if (previousLocation) {
        router.navigate(router.history.previousLocation, { trigger: false, replace: true });
      } else if (router.fallbackRoute) {
        router.navigate(router.fallbackRoute, { trigger: true, replace: true });
      } else {
        logger.error('Router navigation failed, and no previous location or fallbackRoute could be restored.');
      }
    }
  }).call($__exports, $__exports, $__require('aurelia-logging'), $__require('aurelia-route-recognizer'), $__require('aurelia-dependency-injection'), $__require('aurelia-history'), $__require('aurelia-event-aggregator'));
});
System.registerDynamic("npm:jspm-nodelibs-process@0.2.1.json", [], true, function() {
  return {
    "main": "./process.js"
  };
});

System.registerDynamic('npm:jspm-nodelibs-process@0.2.1/process.js', ['@system-env'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    // From https://github.com/defunctzombie/node-process/blob/master/browser.js
    // shim for using process in browser

    var productionEnv = $__require('@system-env').production;

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {
        NODE_ENV: productionEnv ? 'production' : 'development'
    };
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
});
System.registerDynamic("npm:core-js@2.4.1.json", [], true, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./build": "./build/index.js",
      "./core": "./core/index.js",
      "./es5": "./es5/index.js",
      "./es6": "./es6/index.js",
      "./es7": "./es7/index.js",
      "./fn/array": "./fn/array/index.js",
      "./fn/array/virtual": "./fn/array/virtual/index.js",
      "./fn/date": "./fn/date/index.js",
      "./fn/dom-collections": "./fn/dom-collections/index.js",
      "./fn/error": "./fn/error/index.js",
      "./fn/function": "./fn/function/index.js",
      "./fn/function/virtual": "./fn/function/virtual/index.js",
      "./fn/json": "./fn/json/index.js",
      "./fn/math": "./fn/math/index.js",
      "./fn/number": "./fn/number/index.js",
      "./fn/number/virtual": "./fn/number/virtual/index.js",
      "./fn/object": "./fn/object/index.js",
      "./fn/reflect": "./fn/reflect/index.js",
      "./fn/regexp": "./fn/regexp/index.js",
      "./fn/string": "./fn/string/index.js",
      "./fn/string/virtual": "./fn/string/virtual/index.js",
      "./fn/symbol": "./fn/symbol/index.js",
      "./fn/system": "./fn/system/index.js",
      "./fn/typed": "./fn/typed/index.js",
      "./library": "./library/index.js",
      "./library/core": "./library/core/index.js",
      "./library/es5": "./library/es5/index.js",
      "./library/es6": "./library/es6/index.js",
      "./library/es7": "./library/es7/index.js",
      "./library/fn/array": "./library/fn/array/index.js",
      "./library/fn/array/virtual": "./library/fn/array/virtual/index.js",
      "./library/fn/date": "./library/fn/date/index.js",
      "./library/fn/dom-collections": "./library/fn/dom-collections/index.js",
      "./library/fn/error": "./library/fn/error/index.js",
      "./library/fn/function": "./library/fn/function/index.js",
      "./library/fn/function/virtual": "./library/fn/function/virtual/index.js",
      "./library/fn/json": "./library/fn/json/index.js",
      "./library/fn/math": "./library/fn/math/index.js",
      "./library/fn/number": "./library/fn/number/index.js",
      "./library/fn/number/virtual": "./library/fn/number/virtual/index.js",
      "./library/fn/object": "./library/fn/object/index.js",
      "./library/fn/reflect": "./library/fn/reflect/index.js",
      "./library/fn/regexp": "./library/fn/regexp/index.js",
      "./library/fn/string": "./library/fn/string/index.js",
      "./library/fn/string/virtual": "./library/fn/string/virtual/index.js",
      "./library/fn/symbol": "./library/fn/symbol/index.js",
      "./library/fn/system": "./library/fn/system/index.js",
      "./library/fn/typed": "./library/fn/typed/index.js",
      "./library/stage": "./library/stage/index.js",
      "./library/web": "./library/web/index.js",
      "./package": "./package.json",
      "./stage": "./stage/index.js",
      "./web": "./web/index.js"
    }
  };
});

System.registerDynamic('npm:core-js@2.4.1/client/core.js', ['process'], true, function ($__require, exports, module) {
	var process = $__require('process');
	var global = this || self,
	    GLOBAL = global;
	/**
  * core-js 2.4.1
  * https://github.com/zloirock/core-js
  * License: http://rock.mit-license.org
  * © 2016 Denis Pushkarev
  */
	!function (__e, __g, undefined) {
		'use strict';
		/******/
		(function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};

			/******/ // The require function
			/******/function __webpack_require__(moduleId) {

				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;

				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };

				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

				/******/ // Flag the module as loaded
				/******/module.loaded = true;

				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}

			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;

			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;

			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";

			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		})(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(1);
			__webpack_require__(50);
			__webpack_require__(51);
			__webpack_require__(52);
			__webpack_require__(54);
			__webpack_require__(55);
			__webpack_require__(58);
			__webpack_require__(59);
			__webpack_require__(60);
			__webpack_require__(61);
			__webpack_require__(62);
			__webpack_require__(63);
			__webpack_require__(64);
			__webpack_require__(65);
			__webpack_require__(66);
			__webpack_require__(68);
			__webpack_require__(70);
			__webpack_require__(72);
			__webpack_require__(74);
			__webpack_require__(77);
			__webpack_require__(78);
			__webpack_require__(79);
			__webpack_require__(83);
			__webpack_require__(86);
			__webpack_require__(87);
			__webpack_require__(88);
			__webpack_require__(89);
			__webpack_require__(91);
			__webpack_require__(92);
			__webpack_require__(93);
			__webpack_require__(94);
			__webpack_require__(95);
			__webpack_require__(97);
			__webpack_require__(99);
			__webpack_require__(100);
			__webpack_require__(101);
			__webpack_require__(103);
			__webpack_require__(104);
			__webpack_require__(105);
			__webpack_require__(107);
			__webpack_require__(108);
			__webpack_require__(109);
			__webpack_require__(111);
			__webpack_require__(112);
			__webpack_require__(113);
			__webpack_require__(114);
			__webpack_require__(115);
			__webpack_require__(116);
			__webpack_require__(117);
			__webpack_require__(118);
			__webpack_require__(119);
			__webpack_require__(120);
			__webpack_require__(121);
			__webpack_require__(122);
			__webpack_require__(123);
			__webpack_require__(124);
			__webpack_require__(126);
			__webpack_require__(130);
			__webpack_require__(131);
			__webpack_require__(132);
			__webpack_require__(133);
			__webpack_require__(137);
			__webpack_require__(139);
			__webpack_require__(140);
			__webpack_require__(141);
			__webpack_require__(142);
			__webpack_require__(143);
			__webpack_require__(144);
			__webpack_require__(145);
			__webpack_require__(146);
			__webpack_require__(147);
			__webpack_require__(148);
			__webpack_require__(149);
			__webpack_require__(150);
			__webpack_require__(151);
			__webpack_require__(152);
			__webpack_require__(158);
			__webpack_require__(159);
			__webpack_require__(161);
			__webpack_require__(162);
			__webpack_require__(163);
			__webpack_require__(167);
			__webpack_require__(168);
			__webpack_require__(169);
			__webpack_require__(170);
			__webpack_require__(171);
			__webpack_require__(173);
			__webpack_require__(174);
			__webpack_require__(175);
			__webpack_require__(176);
			__webpack_require__(179);
			__webpack_require__(181);
			__webpack_require__(182);
			__webpack_require__(183);
			__webpack_require__(185);
			__webpack_require__(187);
			__webpack_require__(189);
			__webpack_require__(190);
			__webpack_require__(191);
			__webpack_require__(193);
			__webpack_require__(194);
			__webpack_require__(195);
			__webpack_require__(196);
			__webpack_require__(203);
			__webpack_require__(206);
			__webpack_require__(207);
			__webpack_require__(209);
			__webpack_require__(210);
			__webpack_require__(211);
			__webpack_require__(212);
			__webpack_require__(213);
			__webpack_require__(214);
			__webpack_require__(215);
			__webpack_require__(216);
			__webpack_require__(217);
			__webpack_require__(218);
			__webpack_require__(219);
			__webpack_require__(220);
			__webpack_require__(222);
			__webpack_require__(223);
			__webpack_require__(224);
			__webpack_require__(225);
			__webpack_require__(226);
			__webpack_require__(227);
			__webpack_require__(228);
			__webpack_require__(229);
			__webpack_require__(231);
			__webpack_require__(234);
			__webpack_require__(235);
			__webpack_require__(237);
			__webpack_require__(238);
			__webpack_require__(239);
			__webpack_require__(240);
			__webpack_require__(241);
			__webpack_require__(242);
			__webpack_require__(243);
			__webpack_require__(244);
			__webpack_require__(245);
			__webpack_require__(246);
			__webpack_require__(247);
			__webpack_require__(249);
			__webpack_require__(250);
			__webpack_require__(251);
			__webpack_require__(252);
			__webpack_require__(253);
			__webpack_require__(254);
			__webpack_require__(255);
			__webpack_require__(256);
			__webpack_require__(258);
			__webpack_require__(259);
			__webpack_require__(261);
			__webpack_require__(262);
			__webpack_require__(263);
			__webpack_require__(264);
			__webpack_require__(267);
			__webpack_require__(268);
			__webpack_require__(269);
			__webpack_require__(270);
			__webpack_require__(271);
			__webpack_require__(272);
			__webpack_require__(273);
			__webpack_require__(274);
			__webpack_require__(276);
			__webpack_require__(277);
			__webpack_require__(278);
			__webpack_require__(279);
			__webpack_require__(280);
			__webpack_require__(281);
			__webpack_require__(282);
			__webpack_require__(283);
			__webpack_require__(284);
			__webpack_require__(285);
			__webpack_require__(286);
			__webpack_require__(287);
			__webpack_require__(288);
			__webpack_require__(291);
			__webpack_require__(156);
			__webpack_require__(293);
			__webpack_require__(292);
			__webpack_require__(294);
			__webpack_require__(295);
			__webpack_require__(296);
			__webpack_require__(297);
			__webpack_require__(298);
			__webpack_require__(300);
			__webpack_require__(301);
			__webpack_require__(302);
			__webpack_require__(304);
			module.exports = __webpack_require__(305);

			/***/
		},
		/* 1 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// ECMAScript 6 symbols shim

			var global = __webpack_require__(2),
			    has = __webpack_require__(3),
			    DESCRIPTORS = __webpack_require__(4),
			    $export = __webpack_require__(6),
			    redefine = __webpack_require__(16),
			    META = __webpack_require__(20).KEY,
			    $fails = __webpack_require__(5),
			    shared = __webpack_require__(21),
			    setToStringTag = __webpack_require__(22),
			    uid = __webpack_require__(17),
			    wks = __webpack_require__(23),
			    wksExt = __webpack_require__(24),
			    wksDefine = __webpack_require__(25),
			    keyOf = __webpack_require__(27),
			    enumKeys = __webpack_require__(40),
			    isArray = __webpack_require__(43),
			    anObject = __webpack_require__(10),
			    toIObject = __webpack_require__(30),
			    toPrimitive = __webpack_require__(14),
			    createDesc = __webpack_require__(15),
			    _create = __webpack_require__(44),
			    gOPNExt = __webpack_require__(47),
			    $GOPD = __webpack_require__(49),
			    $DP = __webpack_require__(9),
			    $keys = __webpack_require__(28),
			    gOPD = $GOPD.f,
			    dP = $DP.f,
			    gOPN = gOPNExt.f,
			    $Symbol = global.Symbol,
			    $JSON = global.JSON,
			    _stringify = $JSON && $JSON.stringify,
			    PROTOTYPE = 'prototype',
			    HIDDEN = wks('_hidden'),
			    TO_PRIMITIVE = wks('toPrimitive'),
			    isEnum = {}.propertyIsEnumerable,
			    SymbolRegistry = shared('symbol-registry'),
			    AllSymbols = shared('symbols'),
			    OPSymbols = shared('op-symbols'),
			    ObjectProto = Object[PROTOTYPE],
			    USE_NATIVE = typeof $Symbol == 'function',
			    QObject = global.QObject;
			// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
			var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

			// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
			var setSymbolDesc = DESCRIPTORS && $fails(function () {
				return _create(dP({}, 'a', {
					get: function () {
						return dP(this, 'a', { value: 7 }).a;
					}
				})).a != 7;
			}) ? function (it, key, D) {
				var protoDesc = gOPD(ObjectProto, key);
				if (protoDesc) delete ObjectProto[key];
				dP(it, key, D);
				if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
			} : dP;

			var wrap = function (tag) {
				var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
				sym._k = tag;
				return sym;
			};

			var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
				return typeof it == 'symbol';
			} : function (it) {
				return it instanceof $Symbol;
			};

			var $defineProperty = function defineProperty(it, key, D) {
				if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
				anObject(it);
				key = toPrimitive(key, true);
				anObject(D);
				if (has(AllSymbols, key)) {
					if (!D.enumerable) {
						if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
						it[HIDDEN][key] = true;
					} else {
						if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
						D = _create(D, { enumerable: createDesc(0, false) });
					}return setSymbolDesc(it, key, D);
				}return dP(it, key, D);
			};
			var $defineProperties = function defineProperties(it, P) {
				anObject(it);
				var keys = enumKeys(P = toIObject(P)),
				    i = 0,
				    l = keys.length,
				    key;
				while (l > i) $defineProperty(it, key = keys[i++], P[key]);
				return it;
			};
			var $create = function create(it, P) {
				return P === undefined ? _create(it) : $defineProperties(_create(it), P);
			};
			var $propertyIsEnumerable = function propertyIsEnumerable(key) {
				var E = isEnum.call(this, key = toPrimitive(key, true));
				if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
				return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
			};
			var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
				it = toIObject(it);
				key = toPrimitive(key, true);
				if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
				var D = gOPD(it, key);
				if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
				return D;
			};
			var $getOwnPropertyNames = function getOwnPropertyNames(it) {
				var names = gOPN(toIObject(it)),
				    result = [],
				    i = 0,
				    key;
				while (names.length > i) {
					if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
				}return result;
			};
			var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
				var IS_OP = it === ObjectProto,
				    names = gOPN(IS_OP ? OPSymbols : toIObject(it)),
				    result = [],
				    i = 0,
				    key;
				while (names.length > i) {
					if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
				}return result;
			};

			// 19.4.1.1 Symbol([description])
			if (!USE_NATIVE) {
				$Symbol = function Symbol() {
					if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
					var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
					var $set = function (value) {
						if (this === ObjectProto) $set.call(OPSymbols, value);
						if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
						setSymbolDesc(this, tag, createDesc(1, value));
					};
					if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
					return wrap(tag);
				};
				redefine($Symbol[PROTOTYPE], 'toString', function toString() {
					return this._k;
				});

				$GOPD.f = $getOwnPropertyDescriptor;
				$DP.f = $defineProperty;
				__webpack_require__(48).f = gOPNExt.f = $getOwnPropertyNames;
				__webpack_require__(42).f = $propertyIsEnumerable;
				__webpack_require__(41).f = $getOwnPropertySymbols;

				if (DESCRIPTORS && !__webpack_require__(26)) {
					redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
				}

				wksExt.f = function (name) {
					return wrap(wks(name));
				};
			}

			$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

			for (var symbols =
			// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
			'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), i = 0; symbols.length > i;) wks(symbols[i++]);

			for (var symbols = $keys(wks.store), i = 0; symbols.length > i;) wksDefine(symbols[i++]);

			$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
				// 19.4.2.1 Symbol.for(key)
				'for': function (key) {
					return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
				},
				// 19.4.2.5 Symbol.keyFor(sym)
				keyFor: function keyFor(key) {
					if (isSymbol(key)) return keyOf(SymbolRegistry, key);
					throw TypeError(key + ' is not a symbol!');
				},
				useSetter: function () {
					setter = true;
				},
				useSimple: function () {
					setter = false;
				}
			});

			$export($export.S + $export.F * !USE_NATIVE, 'Object', {
				// 19.1.2.2 Object.create(O [, Properties])
				create: $create,
				// 19.1.2.4 Object.defineProperty(O, P, Attributes)
				defineProperty: $defineProperty,
				// 19.1.2.3 Object.defineProperties(O, Properties)
				defineProperties: $defineProperties,
				// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
				getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
				// 19.1.2.7 Object.getOwnPropertyNames(O)
				getOwnPropertyNames: $getOwnPropertyNames,
				// 19.1.2.8 Object.getOwnPropertySymbols(O)
				getOwnPropertySymbols: $getOwnPropertySymbols
			});

			// 24.3.2 JSON.stringify(value [, replacer [, space]])
			$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
				var S = $Symbol();
				// MS Edge converts symbol values to JSON as {}
				// WebKit converts symbol values to JSON as null
				// V8 throws on boxed symbols
				return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
			})), 'JSON', {
				stringify: function stringify(it) {
					if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
					var args = [it],
					    i = 1,
					    replacer,
					    $replacer;
					while (arguments.length > i) args.push(arguments[i++]);
					replacer = args[1];
					if (typeof replacer == 'function') $replacer = replacer;
					if ($replacer || !isArray(replacer)) replacer = function (key, value) {
						if ($replacer) value = $replacer.call(this, key, value);
						if (!isSymbol(value)) return value;
					};
					args[1] = replacer;
					return _stringify.apply($JSON, args);
				}
			});

			// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
			$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(8)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
			// 19.4.3.5 Symbol.prototype[@@toStringTag]
			setToStringTag($Symbol, 'Symbol');
			// 20.2.1.9 Math[@@toStringTag]
			setToStringTag(Math, 'Math', true);
			// 24.3.3 JSON[@@toStringTag]
			setToStringTag(global.JSON, 'JSON', true);

			/***/
		},
		/* 2 */
		/***/function (module, exports) {

			// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
			var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
			if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

			/***/
		},
		/* 3 */
		/***/function (module, exports) {

			var hasOwnProperty = {}.hasOwnProperty;
			module.exports = function (it, key) {
				return hasOwnProperty.call(it, key);
			};

			/***/
		},
		/* 4 */
		/***/function (module, exports, __webpack_require__) {

			// Thank's IE8 for his funny defineProperty
			module.exports = !__webpack_require__(5)(function () {
				return Object.defineProperty({}, 'a', { get: function () {
						return 7;
					} }).a != 7;
			});

			/***/
		},
		/* 5 */
		/***/function (module, exports) {

			module.exports = function (exec) {
				try {
					return !!exec();
				} catch (e) {
					return true;
				}
			};

			/***/
		},
		/* 6 */
		/***/function (module, exports, __webpack_require__) {

			var global = __webpack_require__(2),
			    core = __webpack_require__(7),
			    hide = __webpack_require__(8),
			    redefine = __webpack_require__(16),
			    ctx = __webpack_require__(18),
			    PROTOTYPE = 'prototype';

			var $export = function (type, name, source) {
				var IS_FORCED = type & $export.F,
				    IS_GLOBAL = type & $export.G,
				    IS_STATIC = type & $export.S,
				    IS_PROTO = type & $export.P,
				    IS_BIND = type & $export.B,
				    target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
				    exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
				    expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
				    key,
				    own,
				    out,
				    exp;
				if (IS_GLOBAL) source = name;
				for (key in source) {
					// contains in native
					own = !IS_FORCED && target && target[key] !== undefined;
					// export native or passed
					out = (own ? target : source)[key];
					// bind timers to global for call from export context
					exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
					// extend global
					if (target) redefine(target, key, out, type & $export.U);
					// export
					if (exports[key] != out) hide(exports, key, exp);
					if (IS_PROTO && expProto[key] != out) expProto[key] = out;
				}
			};
			global.core = core;
			// type bitmap
			$export.F = 1; // forced
			$export.G = 2; // global
			$export.S = 4; // static
			$export.P = 8; // proto
			$export.B = 16; // bind
			$export.W = 32; // wrap
			$export.U = 64; // safe
			$export.R = 128; // real proto method for `library` 
			module.exports = $export;

			/***/
		},
		/* 7 */
		/***/function (module, exports) {

			var core = module.exports = { version: '2.4.0' };
			if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

			/***/
		},
		/* 8 */
		/***/function (module, exports, __webpack_require__) {

			var dP = __webpack_require__(9),
			    createDesc = __webpack_require__(15);
			module.exports = __webpack_require__(4) ? function (object, key, value) {
				return dP.f(object, key, createDesc(1, value));
			} : function (object, key, value) {
				object[key] = value;
				return object;
			};

			/***/
		},
		/* 9 */
		/***/function (module, exports, __webpack_require__) {

			var anObject = __webpack_require__(10),
			    IE8_DOM_DEFINE = __webpack_require__(12),
			    toPrimitive = __webpack_require__(14),
			    dP = Object.defineProperty;

			exports.f = __webpack_require__(4) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
				anObject(O);
				P = toPrimitive(P, true);
				anObject(Attributes);
				if (IE8_DOM_DEFINE) try {
					return dP(O, P, Attributes);
				} catch (e) {/* empty */}
				if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
				if ('value' in Attributes) O[P] = Attributes.value;
				return O;
			};

			/***/
		},
		/* 10 */
		/***/function (module, exports, __webpack_require__) {

			var isObject = __webpack_require__(11);
			module.exports = function (it) {
				if (!isObject(it)) throw TypeError(it + ' is not an object!');
				return it;
			};

			/***/
		},
		/* 11 */
		/***/function (module, exports) {

			module.exports = function (it) {
				return typeof it === 'object' ? it !== null : typeof it === 'function';
			};

			/***/
		},
		/* 12 */
		/***/function (module, exports, __webpack_require__) {

			module.exports = !__webpack_require__(4) && !__webpack_require__(5)(function () {
				return Object.defineProperty(__webpack_require__(13)('div'), 'a', { get: function () {
						return 7;
					} }).a != 7;
			});

			/***/
		},
		/* 13 */
		/***/function (module, exports, __webpack_require__) {

			var isObject = __webpack_require__(11),
			    document = __webpack_require__(2).document
			// in old IE typeof document.createElement is 'object'
			,
			    is = isObject(document) && isObject(document.createElement);
			module.exports = function (it) {
				return is ? document.createElement(it) : {};
			};

			/***/
		},
		/* 14 */
		/***/function (module, exports, __webpack_require__) {

			// 7.1.1 ToPrimitive(input [, PreferredType])
			var isObject = __webpack_require__(11);
			// instead of the ES6 spec version, we didn't implement @@toPrimitive case
			// and the second argument - flag - preferred type is a string
			module.exports = function (it, S) {
				if (!isObject(it)) return it;
				var fn, val;
				if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
				if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
				if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
				throw TypeError("Can't convert object to primitive value");
			};

			/***/
		},
		/* 15 */
		/***/function (module, exports) {

			module.exports = function (bitmap, value) {
				return {
					enumerable: !(bitmap & 1),
					configurable: !(bitmap & 2),
					writable: !(bitmap & 4),
					value: value
				};
			};

			/***/
		},
		/* 16 */
		/***/function (module, exports, __webpack_require__) {

			var global = __webpack_require__(2),
			    hide = __webpack_require__(8),
			    has = __webpack_require__(3),
			    SRC = __webpack_require__(17)('src'),
			    TO_STRING = 'toString',
			    $toString = Function[TO_STRING],
			    TPL = ('' + $toString).split(TO_STRING);

			__webpack_require__(7).inspectSource = function (it) {
				return $toString.call(it);
			};

			(module.exports = function (O, key, val, safe) {
				var isFunction = typeof val == 'function';
				if (isFunction) has(val, 'name') || hide(val, 'name', key);
				if (O[key] === val) return;
				if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
				if (O === global) {
					O[key] = val;
				} else {
					if (!safe) {
						delete O[key];
						hide(O, key, val);
					} else {
						if (O[key]) O[key] = val;else hide(O, key, val);
					}
				}
				// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
			})(Function.prototype, TO_STRING, function toString() {
				return typeof this == 'function' && this[SRC] || $toString.call(this);
			});

			/***/
		},
		/* 17 */
		/***/function (module, exports) {

			var id = 0,
			    px = Math.random();
			module.exports = function (key) {
				return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
			};

			/***/
		},
		/* 18 */
		/***/function (module, exports, __webpack_require__) {

			// optional / simple context binding
			var aFunction = __webpack_require__(19);
			module.exports = function (fn, that, length) {
				aFunction(fn);
				if (that === undefined) return fn;
				switch (length) {
					case 1:
						return function (a) {
							return fn.call(that, a);
						};
					case 2:
						return function (a, b) {
							return fn.call(that, a, b);
						};
					case 3:
						return function (a, b, c) {
							return fn.call(that, a, b, c);
						};
				}
				return function () /* ...args */{
					return fn.apply(that, arguments);
				};
			};

			/***/
		},
		/* 19 */
		/***/function (module, exports) {

			module.exports = function (it) {
				if (typeof it != 'function') throw TypeError(it + ' is not a function!');
				return it;
			};

			/***/
		},
		/* 20 */
		/***/function (module, exports, __webpack_require__) {

			var META = __webpack_require__(17)('meta'),
			    isObject = __webpack_require__(11),
			    has = __webpack_require__(3),
			    setDesc = __webpack_require__(9).f,
			    id = 0;
			var isExtensible = Object.isExtensible || function () {
				return true;
			};
			var FREEZE = !__webpack_require__(5)(function () {
				return isExtensible(Object.preventExtensions({}));
			});
			var setMeta = function (it) {
				setDesc(it, META, { value: {
						i: 'O' + ++id, // object ID
						w: {} // weak collections IDs
					} });
			};
			var fastKey = function (it, create) {
				// return primitive with prefix
				if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
				if (!has(it, META)) {
					// can't set metadata to uncaught frozen object
					if (!isExtensible(it)) return 'F';
					// not necessary to add metadata
					if (!create) return 'E';
					// add missing metadata
					setMeta(it);
					// return object ID
				}return it[META].i;
			};
			var getWeak = function (it, create) {
				if (!has(it, META)) {
					// can't set metadata to uncaught frozen object
					if (!isExtensible(it)) return true;
					// not necessary to add metadata
					if (!create) return false;
					// add missing metadata
					setMeta(it);
					// return hash weak collections IDs
				}return it[META].w;
			};
			// add metadata on freeze-family methods calling
			var onFreeze = function (it) {
				if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
				return it;
			};
			var meta = module.exports = {
				KEY: META,
				NEED: false,
				fastKey: fastKey,
				getWeak: getWeak,
				onFreeze: onFreeze
			};

			/***/
		},
		/* 21 */
		/***/function (module, exports, __webpack_require__) {

			var global = __webpack_require__(2),
			    SHARED = '__core-js_shared__',
			    store = global[SHARED] || (global[SHARED] = {});
			module.exports = function (key) {
				return store[key] || (store[key] = {});
			};

			/***/
		},
		/* 22 */
		/***/function (module, exports, __webpack_require__) {

			var def = __webpack_require__(9).f,
			    has = __webpack_require__(3),
			    TAG = __webpack_require__(23)('toStringTag');

			module.exports = function (it, tag, stat) {
				if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
			};

			/***/
		},
		/* 23 */
		/***/function (module, exports, __webpack_require__) {

			var store = __webpack_require__(21)('wks'),
			    uid = __webpack_require__(17),
			    Symbol = __webpack_require__(2).Symbol,
			    USE_SYMBOL = typeof Symbol == 'function';

			var $exports = module.exports = function (name) {
				return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
			};

			$exports.store = store;

			/***/
		},
		/* 24 */
		/***/function (module, exports, __webpack_require__) {

			exports.f = __webpack_require__(23);

			/***/
		},
		/* 25 */
		/***/function (module, exports, __webpack_require__) {

			var global = __webpack_require__(2),
			    core = __webpack_require__(7),
			    LIBRARY = __webpack_require__(26),
			    wksExt = __webpack_require__(24),
			    defineProperty = __webpack_require__(9).f;
			module.exports = function (name) {
				var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
				if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
			};

			/***/
		},
		/* 26 */
		/***/function (module, exports) {

			module.exports = false;

			/***/
		},
		/* 27 */
		/***/function (module, exports, __webpack_require__) {

			var getKeys = __webpack_require__(28),
			    toIObject = __webpack_require__(30);
			module.exports = function (object, el) {
				var O = toIObject(object),
				    keys = getKeys(O),
				    length = keys.length,
				    index = 0,
				    key;
				while (length > index) if (O[key = keys[index++]] === el) return key;
			};

			/***/
		},
		/* 28 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.14 / 15.2.3.14 Object.keys(O)
			var $keys = __webpack_require__(29),
			    enumBugKeys = __webpack_require__(39);

			module.exports = Object.keys || function keys(O) {
				return $keys(O, enumBugKeys);
			};

			/***/
		},
		/* 29 */
		/***/function (module, exports, __webpack_require__) {

			var has = __webpack_require__(3),
			    toIObject = __webpack_require__(30),
			    arrayIndexOf = __webpack_require__(34)(false),
			    IE_PROTO = __webpack_require__(38)('IE_PROTO');

			module.exports = function (object, names) {
				var O = toIObject(object),
				    i = 0,
				    result = [],
				    key;
				for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
				// Don't enum bug & hidden keys
				while (names.length > i) if (has(O, key = names[i++])) {
					~arrayIndexOf(result, key) || result.push(key);
				}
				return result;
			};

			/***/
		},
		/* 30 */
		/***/function (module, exports, __webpack_require__) {

			// to indexed object, toObject with fallback for non-array-like ES3 strings
			var IObject = __webpack_require__(31),
			    defined = __webpack_require__(33);
			module.exports = function (it) {
				return IObject(defined(it));
			};

			/***/
		},
		/* 31 */
		/***/function (module, exports, __webpack_require__) {

			// fallback for non-array-like ES3 and non-enumerable old V8 strings
			var cof = __webpack_require__(32);
			module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
				return cof(it) == 'String' ? it.split('') : Object(it);
			};

			/***/
		},
		/* 32 */
		/***/function (module, exports) {

			var toString = {}.toString;

			module.exports = function (it) {
				return toString.call(it).slice(8, -1);
			};

			/***/
		},
		/* 33 */
		/***/function (module, exports) {

			// 7.2.1 RequireObjectCoercible(argument)
			module.exports = function (it) {
				if (it == undefined) throw TypeError("Can't call method on  " + it);
				return it;
			};

			/***/
		},
		/* 34 */
		/***/function (module, exports, __webpack_require__) {

			// false -> Array#indexOf
			// true  -> Array#includes
			var toIObject = __webpack_require__(30),
			    toLength = __webpack_require__(35),
			    toIndex = __webpack_require__(37);
			module.exports = function (IS_INCLUDES) {
				return function ($this, el, fromIndex) {
					var O = toIObject($this),
					    length = toLength(O.length),
					    index = toIndex(fromIndex, length),
					    value;
					// Array#includes uses SameValueZero equality algorithm
					if (IS_INCLUDES && el != el) while (length > index) {
						value = O[index++];
						if (value != value) return true;
						// Array#toIndex ignores holes, Array#includes - not
					} else for (; length > index; index++) if (IS_INCLUDES || index in O) {
						if (O[index] === el) return IS_INCLUDES || index || 0;
					}return !IS_INCLUDES && -1;
				};
			};

			/***/
		},
		/* 35 */
		/***/function (module, exports, __webpack_require__) {

			// 7.1.15 ToLength
			var toInteger = __webpack_require__(36),
			    min = Math.min;
			module.exports = function (it) {
				return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
			};

			/***/
		},
		/* 36 */
		/***/function (module, exports) {

			// 7.1.4 ToInteger
			var ceil = Math.ceil,
			    floor = Math.floor;
			module.exports = function (it) {
				return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
			};

			/***/
		},
		/* 37 */
		/***/function (module, exports, __webpack_require__) {

			var toInteger = __webpack_require__(36),
			    max = Math.max,
			    min = Math.min;
			module.exports = function (index, length) {
				index = toInteger(index);
				return index < 0 ? max(index + length, 0) : min(index, length);
			};

			/***/
		},
		/* 38 */
		/***/function (module, exports, __webpack_require__) {

			var shared = __webpack_require__(21)('keys'),
			    uid = __webpack_require__(17);
			module.exports = function (key) {
				return shared[key] || (shared[key] = uid(key));
			};

			/***/
		},
		/* 39 */
		/***/function (module, exports) {

			// IE 8- don't enum bug keys
			module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

			/***/
		},
		/* 40 */
		/***/function (module, exports, __webpack_require__) {

			// all enumerable object keys, includes symbols
			var getKeys = __webpack_require__(28),
			    gOPS = __webpack_require__(41),
			    pIE = __webpack_require__(42);
			module.exports = function (it) {
				var result = getKeys(it),
				    getSymbols = gOPS.f;
				if (getSymbols) {
					var symbols = getSymbols(it),
					    isEnum = pIE.f,
					    i = 0,
					    key;
					while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
				}return result;
			};

			/***/
		},
		/* 41 */
		/***/function (module, exports) {

			exports.f = Object.getOwnPropertySymbols;

			/***/
		},
		/* 42 */
		/***/function (module, exports) {

			exports.f = {}.propertyIsEnumerable;

			/***/
		},
		/* 43 */
		/***/function (module, exports, __webpack_require__) {

			// 7.2.2 IsArray(argument)
			var cof = __webpack_require__(32);
			module.exports = Array.isArray || function isArray(arg) {
				return cof(arg) == 'Array';
			};

			/***/
		},
		/* 44 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
			var anObject = __webpack_require__(10),
			    dPs = __webpack_require__(45),
			    enumBugKeys = __webpack_require__(39),
			    IE_PROTO = __webpack_require__(38)('IE_PROTO'),
			    Empty = function () {/* empty */},
			    PROTOTYPE = 'prototype';

			// Create object with fake `null` prototype: use iframe Object with cleared prototype
			var createDict = function () {
				// Thrash, waste and sodomy: IE GC bug
				var iframe = __webpack_require__(13)('iframe'),
				    i = enumBugKeys.length,
				    lt = '<',
				    gt = '>',
				    iframeDocument;
				iframe.style.display = 'none';
				__webpack_require__(46).appendChild(iframe);
				iframe.src = 'javascript:'; // eslint-disable-line no-script-url
				// createDict = iframe.contentWindow.Object;
				// html.removeChild(iframe);
				iframeDocument = iframe.contentWindow.document;
				iframeDocument.open();
				iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
				iframeDocument.close();
				createDict = iframeDocument.F;
				while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
				return createDict();
			};

			module.exports = Object.create || function create(O, Properties) {
				var result;
				if (O !== null) {
					Empty[PROTOTYPE] = anObject(O);
					result = new Empty();
					Empty[PROTOTYPE] = null;
					// add "__proto__" for Object.getPrototypeOf polyfill
					result[IE_PROTO] = O;
				} else result = createDict();
				return Properties === undefined ? result : dPs(result, Properties);
			};

			/***/
		},
		/* 45 */
		/***/function (module, exports, __webpack_require__) {

			var dP = __webpack_require__(9),
			    anObject = __webpack_require__(10),
			    getKeys = __webpack_require__(28);

			module.exports = __webpack_require__(4) ? Object.defineProperties : function defineProperties(O, Properties) {
				anObject(O);
				var keys = getKeys(Properties),
				    length = keys.length,
				    i = 0,
				    P;
				while (length > i) dP.f(O, P = keys[i++], Properties[P]);
				return O;
			};

			/***/
		},
		/* 46 */
		/***/function (module, exports, __webpack_require__) {

			module.exports = __webpack_require__(2).document && document.documentElement;

			/***/
		},
		/* 47 */
		/***/function (module, exports, __webpack_require__) {

			// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
			var toIObject = __webpack_require__(30),
			    gOPN = __webpack_require__(48).f,
			    toString = {}.toString;

			var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

			var getWindowNames = function (it) {
				try {
					return gOPN(it);
				} catch (e) {
					return windowNames.slice();
				}
			};

			module.exports.f = function getOwnPropertyNames(it) {
				return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
			};

			/***/
		},
		/* 48 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
			var $keys = __webpack_require__(29),
			    hiddenKeys = __webpack_require__(39).concat('length', 'prototype');

			exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
				return $keys(O, hiddenKeys);
			};

			/***/
		},
		/* 49 */
		/***/function (module, exports, __webpack_require__) {

			var pIE = __webpack_require__(42),
			    createDesc = __webpack_require__(15),
			    toIObject = __webpack_require__(30),
			    toPrimitive = __webpack_require__(14),
			    has = __webpack_require__(3),
			    IE8_DOM_DEFINE = __webpack_require__(12),
			    gOPD = Object.getOwnPropertyDescriptor;

			exports.f = __webpack_require__(4) ? gOPD : function getOwnPropertyDescriptor(O, P) {
				O = toIObject(O);
				P = toPrimitive(P, true);
				if (IE8_DOM_DEFINE) try {
					return gOPD(O, P);
				} catch (e) {/* empty */}
				if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
			};

			/***/
		},
		/* 50 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6);
			// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
			$export($export.S + $export.F * !__webpack_require__(4), 'Object', { defineProperty: __webpack_require__(9).f });

			/***/
		},
		/* 51 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6);
			// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
			$export($export.S + $export.F * !__webpack_require__(4), 'Object', { defineProperties: __webpack_require__(45) });

			/***/
		},
		/* 52 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
			var toIObject = __webpack_require__(30),
			    $getOwnPropertyDescriptor = __webpack_require__(49).f;

			__webpack_require__(53)('getOwnPropertyDescriptor', function () {
				return function getOwnPropertyDescriptor(it, key) {
					return $getOwnPropertyDescriptor(toIObject(it), key);
				};
			});

			/***/
		},
		/* 53 */
		/***/function (module, exports, __webpack_require__) {

			// most Object methods by ES6 should accept primitives
			var $export = __webpack_require__(6),
			    core = __webpack_require__(7),
			    fails = __webpack_require__(5);
			module.exports = function (KEY, exec) {
				var fn = (core.Object || {})[KEY] || Object[KEY],
				    exp = {};
				exp[KEY] = exec(fn);
				$export($export.S + $export.F * fails(function () {
					fn(1);
				}), 'Object', exp);
			};

			/***/
		},
		/* 54 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6);
			// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
			$export($export.S, 'Object', { create: __webpack_require__(44) });

			/***/
		},
		/* 55 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.9 Object.getPrototypeOf(O)
			var toObject = __webpack_require__(56),
			    $getPrototypeOf = __webpack_require__(57);

			__webpack_require__(53)('getPrototypeOf', function () {
				return function getPrototypeOf(it) {
					return $getPrototypeOf(toObject(it));
				};
			});

			/***/
		},
		/* 56 */
		/***/function (module, exports, __webpack_require__) {

			// 7.1.13 ToObject(argument)
			var defined = __webpack_require__(33);
			module.exports = function (it) {
				return Object(defined(it));
			};

			/***/
		},
		/* 57 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
			var has = __webpack_require__(3),
			    toObject = __webpack_require__(56),
			    IE_PROTO = __webpack_require__(38)('IE_PROTO'),
			    ObjectProto = Object.prototype;

			module.exports = Object.getPrototypeOf || function (O) {
				O = toObject(O);
				if (has(O, IE_PROTO)) return O[IE_PROTO];
				if (typeof O.constructor == 'function' && O instanceof O.constructor) {
					return O.constructor.prototype;
				}return O instanceof Object ? ObjectProto : null;
			};

			/***/
		},
		/* 58 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.14 Object.keys(O)
			var toObject = __webpack_require__(56),
			    $keys = __webpack_require__(28);

			__webpack_require__(53)('keys', function () {
				return function keys(it) {
					return $keys(toObject(it));
				};
			});

			/***/
		},
		/* 59 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.7 Object.getOwnPropertyNames(O)
			__webpack_require__(53)('getOwnPropertyNames', function () {
				return __webpack_require__(47).f;
			});

			/***/
		},
		/* 60 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.5 Object.freeze(O)
			var isObject = __webpack_require__(11),
			    meta = __webpack_require__(20).onFreeze;

			__webpack_require__(53)('freeze', function ($freeze) {
				return function freeze(it) {
					return $freeze && isObject(it) ? $freeze(meta(it)) : it;
				};
			});

			/***/
		},
		/* 61 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.17 Object.seal(O)
			var isObject = __webpack_require__(11),
			    meta = __webpack_require__(20).onFreeze;

			__webpack_require__(53)('seal', function ($seal) {
				return function seal(it) {
					return $seal && isObject(it) ? $seal(meta(it)) : it;
				};
			});

			/***/
		},
		/* 62 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.15 Object.preventExtensions(O)
			var isObject = __webpack_require__(11),
			    meta = __webpack_require__(20).onFreeze;

			__webpack_require__(53)('preventExtensions', function ($preventExtensions) {
				return function preventExtensions(it) {
					return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
				};
			});

			/***/
		},
		/* 63 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.12 Object.isFrozen(O)
			var isObject = __webpack_require__(11);

			__webpack_require__(53)('isFrozen', function ($isFrozen) {
				return function isFrozen(it) {
					return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
				};
			});

			/***/
		},
		/* 64 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.13 Object.isSealed(O)
			var isObject = __webpack_require__(11);

			__webpack_require__(53)('isSealed', function ($isSealed) {
				return function isSealed(it) {
					return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
				};
			});

			/***/
		},
		/* 65 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.2.11 Object.isExtensible(O)
			var isObject = __webpack_require__(11);

			__webpack_require__(53)('isExtensible', function ($isExtensible) {
				return function isExtensible(it) {
					return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
				};
			});

			/***/
		},
		/* 66 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.3.1 Object.assign(target, source)
			var $export = __webpack_require__(6);

			$export($export.S + $export.F, 'Object', { assign: __webpack_require__(67) });

			/***/
		},
		/* 67 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// 19.1.2.1 Object.assign(target, source, ...)

			var getKeys = __webpack_require__(28),
			    gOPS = __webpack_require__(41),
			    pIE = __webpack_require__(42),
			    toObject = __webpack_require__(56),
			    IObject = __webpack_require__(31),
			    $assign = Object.assign;

			// should work with symbols and should have deterministic property order (V8 bug)
			module.exports = !$assign || __webpack_require__(5)(function () {
				var A = {},
				    B = {},
				    S = Symbol(),
				    K = 'abcdefghijklmnopqrst';
				A[S] = 7;
				K.split('').forEach(function (k) {
					B[k] = k;
				});
				return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
			}) ? function assign(target, source) {
				// eslint-disable-line no-unused-vars
				var T = toObject(target),
				    aLen = arguments.length,
				    index = 1,
				    getSymbols = gOPS.f,
				    isEnum = pIE.f;
				while (aLen > index) {
					var S = IObject(arguments[index++]),
					    keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
					    length = keys.length,
					    j = 0,
					    key;
					while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
				}return T;
			} : $assign;

			/***/
		},
		/* 68 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.3.10 Object.is(value1, value2)
			var $export = __webpack_require__(6);
			$export($export.S, 'Object', { is: __webpack_require__(69) });

			/***/
		},
		/* 69 */
		/***/function (module, exports) {

			// 7.2.9 SameValue(x, y)
			module.exports = Object.is || function is(x, y) {
				return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
			};

			/***/
		},
		/* 70 */
		/***/function (module, exports, __webpack_require__) {

			// 19.1.3.19 Object.setPrototypeOf(O, proto)
			var $export = __webpack_require__(6);
			$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(71).set });

			/***/
		},
		/* 71 */
		/***/function (module, exports, __webpack_require__) {

			// Works with __proto__ only. Old v8 can't work with null proto objects.
			/* eslint-disable no-proto */
			var isObject = __webpack_require__(11),
			    anObject = __webpack_require__(10);
			var check = function (O, proto) {
				anObject(O);
				if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
			};
			module.exports = {
				set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
				function (test, buggy, set) {
					try {
						set = __webpack_require__(18)(Function.call, __webpack_require__(49).f(Object.prototype, '__proto__').set, 2);
						set(test, []);
						buggy = !(test instanceof Array);
					} catch (e) {
						buggy = true;
					}
					return function setPrototypeOf(O, proto) {
						check(O, proto);
						if (buggy) O.__proto__ = proto;else set(O, proto);
						return O;
					};
				}({}, false) : undefined),
				check: check
			};

			/***/
		},
		/* 72 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// 19.1.3.6 Object.prototype.toString()

			var classof = __webpack_require__(73),
			    test = {};
			test[__webpack_require__(23)('toStringTag')] = 'z';
			if (test + '' != '[object z]') {
				__webpack_require__(16)(Object.prototype, 'toString', function toString() {
					return '[object ' + classof(this) + ']';
				}, true);
			}

			/***/
		},
		/* 73 */
		/***/function (module, exports, __webpack_require__) {

			// getting tag from 19.1.3.6 Object.prototype.toString()
			var cof = __webpack_require__(32),
			    TAG = __webpack_require__(23)('toStringTag')
			// ES3 wrong here
			,
			    ARG = cof(function () {
				return arguments;
			}()) == 'Arguments';

			// fallback for IE11 Script Access Denied error
			var tryGet = function (it, key) {
				try {
					return it[key];
				} catch (e) {/* empty */}
			};

			module.exports = function (it) {
				var O, T, B;
				return it === undefined ? 'Undefined' : it === null ? 'Null'
				// @@toStringTag case
				: typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
				// builtinTag case
				: ARG ? cof(O)
				// ES3 arguments fallback
				: (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
			};

			/***/
		},
		/* 74 */
		/***/function (module, exports, __webpack_require__) {

			// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
			var $export = __webpack_require__(6);

			$export($export.P, 'Function', { bind: __webpack_require__(75) });

			/***/
		},
		/* 75 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var aFunction = __webpack_require__(19),
			    isObject = __webpack_require__(11),
			    invoke = __webpack_require__(76),
			    arraySlice = [].slice,
			    factories = {};

			var construct = function (F, len, args) {
				if (!(len in factories)) {
					for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
					factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
				}return factories[len](F, args);
			};

			module.exports = Function.bind || function bind(that /*, args... */) {
				var fn = aFunction(this),
				    partArgs = arraySlice.call(arguments, 1);
				var bound = function () /* args... */{
					var args = partArgs.concat(arraySlice.call(arguments));
					return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
				};
				if (isObject(fn.prototype)) bound.prototype = fn.prototype;
				return bound;
			};

			/***/
		},
		/* 76 */
		/***/function (module, exports) {

			// fast apply, http://jsperf.lnkit.com/fast-apply/5
			module.exports = function (fn, args, that) {
				var un = that === undefined;
				switch (args.length) {
					case 0:
						return un ? fn() : fn.call(that);
					case 1:
						return un ? fn(args[0]) : fn.call(that, args[0]);
					case 2:
						return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
					case 3:
						return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
					case 4:
						return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
				}return fn.apply(that, args);
			};

			/***/
		},
		/* 77 */
		/***/function (module, exports, __webpack_require__) {

			var dP = __webpack_require__(9).f,
			    createDesc = __webpack_require__(15),
			    has = __webpack_require__(3),
			    FProto = Function.prototype,
			    nameRE = /^\s*function ([^ (]*)/,
			    NAME = 'name';

			var isExtensible = Object.isExtensible || function () {
				return true;
			};

			// 19.2.4.2 name
			NAME in FProto || __webpack_require__(4) && dP(FProto, NAME, {
				configurable: true,
				get: function () {
					try {
						var that = this,
						    name = ('' + that).match(nameRE)[1];
						has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
						return name;
					} catch (e) {
						return '';
					}
				}
			});

			/***/
		},
		/* 78 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var isObject = __webpack_require__(11),
			    getPrototypeOf = __webpack_require__(57),
			    HAS_INSTANCE = __webpack_require__(23)('hasInstance'),
			    FunctionProto = Function.prototype;
			// 19.2.3.6 Function.prototype[@@hasInstance](V)
			if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(9).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
					if (typeof this != 'function' || !isObject(O)) return false;
					if (!isObject(this.prototype)) return O instanceof this;
					// for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
					while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
					return false;
				} });

			/***/
		},
		/* 79 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var global = __webpack_require__(2),
			    has = __webpack_require__(3),
			    cof = __webpack_require__(32),
			    inheritIfRequired = __webpack_require__(80),
			    toPrimitive = __webpack_require__(14),
			    fails = __webpack_require__(5),
			    gOPN = __webpack_require__(48).f,
			    gOPD = __webpack_require__(49).f,
			    dP = __webpack_require__(9).f,
			    $trim = __webpack_require__(81).trim,
			    NUMBER = 'Number',
			    $Number = global[NUMBER],
			    Base = $Number,
			    proto = $Number.prototype
			// Opera ~12 has broken Object#toString
			,
			    BROKEN_COF = cof(__webpack_require__(44)(proto)) == NUMBER,
			    TRIM = 'trim' in String.prototype;

			// 7.1.3 ToNumber(argument)
			var toNumber = function (argument) {
				var it = toPrimitive(argument, false);
				if (typeof it == 'string' && it.length > 2) {
					it = TRIM ? it.trim() : $trim(it, 3);
					var first = it.charCodeAt(0),
					    third,
					    radix,
					    maxCode;
					if (first === 43 || first === 45) {
						third = it.charCodeAt(2);
						if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
					} else if (first === 48) {
						switch (it.charCodeAt(1)) {
							case 66:case 98:
								radix = 2;maxCode = 49;break; // fast equal /^0b[01]+$/i
							case 79:case 111:
								radix = 8;maxCode = 55;break; // fast equal /^0o[0-7]+$/i
							default:
								return +it;
						}
						for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
							code = digits.charCodeAt(i);
							// parseInt parses a string to a first unavailable symbol
							// but ToNumber should return NaN if a string contains unavailable symbols
							if (code < 48 || code > maxCode) return NaN;
						}return parseInt(digits, radix);
					}
				}return +it;
			};

			if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
				$Number = function Number(value) {
					var it = arguments.length < 1 ? 0 : value,
					    that = this;
					return that instanceof $Number
					// check on 1..constructor(foo) case
					&& (BROKEN_COF ? fails(function () {
						proto.valueOf.call(that);
					}) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
				};
				for (var keys = __webpack_require__(4) ? gOPN(Base) : (
				// ES3:
				'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
				// ES6 (in case, if modules with ES6 Number statics required before):
				'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
					if (has(Base, key = keys[j]) && !has($Number, key)) {
						dP($Number, key, gOPD(Base, key));
					}
				}
				$Number.prototype = proto;
				proto.constructor = $Number;
				__webpack_require__(16)(global, NUMBER, $Number);
			}

			/***/
		},
		/* 80 */
		/***/function (module, exports, __webpack_require__) {

			var isObject = __webpack_require__(11),
			    setPrototypeOf = __webpack_require__(71).set;
			module.exports = function (that, target, C) {
				var P,
				    S = target.constructor;
				if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
					setPrototypeOf(that, P);
				}return that;
			};

			/***/
		},
		/* 81 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    defined = __webpack_require__(33),
			    fails = __webpack_require__(5),
			    spaces = __webpack_require__(82),
			    space = '[' + spaces + ']',
			    non = '\u200b\u0085',
			    ltrim = RegExp('^' + space + space + '*'),
			    rtrim = RegExp(space + space + '*$');

			var exporter = function (KEY, exec, ALIAS) {
				var exp = {};
				var FORCE = fails(function () {
					return !!spaces[KEY]() || non[KEY]() != non;
				});
				var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
				if (ALIAS) exp[ALIAS] = fn;
				$export($export.P + $export.F * FORCE, 'String', exp);
			};

			// 1 -> String#trimLeft
			// 2 -> String#trimRight
			// 3 -> String#trim
			var trim = exporter.trim = function (string, TYPE) {
				string = String(defined(string));
				if (TYPE & 1) string = string.replace(ltrim, '');
				if (TYPE & 2) string = string.replace(rtrim, '');
				return string;
			};

			module.exports = exporter;

			/***/
		},
		/* 82 */
		/***/function (module, exports) {

			module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

			/***/
		},
		/* 83 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    toInteger = __webpack_require__(36),
			    aNumberValue = __webpack_require__(84),
			    repeat = __webpack_require__(85),
			    $toFixed = 1..toFixed,
			    floor = Math.floor,
			    data = [0, 0, 0, 0, 0, 0],
			    ERROR = 'Number.toFixed: incorrect invocation!',
			    ZERO = '0';

			var multiply = function (n, c) {
				var i = -1,
				    c2 = c;
				while (++i < 6) {
					c2 += n * data[i];
					data[i] = c2 % 1e7;
					c2 = floor(c2 / 1e7);
				}
			};
			var divide = function (n) {
				var i = 6,
				    c = 0;
				while (--i >= 0) {
					c += data[i];
					data[i] = floor(c / n);
					c = c % n * 1e7;
				}
			};
			var numToString = function () {
				var i = 6,
				    s = '';
				while (--i >= 0) {
					if (s !== '' || i === 0 || data[i] !== 0) {
						var t = String(data[i]);
						s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
					}
				}return s;
			};
			var pow = function (x, n, acc) {
				return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
			};
			var log = function (x) {
				var n = 0,
				    x2 = x;
				while (x2 >= 4096) {
					n += 12;
					x2 /= 4096;
				}
				while (x2 >= 2) {
					n += 1;
					x2 /= 2;
				}return n;
			};

			$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128..toFixed(0) !== '1000000000000000128') || !__webpack_require__(5)(function () {
				// V8 ~ Android 4.3-
				$toFixed.call({});
			})), 'Number', {
				toFixed: function toFixed(fractionDigits) {
					var x = aNumberValue(this, ERROR),
					    f = toInteger(fractionDigits),
					    s = '',
					    m = ZERO,
					    e,
					    z,
					    j,
					    k;
					if (f < 0 || f > 20) throw RangeError(ERROR);
					if (x != x) return 'NaN';
					if (x <= -1e21 || x >= 1e21) return String(x);
					if (x < 0) {
						s = '-';
						x = -x;
					}
					if (x > 1e-21) {
						e = log(x * pow(2, 69, 1)) - 69;
						z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
						z *= 0x10000000000000;
						e = 52 - e;
						if (e > 0) {
							multiply(0, z);
							j = f;
							while (j >= 7) {
								multiply(1e7, 0);
								j -= 7;
							}
							multiply(pow(10, j, 1), 0);
							j = e - 1;
							while (j >= 23) {
								divide(1 << 23);
								j -= 23;
							}
							divide(1 << j);
							multiply(1, 1);
							divide(2);
							m = numToString();
						} else {
							multiply(0, z);
							multiply(1 << -e, 0);
							m = numToString() + repeat.call(ZERO, f);
						}
					}
					if (f > 0) {
						k = m.length;
						m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
					} else {
						m = s + m;
					}return m;
				}
			});

			/***/
		},
		/* 84 */
		/***/function (module, exports, __webpack_require__) {

			var cof = __webpack_require__(32);
			module.exports = function (it, msg) {
				if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
				return +it;
			};

			/***/
		},
		/* 85 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var toInteger = __webpack_require__(36),
			    defined = __webpack_require__(33);

			module.exports = function repeat(count) {
				var str = String(defined(this)),
				    res = '',
				    n = toInteger(count);
				if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
				for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
				return res;
			};

			/***/
		},
		/* 86 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $fails = __webpack_require__(5),
			    aNumberValue = __webpack_require__(84),
			    $toPrecision = 1..toPrecision;

			$export($export.P + $export.F * ($fails(function () {
				// IE7-
				return $toPrecision.call(1, undefined) !== '1';
			}) || !$fails(function () {
				// V8 ~ Android 4.3-
				$toPrecision.call({});
			})), 'Number', {
				toPrecision: function toPrecision(precision) {
					var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
					return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
				}
			});

			/***/
		},
		/* 87 */
		/***/function (module, exports, __webpack_require__) {

			// 20.1.2.1 Number.EPSILON
			var $export = __webpack_require__(6);

			$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

			/***/
		},
		/* 88 */
		/***/function (module, exports, __webpack_require__) {

			// 20.1.2.2 Number.isFinite(number)
			var $export = __webpack_require__(6),
			    _isFinite = __webpack_require__(2).isFinite;

			$export($export.S, 'Number', {
				isFinite: function isFinite(it) {
					return typeof it == 'number' && _isFinite(it);
				}
			});

			/***/
		},
		/* 89 */
		/***/function (module, exports, __webpack_require__) {

			// 20.1.2.3 Number.isInteger(number)
			var $export = __webpack_require__(6);

			$export($export.S, 'Number', { isInteger: __webpack_require__(90) });

			/***/
		},
		/* 90 */
		/***/function (module, exports, __webpack_require__) {

			// 20.1.2.3 Number.isInteger(number)
			var isObject = __webpack_require__(11),
			    floor = Math.floor;
			module.exports = function isInteger(it) {
				return !isObject(it) && isFinite(it) && floor(it) === it;
			};

			/***/
		},
		/* 91 */
		/***/function (module, exports, __webpack_require__) {

			// 20.1.2.4 Number.isNaN(number)
			var $export = __webpack_require__(6);

			$export($export.S, 'Number', {
				isNaN: function isNaN(number) {
					return number != number;
				}
			});

			/***/
		},
		/* 92 */
		/***/function (module, exports, __webpack_require__) {

			// 20.1.2.5 Number.isSafeInteger(number)
			var $export = __webpack_require__(6),
			    isInteger = __webpack_require__(90),
			    abs = Math.abs;

			$export($export.S, 'Number', {
				isSafeInteger: function isSafeInteger(number) {
					return isInteger(number) && abs(number) <= 0x1fffffffffffff;
				}
			});

			/***/
		},
		/* 93 */
		/***/function (module, exports, __webpack_require__) {

			// 20.1.2.6 Number.MAX_SAFE_INTEGER
			var $export = __webpack_require__(6);

			$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

			/***/
		},
		/* 94 */
		/***/function (module, exports, __webpack_require__) {

			// 20.1.2.10 Number.MIN_SAFE_INTEGER
			var $export = __webpack_require__(6);

			$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

			/***/
		},
		/* 95 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    $parseFloat = __webpack_require__(96);
			// 20.1.2.12 Number.parseFloat(string)
			$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

			/***/
		},
		/* 96 */
		/***/function (module, exports, __webpack_require__) {

			var $parseFloat = __webpack_require__(2).parseFloat,
			    $trim = __webpack_require__(81).trim;

			module.exports = 1 / $parseFloat(__webpack_require__(82) + '-0') !== -Infinity ? function parseFloat(str) {
				var string = $trim(String(str), 3),
				    result = $parseFloat(string);
				return result === 0 && string.charAt(0) == '-' ? -0 : result;
			} : $parseFloat;

			/***/
		},
		/* 97 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    $parseInt = __webpack_require__(98);
			// 20.1.2.13 Number.parseInt(string, radix)
			$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

			/***/
		},
		/* 98 */
		/***/function (module, exports, __webpack_require__) {

			var $parseInt = __webpack_require__(2).parseInt,
			    $trim = __webpack_require__(81).trim,
			    ws = __webpack_require__(82),
			    hex = /^[\-+]?0[xX]/;

			module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
				var string = $trim(String(str), 3);
				return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
			} : $parseInt;

			/***/
		},
		/* 99 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    $parseInt = __webpack_require__(98);
			// 18.2.5 parseInt(string, radix)
			$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

			/***/
		},
		/* 100 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    $parseFloat = __webpack_require__(96);
			// 18.2.4 parseFloat(string)
			$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

			/***/
		},
		/* 101 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.3 Math.acosh(x)
			var $export = __webpack_require__(6),
			    log1p = __webpack_require__(102),
			    sqrt = Math.sqrt,
			    $acosh = Math.acosh;

			$export($export.S + $export.F * !($acosh
			// V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
			&& Math.floor($acosh(Number.MAX_VALUE)) == 710
			// Tor Browser bug: Math.acosh(Infinity) -> NaN 
			&& $acosh(Infinity) == Infinity), 'Math', {
				acosh: function acosh(x) {
					return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
				}
			});

			/***/
		},
		/* 102 */
		/***/function (module, exports) {

			// 20.2.2.20 Math.log1p(x)
			module.exports = Math.log1p || function log1p(x) {
				return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
			};

			/***/
		},
		/* 103 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.5 Math.asinh(x)
			var $export = __webpack_require__(6),
			    $asinh = Math.asinh;

			function asinh(x) {
				return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
			}

			// Tor Browser bug: Math.asinh(0) -> -0 
			$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

			/***/
		},
		/* 104 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.7 Math.atanh(x)
			var $export = __webpack_require__(6),
			    $atanh = Math.atanh;

			// Tor Browser bug: Math.atanh(-0) -> 0 
			$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
				atanh: function atanh(x) {
					return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
				}
			});

			/***/
		},
		/* 105 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.9 Math.cbrt(x)
			var $export = __webpack_require__(6),
			    sign = __webpack_require__(106);

			$export($export.S, 'Math', {
				cbrt: function cbrt(x) {
					return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
				}
			});

			/***/
		},
		/* 106 */
		/***/function (module, exports) {

			// 20.2.2.28 Math.sign(x)
			module.exports = Math.sign || function sign(x) {
				return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
			};

			/***/
		},
		/* 107 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.11 Math.clz32(x)
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', {
				clz32: function clz32(x) {
					return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
				}
			});

			/***/
		},
		/* 108 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.12 Math.cosh(x)
			var $export = __webpack_require__(6),
			    exp = Math.exp;

			$export($export.S, 'Math', {
				cosh: function cosh(x) {
					return (exp(x = +x) + exp(-x)) / 2;
				}
			});

			/***/
		},
		/* 109 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.14 Math.expm1(x)
			var $export = __webpack_require__(6),
			    $expm1 = __webpack_require__(110);

			$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

			/***/
		},
		/* 110 */
		/***/function (module, exports) {

			// 20.2.2.14 Math.expm1(x)
			var $expm1 = Math.expm1;
			module.exports = !$expm1
			// Old FF bug
			|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
			// Tor Browser bug
			|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
				return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
			} : $expm1;

			/***/
		},
		/* 111 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.16 Math.fround(x)
			var $export = __webpack_require__(6),
			    sign = __webpack_require__(106),
			    pow = Math.pow,
			    EPSILON = pow(2, -52),
			    EPSILON32 = pow(2, -23),
			    MAX32 = pow(2, 127) * (2 - EPSILON32),
			    MIN32 = pow(2, -126);

			var roundTiesToEven = function (n) {
				return n + 1 / EPSILON - 1 / EPSILON;
			};

			$export($export.S, 'Math', {
				fround: function fround(x) {
					var $abs = Math.abs(x),
					    $sign = sign(x),
					    a,
					    result;
					if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
					a = (1 + EPSILON32 / EPSILON) * $abs;
					result = a - (a - $abs);
					if (result > MAX32 || result != result) return $sign * Infinity;
					return $sign * result;
				}
			});

			/***/
		},
		/* 112 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
			var $export = __webpack_require__(6),
			    abs = Math.abs;

			$export($export.S, 'Math', {
				hypot: function hypot(value1, value2) {
					// eslint-disable-line no-unused-vars
					var sum = 0,
					    i = 0,
					    aLen = arguments.length,
					    larg = 0,
					    arg,
					    div;
					while (i < aLen) {
						arg = abs(arguments[i++]);
						if (larg < arg) {
							div = larg / arg;
							sum = sum * div * div + 1;
							larg = arg;
						} else if (arg > 0) {
							div = arg / larg;
							sum += div * div;
						} else sum += arg;
					}
					return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
				}
			});

			/***/
		},
		/* 113 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.18 Math.imul(x, y)
			var $export = __webpack_require__(6),
			    $imul = Math.imul;

			// some WebKit versions fails with big numbers, some has wrong arity
			$export($export.S + $export.F * __webpack_require__(5)(function () {
				return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
			}), 'Math', {
				imul: function imul(x, y) {
					var UINT16 = 0xffff,
					    xn = +x,
					    yn = +y,
					    xl = UINT16 & xn,
					    yl = UINT16 & yn;
					return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
				}
			});

			/***/
		},
		/* 114 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.21 Math.log10(x)
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', {
				log10: function log10(x) {
					return Math.log(x) / Math.LN10;
				}
			});

			/***/
		},
		/* 115 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.20 Math.log1p(x)
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', { log1p: __webpack_require__(102) });

			/***/
		},
		/* 116 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.22 Math.log2(x)
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', {
				log2: function log2(x) {
					return Math.log(x) / Math.LN2;
				}
			});

			/***/
		},
		/* 117 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.28 Math.sign(x)
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', { sign: __webpack_require__(106) });

			/***/
		},
		/* 118 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.30 Math.sinh(x)
			var $export = __webpack_require__(6),
			    expm1 = __webpack_require__(110),
			    exp = Math.exp;

			// V8 near Chromium 38 has a problem with very small numbers
			$export($export.S + $export.F * __webpack_require__(5)(function () {
				return !Math.sinh(-2e-17) != -2e-17;
			}), 'Math', {
				sinh: function sinh(x) {
					return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
				}
			});

			/***/
		},
		/* 119 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.33 Math.tanh(x)
			var $export = __webpack_require__(6),
			    expm1 = __webpack_require__(110),
			    exp = Math.exp;

			$export($export.S, 'Math', {
				tanh: function tanh(x) {
					var a = expm1(x = +x),
					    b = expm1(-x);
					return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
				}
			});

			/***/
		},
		/* 120 */
		/***/function (module, exports, __webpack_require__) {

			// 20.2.2.34 Math.trunc(x)
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', {
				trunc: function trunc(it) {
					return (it > 0 ? Math.floor : Math.ceil)(it);
				}
			});

			/***/
		},
		/* 121 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    toIndex = __webpack_require__(37),
			    fromCharCode = String.fromCharCode,
			    $fromCodePoint = String.fromCodePoint;

			// length should be 1, old FF problem
			$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
				// 21.1.2.2 String.fromCodePoint(...codePoints)
				fromCodePoint: function fromCodePoint(x) {
					// eslint-disable-line no-unused-vars
					var res = [],
					    aLen = arguments.length,
					    i = 0,
					    code;
					while (aLen > i) {
						code = +arguments[i++];
						if (toIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
						res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
					}return res.join('');
				}
			});

			/***/
		},
		/* 122 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    toIObject = __webpack_require__(30),
			    toLength = __webpack_require__(35);

			$export($export.S, 'String', {
				// 21.1.2.4 String.raw(callSite, ...substitutions)
				raw: function raw(callSite) {
					var tpl = toIObject(callSite.raw),
					    len = toLength(tpl.length),
					    aLen = arguments.length,
					    res = [],
					    i = 0;
					while (len > i) {
						res.push(String(tpl[i++]));
						if (i < aLen) res.push(String(arguments[i]));
					}return res.join('');
				}
			});

			/***/
		},
		/* 123 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// 21.1.3.25 String.prototype.trim()

			__webpack_require__(81)('trim', function ($trim) {
				return function trim() {
					return $trim(this, 3);
				};
			});

			/***/
		},
		/* 124 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $at = __webpack_require__(125)(false);
			$export($export.P, 'String', {
				// 21.1.3.3 String.prototype.codePointAt(pos)
				codePointAt: function codePointAt(pos) {
					return $at(this, pos);
				}
			});

			/***/
		},
		/* 125 */
		/***/function (module, exports, __webpack_require__) {

			var toInteger = __webpack_require__(36),
			    defined = __webpack_require__(33);
			// true  -> String#at
			// false -> String#codePointAt
			module.exports = function (TO_STRING) {
				return function (that, pos) {
					var s = String(defined(that)),
					    i = toInteger(pos),
					    l = s.length,
					    a,
					    b;
					if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
					a = s.charCodeAt(i);
					return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
				};
			};

			/***/
		},
		/* 126 */
		/***/function (module, exports, __webpack_require__) {

			// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
			'use strict';

			var $export = __webpack_require__(6),
			    toLength = __webpack_require__(35),
			    context = __webpack_require__(127),
			    ENDS_WITH = 'endsWith',
			    $endsWith = ''[ENDS_WITH];

			$export($export.P + $export.F * __webpack_require__(129)(ENDS_WITH), 'String', {
				endsWith: function endsWith(searchString /*, endPosition = @length */) {
					var that = context(this, searchString, ENDS_WITH),
					    endPosition = arguments.length > 1 ? arguments[1] : undefined,
					    len = toLength(that.length),
					    end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
					    search = String(searchString);
					return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
				}
			});

			/***/
		},
		/* 127 */
		/***/function (module, exports, __webpack_require__) {

			// helper for String#{startsWith, endsWith, includes}
			var isRegExp = __webpack_require__(128),
			    defined = __webpack_require__(33);

			module.exports = function (that, searchString, NAME) {
				if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
				return String(defined(that));
			};

			/***/
		},
		/* 128 */
		/***/function (module, exports, __webpack_require__) {

			// 7.2.8 IsRegExp(argument)
			var isObject = __webpack_require__(11),
			    cof = __webpack_require__(32),
			    MATCH = __webpack_require__(23)('match');
			module.exports = function (it) {
				var isRegExp;
				return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
			};

			/***/
		},
		/* 129 */
		/***/function (module, exports, __webpack_require__) {

			var MATCH = __webpack_require__(23)('match');
			module.exports = function (KEY) {
				var re = /./;
				try {
					'/./'[KEY](re);
				} catch (e) {
					try {
						re[MATCH] = false;
						return !'/./'[KEY](re);
					} catch (f) {/* empty */}
				}return true;
			};

			/***/
		},
		/* 130 */
		/***/function (module, exports, __webpack_require__) {

			// 21.1.3.7 String.prototype.includes(searchString, position = 0)
			'use strict';

			var $export = __webpack_require__(6),
			    context = __webpack_require__(127),
			    INCLUDES = 'includes';

			$export($export.P + $export.F * __webpack_require__(129)(INCLUDES), 'String', {
				includes: function includes(searchString /*, position = 0 */) {
					return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
				}
			});

			/***/
		},
		/* 131 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6);

			$export($export.P, 'String', {
				// 21.1.3.13 String.prototype.repeat(count)
				repeat: __webpack_require__(85)
			});

			/***/
		},
		/* 132 */
		/***/function (module, exports, __webpack_require__) {

			// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
			'use strict';

			var $export = __webpack_require__(6),
			    toLength = __webpack_require__(35),
			    context = __webpack_require__(127),
			    STARTS_WITH = 'startsWith',
			    $startsWith = ''[STARTS_WITH];

			$export($export.P + $export.F * __webpack_require__(129)(STARTS_WITH), 'String', {
				startsWith: function startsWith(searchString /*, position = 0 */) {
					var that = context(this, searchString, STARTS_WITH),
					    index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length)),
					    search = String(searchString);
					return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
				}
			});

			/***/
		},
		/* 133 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $at = __webpack_require__(125)(true);

			// 21.1.3.27 String.prototype[@@iterator]()
			__webpack_require__(134)(String, 'String', function (iterated) {
				this._t = String(iterated); // target
				this._i = 0; // next index
				// 21.1.5.2.1 %StringIteratorPrototype%.next()
			}, function () {
				var O = this._t,
				    index = this._i,
				    point;
				if (index >= O.length) return { value: undefined, done: true };
				point = $at(O, index);
				this._i += point.length;
				return { value: point, done: false };
			});

			/***/
		},
		/* 134 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var LIBRARY = __webpack_require__(26),
			    $export = __webpack_require__(6),
			    redefine = __webpack_require__(16),
			    hide = __webpack_require__(8),
			    has = __webpack_require__(3),
			    Iterators = __webpack_require__(135),
			    $iterCreate = __webpack_require__(136),
			    setToStringTag = __webpack_require__(22),
			    getPrototypeOf = __webpack_require__(57),
			    ITERATOR = __webpack_require__(23)('iterator'),
			    BUGGY = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
			,
			    FF_ITERATOR = '@@iterator',
			    KEYS = 'keys',
			    VALUES = 'values';

			var returnThis = function () {
				return this;
			};

			module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
				$iterCreate(Constructor, NAME, next);
				var getMethod = function (kind) {
					if (!BUGGY && kind in proto) return proto[kind];
					switch (kind) {
						case KEYS:
							return function keys() {
								return new Constructor(this, kind);
							};
						case VALUES:
							return function values() {
								return new Constructor(this, kind);
							};
					}return function entries() {
						return new Constructor(this, kind);
					};
				};
				var TAG = NAME + ' Iterator',
				    DEF_VALUES = DEFAULT == VALUES,
				    VALUES_BUG = false,
				    proto = Base.prototype,
				    $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
				    $default = $native || getMethod(DEFAULT),
				    $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined,
				    $anyNative = NAME == 'Array' ? proto.entries || $native : $native,
				    methods,
				    key,
				    IteratorPrototype;
				// Fix native
				if ($anyNative) {
					IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
					if (IteratorPrototype !== Object.prototype) {
						// Set @@toStringTag to native iterators
						setToStringTag(IteratorPrototype, TAG, true);
						// fix for some old engines
						if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
					}
				}
				// fix Array#{values, @@iterator}.name in V8 / FF
				if (DEF_VALUES && $native && $native.name !== VALUES) {
					VALUES_BUG = true;
					$default = function values() {
						return $native.call(this);
					};
				}
				// Define iterator
				if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
					hide(proto, ITERATOR, $default);
				}
				// Plug for library
				Iterators[NAME] = $default;
				Iterators[TAG] = returnThis;
				if (DEFAULT) {
					methods = {
						values: DEF_VALUES ? $default : getMethod(VALUES),
						keys: IS_SET ? $default : getMethod(KEYS),
						entries: $entries
					};
					if (FORCED) for (key in methods) {
						if (!(key in proto)) redefine(proto, key, methods[key]);
					} else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
				}
				return methods;
			};

			/***/
		},
		/* 135 */
		/***/function (module, exports) {

			module.exports = {};

			/***/
		},
		/* 136 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var create = __webpack_require__(44),
			    descriptor = __webpack_require__(15),
			    setToStringTag = __webpack_require__(22),
			    IteratorPrototype = {};

			// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
			__webpack_require__(8)(IteratorPrototype, __webpack_require__(23)('iterator'), function () {
				return this;
			});

			module.exports = function (Constructor, NAME, next) {
				Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
				setToStringTag(Constructor, NAME + ' Iterator');
			};

			/***/
		},
		/* 137 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.2 String.prototype.anchor(name)

			__webpack_require__(138)('anchor', function (createHTML) {
				return function anchor(name) {
					return createHTML(this, 'a', 'name', name);
				};
			});

			/***/
		},
		/* 138 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    fails = __webpack_require__(5),
			    defined = __webpack_require__(33),
			    quot = /"/g;
			// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
			var createHTML = function (string, tag, attribute, value) {
				var S = String(defined(string)),
				    p1 = '<' + tag;
				if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
				return p1 + '>' + S + '</' + tag + '>';
			};
			module.exports = function (NAME, exec) {
				var O = {};
				O[NAME] = exec(createHTML);
				$export($export.P + $export.F * fails(function () {
					var test = ''[NAME]('"');
					return test !== test.toLowerCase() || test.split('"').length > 3;
				}), 'String', O);
			};

			/***/
		},
		/* 139 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.3 String.prototype.big()

			__webpack_require__(138)('big', function (createHTML) {
				return function big() {
					return createHTML(this, 'big', '', '');
				};
			});

			/***/
		},
		/* 140 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.4 String.prototype.blink()

			__webpack_require__(138)('blink', function (createHTML) {
				return function blink() {
					return createHTML(this, 'blink', '', '');
				};
			});

			/***/
		},
		/* 141 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.5 String.prototype.bold()

			__webpack_require__(138)('bold', function (createHTML) {
				return function bold() {
					return createHTML(this, 'b', '', '');
				};
			});

			/***/
		},
		/* 142 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.6 String.prototype.fixed()

			__webpack_require__(138)('fixed', function (createHTML) {
				return function fixed() {
					return createHTML(this, 'tt', '', '');
				};
			});

			/***/
		},
		/* 143 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.7 String.prototype.fontcolor(color)

			__webpack_require__(138)('fontcolor', function (createHTML) {
				return function fontcolor(color) {
					return createHTML(this, 'font', 'color', color);
				};
			});

			/***/
		},
		/* 144 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.8 String.prototype.fontsize(size)

			__webpack_require__(138)('fontsize', function (createHTML) {
				return function fontsize(size) {
					return createHTML(this, 'font', 'size', size);
				};
			});

			/***/
		},
		/* 145 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.9 String.prototype.italics()

			__webpack_require__(138)('italics', function (createHTML) {
				return function italics() {
					return createHTML(this, 'i', '', '');
				};
			});

			/***/
		},
		/* 146 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.10 String.prototype.link(url)

			__webpack_require__(138)('link', function (createHTML) {
				return function link(url) {
					return createHTML(this, 'a', 'href', url);
				};
			});

			/***/
		},
		/* 147 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.11 String.prototype.small()

			__webpack_require__(138)('small', function (createHTML) {
				return function small() {
					return createHTML(this, 'small', '', '');
				};
			});

			/***/
		},
		/* 148 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.12 String.prototype.strike()

			__webpack_require__(138)('strike', function (createHTML) {
				return function strike() {
					return createHTML(this, 'strike', '', '');
				};
			});

			/***/
		},
		/* 149 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.13 String.prototype.sub()

			__webpack_require__(138)('sub', function (createHTML) {
				return function sub() {
					return createHTML(this, 'sub', '', '');
				};
			});

			/***/
		},
		/* 150 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// B.2.3.14 String.prototype.sup()

			__webpack_require__(138)('sup', function (createHTML) {
				return function sup() {
					return createHTML(this, 'sup', '', '');
				};
			});

			/***/
		},
		/* 151 */
		/***/function (module, exports, __webpack_require__) {

			// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
			var $export = __webpack_require__(6);

			$export($export.S, 'Array', { isArray: __webpack_require__(43) });

			/***/
		},
		/* 152 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var ctx = __webpack_require__(18),
			    $export = __webpack_require__(6),
			    toObject = __webpack_require__(56),
			    call = __webpack_require__(153),
			    isArrayIter = __webpack_require__(154),
			    toLength = __webpack_require__(35),
			    createProperty = __webpack_require__(155),
			    getIterFn = __webpack_require__(156);

			$export($export.S + $export.F * !__webpack_require__(157)(function (iter) {
				Array.from(iter);
			}), 'Array', {
				// 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
				from: function from(arrayLike /*, mapfn = undefined, thisArg = undefined*/) {
					var O = toObject(arrayLike),
					    C = typeof this == 'function' ? this : Array,
					    aLen = arguments.length,
					    mapfn = aLen > 1 ? arguments[1] : undefined,
					    mapping = mapfn !== undefined,
					    index = 0,
					    iterFn = getIterFn(O),
					    length,
					    result,
					    step,
					    iterator;
					if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
					// if object isn't iterable or it's array with default iterator - use simple case
					if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
						for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
							createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
						}
					} else {
						length = toLength(O.length);
						for (result = new C(length); length > index; index++) {
							createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
						}
					}
					result.length = index;
					return result;
				}
			});

			/***/
		},
		/* 153 */
		/***/function (module, exports, __webpack_require__) {

			// call something on iterator step with safe closing on error
			var anObject = __webpack_require__(10);
			module.exports = function (iterator, fn, value, entries) {
				try {
					return entries ? fn(anObject(value)[0], value[1]) : fn(value);
					// 7.4.6 IteratorClose(iterator, completion)
				} catch (e) {
					var ret = iterator['return'];
					if (ret !== undefined) anObject(ret.call(iterator));
					throw e;
				}
			};

			/***/
		},
		/* 154 */
		/***/function (module, exports, __webpack_require__) {

			// check on default Array iterator
			var Iterators = __webpack_require__(135),
			    ITERATOR = __webpack_require__(23)('iterator'),
			    ArrayProto = Array.prototype;

			module.exports = function (it) {
				return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
			};

			/***/
		},
		/* 155 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $defineProperty = __webpack_require__(9),
			    createDesc = __webpack_require__(15);

			module.exports = function (object, index, value) {
				if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
			};

			/***/
		},
		/* 156 */
		/***/function (module, exports, __webpack_require__) {

			var classof = __webpack_require__(73),
			    ITERATOR = __webpack_require__(23)('iterator'),
			    Iterators = __webpack_require__(135);
			module.exports = __webpack_require__(7).getIteratorMethod = function (it) {
				if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
			};

			/***/
		},
		/* 157 */
		/***/function (module, exports, __webpack_require__) {

			var ITERATOR = __webpack_require__(23)('iterator'),
			    SAFE_CLOSING = false;

			try {
				var riter = [7][ITERATOR]();
				riter['return'] = function () {
					SAFE_CLOSING = true;
				};
				Array.from(riter, function () {
					throw 2;
				});
			} catch (e) {/* empty */}

			module.exports = function (exec, skipClosing) {
				if (!skipClosing && !SAFE_CLOSING) return false;
				var safe = false;
				try {
					var arr = [7],
					    iter = arr[ITERATOR]();
					iter.next = function () {
						return { done: safe = true };
					};
					arr[ITERATOR] = function () {
						return iter;
					};
					exec(arr);
				} catch (e) {/* empty */}
				return safe;
			};

			/***/
		},
		/* 158 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    createProperty = __webpack_require__(155);

			// WebKit Array.of isn't generic
			$export($export.S + $export.F * __webpack_require__(5)(function () {
				function F() {}
				return !(Array.of.call(F) instanceof F);
			}), 'Array', {
				// 22.1.2.3 Array.of( ...items)
				of: function of() /* ...args */{
					var index = 0,
					    aLen = arguments.length,
					    result = new (typeof this == 'function' ? this : Array)(aLen);
					while (aLen > index) createProperty(result, index, arguments[index++]);
					result.length = aLen;
					return result;
				}
			});

			/***/
		},
		/* 159 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// 22.1.3.13 Array.prototype.join(separator)

			var $export = __webpack_require__(6),
			    toIObject = __webpack_require__(30),
			    arrayJoin = [].join;

			// fallback for not array-like strings
			$export($export.P + $export.F * (__webpack_require__(31) != Object || !__webpack_require__(160)(arrayJoin)), 'Array', {
				join: function join(separator) {
					return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
				}
			});

			/***/
		},
		/* 160 */
		/***/function (module, exports, __webpack_require__) {

			var fails = __webpack_require__(5);

			module.exports = function (method, arg) {
				return !!method && fails(function () {
					arg ? method.call(null, function () {}, 1) : method.call(null);
				});
			};

			/***/
		},
		/* 161 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    html = __webpack_require__(46),
			    cof = __webpack_require__(32),
			    toIndex = __webpack_require__(37),
			    toLength = __webpack_require__(35),
			    arraySlice = [].slice;

			// fallback for not array-like ES3 strings and DOM objects
			$export($export.P + $export.F * __webpack_require__(5)(function () {
				if (html) arraySlice.call(html);
			}), 'Array', {
				slice: function slice(begin, end) {
					var len = toLength(this.length),
					    klass = cof(this);
					end = end === undefined ? len : end;
					if (klass == 'Array') return arraySlice.call(this, begin, end);
					var start = toIndex(begin, len),
					    upTo = toIndex(end, len),
					    size = toLength(upTo - start),
					    cloned = Array(size),
					    i = 0;
					for (; i < size; i++) cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
					return cloned;
				}
			});

			/***/
		},
		/* 162 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    aFunction = __webpack_require__(19),
			    toObject = __webpack_require__(56),
			    fails = __webpack_require__(5),
			    $sort = [].sort,
			    test = [1, 2, 3];

			$export($export.P + $export.F * (fails(function () {
				// IE8-
				test.sort(undefined);
			}) || !fails(function () {
				// V8 bug
				test.sort(null);
				// Old WebKit
			}) || !__webpack_require__(160)($sort)), 'Array', {
				// 22.1.3.25 Array.prototype.sort(comparefn)
				sort: function sort(comparefn) {
					return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
				}
			});

			/***/
		},
		/* 163 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $forEach = __webpack_require__(164)(0),
			    STRICT = __webpack_require__(160)([].forEach, true);

			$export($export.P + $export.F * !STRICT, 'Array', {
				// 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
				forEach: function forEach(callbackfn /* , thisArg */) {
					return $forEach(this, callbackfn, arguments[1]);
				}
			});

			/***/
		},
		/* 164 */
		/***/function (module, exports, __webpack_require__) {

			// 0 -> Array#forEach
			// 1 -> Array#map
			// 2 -> Array#filter
			// 3 -> Array#some
			// 4 -> Array#every
			// 5 -> Array#find
			// 6 -> Array#findIndex
			var ctx = __webpack_require__(18),
			    IObject = __webpack_require__(31),
			    toObject = __webpack_require__(56),
			    toLength = __webpack_require__(35),
			    asc = __webpack_require__(165);
			module.exports = function (TYPE, $create) {
				var IS_MAP = TYPE == 1,
				    IS_FILTER = TYPE == 2,
				    IS_SOME = TYPE == 3,
				    IS_EVERY = TYPE == 4,
				    IS_FIND_INDEX = TYPE == 6,
				    NO_HOLES = TYPE == 5 || IS_FIND_INDEX,
				    create = $create || asc;
				return function ($this, callbackfn, that) {
					var O = toObject($this),
					    self = IObject(O),
					    f = ctx(callbackfn, that, 3),
					    length = toLength(self.length),
					    index = 0,
					    result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined,
					    val,
					    res;
					for (; length > index; index++) if (NO_HOLES || index in self) {
						val = self[index];
						res = f(val, index, O);
						if (TYPE) {
							if (IS_MAP) result[index] = res; // map
							else if (res) switch (TYPE) {
									case 3:
										return true; // some
									case 5:
										return val; // find
									case 6:
										return index; // findIndex
									case 2:
										result.push(val); // filter
								} else if (IS_EVERY) return false; // every
						}
					}
					return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
				};
			};

			/***/
		},
		/* 165 */
		/***/function (module, exports, __webpack_require__) {

			// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
			var speciesConstructor = __webpack_require__(166);

			module.exports = function (original, length) {
				return new (speciesConstructor(original))(length);
			};

			/***/
		},
		/* 166 */
		/***/function (module, exports, __webpack_require__) {

			var isObject = __webpack_require__(11),
			    isArray = __webpack_require__(43),
			    SPECIES = __webpack_require__(23)('species');

			module.exports = function (original) {
				var C;
				if (isArray(original)) {
					C = original.constructor;
					// cross-realm fallback
					if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
					if (isObject(C)) {
						C = C[SPECIES];
						if (C === null) C = undefined;
					}
				}return C === undefined ? Array : C;
			};

			/***/
		},
		/* 167 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $map = __webpack_require__(164)(1);

			$export($export.P + $export.F * !__webpack_require__(160)([].map, true), 'Array', {
				// 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
				map: function map(callbackfn /* , thisArg */) {
					return $map(this, callbackfn, arguments[1]);
				}
			});

			/***/
		},
		/* 168 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $filter = __webpack_require__(164)(2);

			$export($export.P + $export.F * !__webpack_require__(160)([].filter, true), 'Array', {
				// 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
				filter: function filter(callbackfn /* , thisArg */) {
					return $filter(this, callbackfn, arguments[1]);
				}
			});

			/***/
		},
		/* 169 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $some = __webpack_require__(164)(3);

			$export($export.P + $export.F * !__webpack_require__(160)([].some, true), 'Array', {
				// 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
				some: function some(callbackfn /* , thisArg */) {
					return $some(this, callbackfn, arguments[1]);
				}
			});

			/***/
		},
		/* 170 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $every = __webpack_require__(164)(4);

			$export($export.P + $export.F * !__webpack_require__(160)([].every, true), 'Array', {
				// 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
				every: function every(callbackfn /* , thisArg */) {
					return $every(this, callbackfn, arguments[1]);
				}
			});

			/***/
		},
		/* 171 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $reduce = __webpack_require__(172);

			$export($export.P + $export.F * !__webpack_require__(160)([].reduce, true), 'Array', {
				// 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
				reduce: function reduce(callbackfn /* , initialValue */) {
					return $reduce(this, callbackfn, arguments.length, arguments[1], false);
				}
			});

			/***/
		},
		/* 172 */
		/***/function (module, exports, __webpack_require__) {

			var aFunction = __webpack_require__(19),
			    toObject = __webpack_require__(56),
			    IObject = __webpack_require__(31),
			    toLength = __webpack_require__(35);

			module.exports = function (that, callbackfn, aLen, memo, isRight) {
				aFunction(callbackfn);
				var O = toObject(that),
				    self = IObject(O),
				    length = toLength(O.length),
				    index = isRight ? length - 1 : 0,
				    i = isRight ? -1 : 1;
				if (aLen < 2) for (;;) {
					if (index in self) {
						memo = self[index];
						index += i;
						break;
					}
					index += i;
					if (isRight ? index < 0 : length <= index) {
						throw TypeError('Reduce of empty array with no initial value');
					}
				}
				for (; isRight ? index >= 0 : length > index; index += i) if (index in self) {
					memo = callbackfn(memo, self[index], index, O);
				}
				return memo;
			};

			/***/
		},
		/* 173 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $reduce = __webpack_require__(172);

			$export($export.P + $export.F * !__webpack_require__(160)([].reduceRight, true), 'Array', {
				// 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
				reduceRight: function reduceRight(callbackfn /* , initialValue */) {
					return $reduce(this, callbackfn, arguments.length, arguments[1], true);
				}
			});

			/***/
		},
		/* 174 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $indexOf = __webpack_require__(34)(false),
			    $native = [].indexOf,
			    NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

			$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(160)($native)), 'Array', {
				// 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
				indexOf: function indexOf(searchElement /*, fromIndex = 0 */) {
					return NEGATIVE_ZERO
					// convert -0 to +0
					? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
				}
			});

			/***/
		},
		/* 175 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    toIObject = __webpack_require__(30),
			    toInteger = __webpack_require__(36),
			    toLength = __webpack_require__(35),
			    $native = [].lastIndexOf,
			    NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

			$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(160)($native)), 'Array', {
				// 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
				lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */) {
					// convert -0 to +0
					if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
					var O = toIObject(this),
					    length = toLength(O.length),
					    index = length - 1;
					if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
					if (index < 0) index = length + index;
					for (; index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
					return -1;
				}
			});

			/***/
		},
		/* 176 */
		/***/function (module, exports, __webpack_require__) {

			// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
			var $export = __webpack_require__(6);

			$export($export.P, 'Array', { copyWithin: __webpack_require__(177) });

			__webpack_require__(178)('copyWithin');

			/***/
		},
		/* 177 */
		/***/function (module, exports, __webpack_require__) {

			// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
			'use strict';

			var toObject = __webpack_require__(56),
			    toIndex = __webpack_require__(37),
			    toLength = __webpack_require__(35);

			module.exports = [].copyWithin || function copyWithin(target /*= 0*/, start /*= 0, end = @length*/) {
				var O = toObject(this),
				    len = toLength(O.length),
				    to = toIndex(target, len),
				    from = toIndex(start, len),
				    end = arguments.length > 2 ? arguments[2] : undefined,
				    count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to),
				    inc = 1;
				if (from < to && to < from + count) {
					inc = -1;
					from += count - 1;
					to += count - 1;
				}
				while (count-- > 0) {
					if (from in O) O[to] = O[from];else delete O[to];
					to += inc;
					from += inc;
				}return O;
			};

			/***/
		},
		/* 178 */
		/***/function (module, exports, __webpack_require__) {

			// 22.1.3.31 Array.prototype[@@unscopables]
			var UNSCOPABLES = __webpack_require__(23)('unscopables'),
			    ArrayProto = Array.prototype;
			if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(8)(ArrayProto, UNSCOPABLES, {});
			module.exports = function (key) {
				ArrayProto[UNSCOPABLES][key] = true;
			};

			/***/
		},
		/* 179 */
		/***/function (module, exports, __webpack_require__) {

			// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
			var $export = __webpack_require__(6);

			$export($export.P, 'Array', { fill: __webpack_require__(180) });

			__webpack_require__(178)('fill');

			/***/
		},
		/* 180 */
		/***/function (module, exports, __webpack_require__) {

			// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
			'use strict';

			var toObject = __webpack_require__(56),
			    toIndex = __webpack_require__(37),
			    toLength = __webpack_require__(35);
			module.exports = function fill(value /*, start = 0, end = @length */) {
				var O = toObject(this),
				    length = toLength(O.length),
				    aLen = arguments.length,
				    index = toIndex(aLen > 1 ? arguments[1] : undefined, length),
				    end = aLen > 2 ? arguments[2] : undefined,
				    endPos = end === undefined ? length : toIndex(end, length);
				while (endPos > index) O[index++] = value;
				return O;
			};

			/***/
		},
		/* 181 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

			var $export = __webpack_require__(6),
			    $find = __webpack_require__(164)(5),
			    KEY = 'find',
			    forced = true;
			// Shouldn't skip holes
			if (KEY in []) Array(1)[KEY](function () {
				forced = false;
			});
			$export($export.P + $export.F * forced, 'Array', {
				find: function find(callbackfn /*, that = undefined */) {
					return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
				}
			});
			__webpack_require__(178)(KEY);

			/***/
		},
		/* 182 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

			var $export = __webpack_require__(6),
			    $find = __webpack_require__(164)(6),
			    KEY = 'findIndex',
			    forced = true;
			// Shouldn't skip holes
			if (KEY in []) Array(1)[KEY](function () {
				forced = false;
			});
			$export($export.P + $export.F * forced, 'Array', {
				findIndex: function findIndex(callbackfn /*, that = undefined */) {
					return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
				}
			});
			__webpack_require__(178)(KEY);

			/***/
		},
		/* 183 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var addToUnscopables = __webpack_require__(178),
			    step = __webpack_require__(184),
			    Iterators = __webpack_require__(135),
			    toIObject = __webpack_require__(30);

			// 22.1.3.4 Array.prototype.entries()
			// 22.1.3.13 Array.prototype.keys()
			// 22.1.3.29 Array.prototype.values()
			// 22.1.3.30 Array.prototype[@@iterator]()
			module.exports = __webpack_require__(134)(Array, 'Array', function (iterated, kind) {
				this._t = toIObject(iterated); // target
				this._i = 0; // next index
				this._k = kind; // kind
				// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
			}, function () {
				var O = this._t,
				    kind = this._k,
				    index = this._i++;
				if (!O || index >= O.length) {
					this._t = undefined;
					return step(1);
				}
				if (kind == 'keys') return step(0, index);
				if (kind == 'values') return step(0, O[index]);
				return step(0, [index, O[index]]);
			}, 'values');

			// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
			Iterators.Arguments = Iterators.Array;

			addToUnscopables('keys');
			addToUnscopables('values');
			addToUnscopables('entries');

			/***/
		},
		/* 184 */
		/***/function (module, exports) {

			module.exports = function (done, value) {
				return { value: value, done: !!done };
			};

			/***/
		},
		/* 185 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(186)('Array');

			/***/
		},
		/* 186 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var global = __webpack_require__(2),
			    dP = __webpack_require__(9),
			    DESCRIPTORS = __webpack_require__(4),
			    SPECIES = __webpack_require__(23)('species');

			module.exports = function (KEY) {
				var C = global[KEY];
				if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
					configurable: true,
					get: function () {
						return this;
					}
				});
			};

			/***/
		},
		/* 187 */
		/***/function (module, exports, __webpack_require__) {

			var global = __webpack_require__(2),
			    inheritIfRequired = __webpack_require__(80),
			    dP = __webpack_require__(9).f,
			    gOPN = __webpack_require__(48).f,
			    isRegExp = __webpack_require__(128),
			    $flags = __webpack_require__(188),
			    $RegExp = global.RegExp,
			    Base = $RegExp,
			    proto = $RegExp.prototype,
			    re1 = /a/g,
			    re2 = /a/g
			// "new" creates a new object, old webkit buggy here
			,
			    CORRECT_NEW = new $RegExp(re1) !== re1;

			if (__webpack_require__(4) && (!CORRECT_NEW || __webpack_require__(5)(function () {
				re2[__webpack_require__(23)('match')] = false;
				// RegExp constructor can alter flags and IsRegExp works correct with @@match
				return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
			}))) {
				$RegExp = function RegExp(p, f) {
					var tiRE = this instanceof $RegExp,
					    piRE = isRegExp(p),
					    fiU = f === undefined;
					return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
				};
				var proxy = function (key) {
					key in $RegExp || dP($RegExp, key, {
						configurable: true,
						get: function () {
							return Base[key];
						},
						set: function (it) {
							Base[key] = it;
						}
					});
				};
				for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
				proto.constructor = $RegExp;
				$RegExp.prototype = proto;
				__webpack_require__(16)(global, 'RegExp', $RegExp);
			}

			__webpack_require__(186)('RegExp');

			/***/
		},
		/* 188 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// 21.2.5.3 get RegExp.prototype.flags

			var anObject = __webpack_require__(10);
			module.exports = function () {
				var that = anObject(this),
				    result = '';
				if (that.global) result += 'g';
				if (that.ignoreCase) result += 'i';
				if (that.multiline) result += 'm';
				if (that.unicode) result += 'u';
				if (that.sticky) result += 'y';
				return result;
			};

			/***/
		},
		/* 189 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			__webpack_require__(190);
			var anObject = __webpack_require__(10),
			    $flags = __webpack_require__(188),
			    DESCRIPTORS = __webpack_require__(4),
			    TO_STRING = 'toString',
			    $toString = /./[TO_STRING];

			var define = function (fn) {
				__webpack_require__(16)(RegExp.prototype, TO_STRING, fn, true);
			};

			// 21.2.5.14 RegExp.prototype.toString()
			if (__webpack_require__(5)(function () {
				return $toString.call({ source: 'a', flags: 'b' }) != '/a/b';
			})) {
				define(function toString() {
					var R = anObject(this);
					return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
				});
				// FF44- RegExp#toString has a wrong name
			} else if ($toString.name != TO_STRING) {
				define(function toString() {
					return $toString.call(this);
				});
			}

			/***/
		},
		/* 190 */
		/***/function (module, exports, __webpack_require__) {

			// 21.2.5.3 get RegExp.prototype.flags()
			if (__webpack_require__(4) && /./g.flags != 'g') __webpack_require__(9).f(RegExp.prototype, 'flags', {
				configurable: true,
				get: __webpack_require__(188)
			});

			/***/
		},
		/* 191 */
		/***/function (module, exports, __webpack_require__) {

			// @@match logic
			__webpack_require__(192)('match', 1, function (defined, MATCH, $match) {
				// 21.1.3.11 String.prototype.match(regexp)
				return [function match(regexp) {
					'use strict';

					var O = defined(this),
					    fn = regexp == undefined ? undefined : regexp[MATCH];
					return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
				}, $match];
			});

			/***/
		},
		/* 192 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var hide = __webpack_require__(8),
			    redefine = __webpack_require__(16),
			    fails = __webpack_require__(5),
			    defined = __webpack_require__(33),
			    wks = __webpack_require__(23);

			module.exports = function (KEY, length, exec) {
				var SYMBOL = wks(KEY),
				    fns = exec(defined, SYMBOL, ''[KEY]),
				    strfn = fns[0],
				    rxfn = fns[1];
				if (fails(function () {
					var O = {};
					O[SYMBOL] = function () {
						return 7;
					};
					return ''[KEY](O) != 7;
				})) {
					redefine(String.prototype, KEY, strfn);
					hide(RegExp.prototype, SYMBOL, length == 2
					// 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
					// 21.2.5.11 RegExp.prototype[@@split](string, limit)
					? function (string, arg) {
						return rxfn.call(string, this, arg);
					}
					// 21.2.5.6 RegExp.prototype[@@match](string)
					// 21.2.5.9 RegExp.prototype[@@search](string)
					: function (string) {
						return rxfn.call(string, this);
					});
				}
			};

			/***/
		},
		/* 193 */
		/***/function (module, exports, __webpack_require__) {

			// @@replace logic
			__webpack_require__(192)('replace', 2, function (defined, REPLACE, $replace) {
				// 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
				return [function replace(searchValue, replaceValue) {
					'use strict';

					var O = defined(this),
					    fn = searchValue == undefined ? undefined : searchValue[REPLACE];
					return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
				}, $replace];
			});

			/***/
		},
		/* 194 */
		/***/function (module, exports, __webpack_require__) {

			// @@search logic
			__webpack_require__(192)('search', 1, function (defined, SEARCH, $search) {
				// 21.1.3.15 String.prototype.search(regexp)
				return [function search(regexp) {
					'use strict';

					var O = defined(this),
					    fn = regexp == undefined ? undefined : regexp[SEARCH];
					return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
				}, $search];
			});

			/***/
		},
		/* 195 */
		/***/function (module, exports, __webpack_require__) {

			// @@split logic
			__webpack_require__(192)('split', 2, function (defined, SPLIT, $split) {
				'use strict';

				var isRegExp = __webpack_require__(128),
				    _split = $split,
				    $push = [].push,
				    $SPLIT = 'split',
				    LENGTH = 'length',
				    LAST_INDEX = 'lastIndex';
				if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
					var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
					// based on es5-shim implementation, need to rework it
					$split = function (separator, limit) {
						var string = String(this);
						if (separator === undefined && limit === 0) return [];
						// If `separator` is not a regex, use native split
						if (!isRegExp(separator)) return _split.call(string, separator, limit);
						var output = [];
						var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
						var lastLastIndex = 0;
						var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
						// Make `global` and avoid `lastIndex` issues by working with a copy
						var separatorCopy = new RegExp(separator.source, flags + 'g');
						var separator2, match, lastIndex, lastLength, i;
						// Doesn't need flags gy, but they don't hurt
						if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
						while (match = separatorCopy.exec(string)) {
							// `separatorCopy.lastIndex` is not reliable cross-browser
							lastIndex = match.index + match[0][LENGTH];
							if (lastIndex > lastLastIndex) {
								output.push(string.slice(lastLastIndex, match.index));
								// Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
								if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
									for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
								});
								if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
								lastLength = match[0][LENGTH];
								lastLastIndex = lastIndex;
								if (output[LENGTH] >= splitLimit) break;
							}
							if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
						}
						if (lastLastIndex === string[LENGTH]) {
							if (lastLength || !separatorCopy.test('')) output.push('');
						} else output.push(string.slice(lastLastIndex));
						return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
					};
					// Chakra, V8
				} else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
					$split = function (separator, limit) {
						return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
					};
				}
				// 21.1.3.17 String.prototype.split(separator, limit)
				return [function split(separator, limit) {
					var O = defined(this),
					    fn = separator == undefined ? undefined : separator[SPLIT];
					return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
				}, $split];
			});

			/***/
		},
		/* 196 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var LIBRARY = __webpack_require__(26),
			    global = __webpack_require__(2),
			    ctx = __webpack_require__(18),
			    classof = __webpack_require__(73),
			    $export = __webpack_require__(6),
			    isObject = __webpack_require__(11),
			    aFunction = __webpack_require__(19),
			    anInstance = __webpack_require__(197),
			    forOf = __webpack_require__(198),
			    speciesConstructor = __webpack_require__(199),
			    task = __webpack_require__(200).set,
			    microtask = __webpack_require__(201)(),
			    PROMISE = 'Promise',
			    TypeError = global.TypeError,
			    process = global.process,
			    $Promise = global[PROMISE],
			    process = global.process,
			    isNode = classof(process) == 'process',
			    empty = function () {/* empty */},
			    Internal,
			    GenericPromiseCapability,
			    Wrapper;

			var USE_NATIVE = !!function () {
				try {
					// correct subclassing with @@species support
					var promise = $Promise.resolve(1),
					    FakePromise = (promise.constructor = {})[__webpack_require__(23)('species')] = function (exec) {
						exec(empty, empty);
					};
					// unhandled rejections tracking support, NodeJS Promise without it fails @@species test
					return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
				} catch (e) {/* empty */}
			}();

			// helpers
			var sameConstructor = function (a, b) {
				// with library wrapper special case
				return a === b || a === $Promise && b === Wrapper;
			};
			var isThenable = function (it) {
				var then;
				return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
			};
			var newPromiseCapability = function (C) {
				return sameConstructor($Promise, C) ? new PromiseCapability(C) : new GenericPromiseCapability(C);
			};
			var PromiseCapability = GenericPromiseCapability = function (C) {
				var resolve, reject;
				this.promise = new C(function ($$resolve, $$reject) {
					if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
					resolve = $$resolve;
					reject = $$reject;
				});
				this.resolve = aFunction(resolve);
				this.reject = aFunction(reject);
			};
			var perform = function (exec) {
				try {
					exec();
				} catch (e) {
					return { error: e };
				}
			};
			var notify = function (promise, isReject) {
				if (promise._n) return;
				promise._n = true;
				var chain = promise._c;
				microtask(function () {
					var value = promise._v,
					    ok = promise._s == 1,
					    i = 0;
					var run = function (reaction) {
						var handler = ok ? reaction.ok : reaction.fail,
						    resolve = reaction.resolve,
						    reject = reaction.reject,
						    domain = reaction.domain,
						    result,
						    then;
						try {
							if (handler) {
								if (!ok) {
									if (promise._h == 2) onHandleUnhandled(promise);
									promise._h = 1;
								}
								if (handler === true) result = value;else {
									if (domain) domain.enter();
									result = handler(value);
									if (domain) domain.exit();
								}
								if (result === reaction.promise) {
									reject(TypeError('Promise-chain cycle'));
								} else if (then = isThenable(result)) {
									then.call(result, resolve, reject);
								} else resolve(result);
							} else reject(value);
						} catch (e) {
							reject(e);
						}
					};
					while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
					promise._c = [];
					promise._n = false;
					if (isReject && !promise._h) onUnhandled(promise);
				});
			};
			var onUnhandled = function (promise) {
				task.call(global, function () {
					var value = promise._v,
					    abrupt,
					    handler,
					    console;
					if (isUnhandled(promise)) {
						abrupt = perform(function () {
							if (isNode) {
								process.emit('unhandledRejection', value, promise);
							} else if (handler = global.onunhandledrejection) {
								handler({ promise: promise, reason: value });
							} else if ((console = global.console) && console.error) {
								console.error('Unhandled promise rejection', value);
							}
						});
						// Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
						promise._h = isNode || isUnhandled(promise) ? 2 : 1;
					}promise._a = undefined;
					if (abrupt) throw abrupt.error;
				});
			};
			var isUnhandled = function (promise) {
				if (promise._h == 1) return false;
				var chain = promise._a || promise._c,
				    i = 0,
				    reaction;
				while (chain.length > i) {
					reaction = chain[i++];
					if (reaction.fail || !isUnhandled(reaction.promise)) return false;
				}return true;
			};
			var onHandleUnhandled = function (promise) {
				task.call(global, function () {
					var handler;
					if (isNode) {
						process.emit('rejectionHandled', promise);
					} else if (handler = global.onrejectionhandled) {
						handler({ promise: promise, reason: promise._v });
					}
				});
			};
			var $reject = function (value) {
				var promise = this;
				if (promise._d) return;
				promise._d = true;
				promise = promise._w || promise; // unwrap
				promise._v = value;
				promise._s = 2;
				if (!promise._a) promise._a = promise._c.slice();
				notify(promise, true);
			};
			var $resolve = function (value) {
				var promise = this,
				    then;
				if (promise._d) return;
				promise._d = true;
				promise = promise._w || promise; // unwrap
				try {
					if (promise === value) throw TypeError("Promise can't be resolved itself");
					if (then = isThenable(value)) {
						microtask(function () {
							var wrapper = { _w: promise, _d: false }; // wrap
							try {
								then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
							} catch (e) {
								$reject.call(wrapper, e);
							}
						});
					} else {
						promise._v = value;
						promise._s = 1;
						notify(promise, false);
					}
				} catch (e) {
					$reject.call({ _w: promise, _d: false }, e); // wrap
				}
			};

			// constructor polyfill
			if (!USE_NATIVE) {
				// 25.4.3.1 Promise(executor)
				$Promise = function Promise(executor) {
					anInstance(this, $Promise, PROMISE, '_h');
					aFunction(executor);
					Internal.call(this);
					try {
						executor(ctx($resolve, this, 1), ctx($reject, this, 1));
					} catch (err) {
						$reject.call(this, err);
					}
				};
				Internal = function Promise(executor) {
					this._c = []; // <- awaiting reactions
					this._a = undefined; // <- checked in isUnhandled reactions
					this._s = 0; // <- state
					this._d = false; // <- done
					this._v = undefined; // <- value
					this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
					this._n = false; // <- notify
				};
				Internal.prototype = __webpack_require__(202)($Promise.prototype, {
					// 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
					then: function then(onFulfilled, onRejected) {
						var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
						reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
						reaction.fail = typeof onRejected == 'function' && onRejected;
						reaction.domain = isNode ? process.domain : undefined;
						this._c.push(reaction);
						if (this._a) this._a.push(reaction);
						if (this._s) notify(this, false);
						return reaction.promise;
					},
					// 25.4.5.1 Promise.prototype.catch(onRejected)
					'catch': function (onRejected) {
						return this.then(undefined, onRejected);
					}
				});
				PromiseCapability = function () {
					var promise = new Internal();
					this.promise = promise;
					this.resolve = ctx($resolve, promise, 1);
					this.reject = ctx($reject, promise, 1);
				};
			}

			$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
			__webpack_require__(22)($Promise, PROMISE);
			__webpack_require__(186)(PROMISE);
			Wrapper = __webpack_require__(7)[PROMISE];

			// statics
			$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
				// 25.4.4.5 Promise.reject(r)
				reject: function reject(r) {
					var capability = newPromiseCapability(this),
					    $$reject = capability.reject;
					$$reject(r);
					return capability.promise;
				}
			});
			$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
				// 25.4.4.6 Promise.resolve(x)
				resolve: function resolve(x) {
					// instanceof instead of internal slot check because we should fix it without replacement native Promise core
					if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;
					var capability = newPromiseCapability(this),
					    $$resolve = capability.resolve;
					$$resolve(x);
					return capability.promise;
				}
			});
			$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(157)(function (iter) {
				$Promise.all(iter)['catch'](empty);
			})), PROMISE, {
				// 25.4.4.1 Promise.all(iterable)
				all: function all(iterable) {
					var C = this,
					    capability = newPromiseCapability(C),
					    resolve = capability.resolve,
					    reject = capability.reject;
					var abrupt = perform(function () {
						var values = [],
						    index = 0,
						    remaining = 1;
						forOf(iterable, false, function (promise) {
							var $index = index++,
							    alreadyCalled = false;
							values.push(undefined);
							remaining++;
							C.resolve(promise).then(function (value) {
								if (alreadyCalled) return;
								alreadyCalled = true;
								values[$index] = value;
								--remaining || resolve(values);
							}, reject);
						});
						--remaining || resolve(values);
					});
					if (abrupt) reject(abrupt.error);
					return capability.promise;
				},
				// 25.4.4.4 Promise.race(iterable)
				race: function race(iterable) {
					var C = this,
					    capability = newPromiseCapability(C),
					    reject = capability.reject;
					var abrupt = perform(function () {
						forOf(iterable, false, function (promise) {
							C.resolve(promise).then(capability.resolve, reject);
						});
					});
					if (abrupt) reject(abrupt.error);
					return capability.promise;
				}
			});

			/***/
		},
		/* 197 */
		/***/function (module, exports) {

			module.exports = function (it, Constructor, name, forbiddenField) {
				if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
					throw TypeError(name + ': incorrect invocation!');
				}return it;
			};

			/***/
		},
		/* 198 */
		/***/function (module, exports, __webpack_require__) {

			var ctx = __webpack_require__(18),
			    call = __webpack_require__(153),
			    isArrayIter = __webpack_require__(154),
			    anObject = __webpack_require__(10),
			    toLength = __webpack_require__(35),
			    getIterFn = __webpack_require__(156),
			    BREAK = {},
			    RETURN = {};
			var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
				var iterFn = ITERATOR ? function () {
					return iterable;
				} : getIterFn(iterable),
				    f = ctx(fn, that, entries ? 2 : 1),
				    index = 0,
				    length,
				    step,
				    iterator,
				    result;
				if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
				// fast case for arrays with default iterator
				if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
					result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
					if (result === BREAK || result === RETURN) return result;
				} else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
					result = call(iterator, f, step.value, entries);
					if (result === BREAK || result === RETURN) return result;
				}
			};
			exports.BREAK = BREAK;
			exports.RETURN = RETURN;

			/***/
		},
		/* 199 */
		/***/function (module, exports, __webpack_require__) {

			// 7.3.20 SpeciesConstructor(O, defaultConstructor)
			var anObject = __webpack_require__(10),
			    aFunction = __webpack_require__(19),
			    SPECIES = __webpack_require__(23)('species');
			module.exports = function (O, D) {
				var C = anObject(O).constructor,
				    S;
				return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
			};

			/***/
		},
		/* 200 */
		/***/function (module, exports, __webpack_require__) {

			var ctx = __webpack_require__(18),
			    invoke = __webpack_require__(76),
			    html = __webpack_require__(46),
			    cel = __webpack_require__(13),
			    global = __webpack_require__(2),
			    process = global.process,
			    setTask = global.setImmediate,
			    clearTask = global.clearImmediate,
			    MessageChannel = global.MessageChannel,
			    counter = 0,
			    queue = {},
			    ONREADYSTATECHANGE = 'onreadystatechange',
			    defer,
			    channel,
			    port;
			var run = function () {
				var id = +this;
				if (queue.hasOwnProperty(id)) {
					var fn = queue[id];
					delete queue[id];
					fn();
				}
			};
			var listener = function (event) {
				run.call(event.data);
			};
			// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
			if (!setTask || !clearTask) {
				setTask = function setImmediate(fn) {
					var args = [],
					    i = 1;
					while (arguments.length > i) args.push(arguments[i++]);
					queue[++counter] = function () {
						invoke(typeof fn == 'function' ? fn : Function(fn), args);
					};
					defer(counter);
					return counter;
				};
				clearTask = function clearImmediate(id) {
					delete queue[id];
				};
				// Node.js 0.8-
				if (__webpack_require__(32)(process) == 'process') {
					defer = function (id) {
						process.nextTick(ctx(run, id, 1));
					};
					// Browsers with MessageChannel, includes WebWorkers
				} else if (MessageChannel) {
					channel = new MessageChannel();
					port = channel.port2;
					channel.port1.onmessage = listener;
					defer = ctx(port.postMessage, port, 1);
					// Browsers with postMessage, skip WebWorkers
					// IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
				} else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
					defer = function (id) {
						global.postMessage(id + '', '*');
					};
					global.addEventListener('message', listener, false);
					// IE8-
				} else if (ONREADYSTATECHANGE in cel('script')) {
					defer = function (id) {
						html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
							html.removeChild(this);
							run.call(id);
						};
					};
					// Rest old browsers
				} else {
					defer = function (id) {
						setTimeout(ctx(run, id, 1), 0);
					};
				}
			}
			module.exports = {
				set: setTask,
				clear: clearTask
			};

			/***/
		},
		/* 201 */
		/***/function (module, exports, __webpack_require__) {

			var global = __webpack_require__(2),
			    macrotask = __webpack_require__(200).set,
			    Observer = global.MutationObserver || global.WebKitMutationObserver,
			    process = global.process,
			    Promise = global.Promise,
			    isNode = __webpack_require__(32)(process) == 'process';

			module.exports = function () {
				var head, last, notify;

				var flush = function () {
					var parent, fn;
					if (isNode && (parent = process.domain)) parent.exit();
					while (head) {
						fn = head.fn;
						head = head.next;
						try {
							fn();
						} catch (e) {
							if (head) notify();else last = undefined;
							throw e;
						}
					}last = undefined;
					if (parent) parent.enter();
				};

				// Node.js
				if (isNode) {
					notify = function () {
						process.nextTick(flush);
					};
					// browsers with MutationObserver
				} else if (Observer) {
					var toggle = true,
					    node = document.createTextNode('');
					new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
					notify = function () {
						node.data = toggle = !toggle;
					};
					// environments with maybe non-completely correct, but existent Promise
				} else if (Promise && Promise.resolve) {
					var promise = Promise.resolve();
					notify = function () {
						promise.then(flush);
					};
					// for other environments - macrotask based on:
					// - setImmediate
					// - MessageChannel
					// - window.postMessag
					// - onreadystatechange
					// - setTimeout
				} else {
					notify = function () {
						// strange IE + webpack dev server bug - use .call(global)
						macrotask.call(global, flush);
					};
				}

				return function (fn) {
					var task = { fn: fn, next: undefined };
					if (last) last.next = task;
					if (!head) {
						head = task;
						notify();
					}last = task;
				};
			};

			/***/
		},
		/* 202 */
		/***/function (module, exports, __webpack_require__) {

			var redefine = __webpack_require__(16);
			module.exports = function (target, src, safe) {
				for (var key in src) redefine(target, key, src[key], safe);
				return target;
			};

			/***/
		},
		/* 203 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var strong = __webpack_require__(204);

			// 23.1 Map Objects
			module.exports = __webpack_require__(205)('Map', function (get) {
				return function Map() {
					return get(this, arguments.length > 0 ? arguments[0] : undefined);
				};
			}, {
				// 23.1.3.6 Map.prototype.get(key)
				get: function get(key) {
					var entry = strong.getEntry(this, key);
					return entry && entry.v;
				},
				// 23.1.3.9 Map.prototype.set(key, value)
				set: function set(key, value) {
					return strong.def(this, key === 0 ? 0 : key, value);
				}
			}, strong, true);

			/***/
		},
		/* 204 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var dP = __webpack_require__(9).f,
			    create = __webpack_require__(44),
			    redefineAll = __webpack_require__(202),
			    ctx = __webpack_require__(18),
			    anInstance = __webpack_require__(197),
			    defined = __webpack_require__(33),
			    forOf = __webpack_require__(198),
			    $iterDefine = __webpack_require__(134),
			    step = __webpack_require__(184),
			    setSpecies = __webpack_require__(186),
			    DESCRIPTORS = __webpack_require__(4),
			    fastKey = __webpack_require__(20).fastKey,
			    SIZE = DESCRIPTORS ? '_s' : 'size';

			var getEntry = function (that, key) {
				// fast case
				var index = fastKey(key),
				    entry;
				if (index !== 'F') return that._i[index];
				// frozen object case
				for (entry = that._f; entry; entry = entry.n) {
					if (entry.k == key) return entry;
				}
			};

			module.exports = {
				getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
					var C = wrapper(function (that, iterable) {
						anInstance(that, C, NAME, '_i');
						that._i = create(null); // index
						that._f = undefined; // first entry
						that._l = undefined; // last entry
						that[SIZE] = 0; // size
						if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
					});
					redefineAll(C.prototype, {
						// 23.1.3.1 Map.prototype.clear()
						// 23.2.3.2 Set.prototype.clear()
						clear: function clear() {
							for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {
								entry.r = true;
								if (entry.p) entry.p = entry.p.n = undefined;
								delete data[entry.i];
							}
							that._f = that._l = undefined;
							that[SIZE] = 0;
						},
						// 23.1.3.3 Map.prototype.delete(key)
						// 23.2.3.4 Set.prototype.delete(value)
						'delete': function (key) {
							var that = this,
							    entry = getEntry(that, key);
							if (entry) {
								var next = entry.n,
								    prev = entry.p;
								delete that._i[entry.i];
								entry.r = true;
								if (prev) prev.n = next;
								if (next) next.p = prev;
								if (that._f == entry) that._f = next;
								if (that._l == entry) that._l = prev;
								that[SIZE]--;
							}return !!entry;
						},
						// 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
						// 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
						forEach: function forEach(callbackfn /*, that = undefined */) {
							anInstance(this, C, 'forEach');
							var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
							    entry;
							while (entry = entry ? entry.n : this._f) {
								f(entry.v, entry.k, this);
								// revert to the last existing entry
								while (entry && entry.r) entry = entry.p;
							}
						},
						// 23.1.3.7 Map.prototype.has(key)
						// 23.2.3.7 Set.prototype.has(value)
						has: function has(key) {
							return !!getEntry(this, key);
						}
					});
					if (DESCRIPTORS) dP(C.prototype, 'size', {
						get: function () {
							return defined(this[SIZE]);
						}
					});
					return C;
				},
				def: function (that, key, value) {
					var entry = getEntry(that, key),
					    prev,
					    index;
					// change existing entry
					if (entry) {
						entry.v = value;
						// create new entry
					} else {
						that._l = entry = {
							i: index = fastKey(key, true), // <- index
							k: key, // <- key
							v: value, // <- value
							p: prev = that._l, // <- previous entry
							n: undefined, // <- next entry
							r: false // <- removed
						};
						if (!that._f) that._f = entry;
						if (prev) prev.n = entry;
						that[SIZE]++;
						// add to index
						if (index !== 'F') that._i[index] = entry;
					}return that;
				},
				getEntry: getEntry,
				setStrong: function (C, NAME, IS_MAP) {
					// add .keys, .values, .entries, [@@iterator]
					// 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
					$iterDefine(C, NAME, function (iterated, kind) {
						this._t = iterated; // target
						this._k = kind; // kind
						this._l = undefined; // previous
					}, function () {
						var that = this,
						    kind = that._k,
						    entry = that._l;
						// revert to the last existing entry
						while (entry && entry.r) entry = entry.p;
						// get next entry
						if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
							// or finish the iteration
							that._t = undefined;
							return step(1);
						}
						// return step by kind
						if (kind == 'keys') return step(0, entry.k);
						if (kind == 'values') return step(0, entry.v);
						return step(0, [entry.k, entry.v]);
					}, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

					// add [@@species], 23.1.2.2, 23.2.2.2
					setSpecies(NAME);
				}
			};

			/***/
		},
		/* 205 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var global = __webpack_require__(2),
			    $export = __webpack_require__(6),
			    redefine = __webpack_require__(16),
			    redefineAll = __webpack_require__(202),
			    meta = __webpack_require__(20),
			    forOf = __webpack_require__(198),
			    anInstance = __webpack_require__(197),
			    isObject = __webpack_require__(11),
			    fails = __webpack_require__(5),
			    $iterDetect = __webpack_require__(157),
			    setToStringTag = __webpack_require__(22),
			    inheritIfRequired = __webpack_require__(80);

			module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
				var Base = global[NAME],
				    C = Base,
				    ADDER = IS_MAP ? 'set' : 'add',
				    proto = C && C.prototype,
				    O = {};
				var fixMethod = function (KEY) {
					var fn = proto[KEY];
					redefine(proto, KEY, KEY == 'delete' ? function (a) {
						return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
					} : KEY == 'has' ? function has(a) {
						return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
					} : KEY == 'get' ? function get(a) {
						return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
					} : KEY == 'add' ? function add(a) {
						fn.call(this, a === 0 ? 0 : a);return this;
					} : function set(a, b) {
						fn.call(this, a === 0 ? 0 : a, b);return this;
					});
				};
				if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
					new C().entries().next();
				}))) {
					// create collection constructor
					C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
					redefineAll(C.prototype, methods);
					meta.NEED = true;
				} else {
					var instance = new C()
					// early implementations not supports chaining
					,
					    HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
					// V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
					,
					    THROWS_ON_PRIMITIVES = fails(function () {
						instance.has(1);
					})
					// most early implementations doesn't supports iterables, most modern - not close it correctly
					,
					    ACCEPT_ITERABLES = $iterDetect(function (iter) {
						new C(iter);
					}) // eslint-disable-line no-new
					// for early implementations -0 and +0 not the same
					,
					    BUGGY_ZERO = !IS_WEAK && fails(function () {
						// V8 ~ Chromium 42- fails only with 5+ elements
						var $instance = new C(),
						    index = 5;
						while (index--) $instance[ADDER](index, index);
						return !$instance.has(-0);
					});
					if (!ACCEPT_ITERABLES) {
						C = wrapper(function (target, iterable) {
							anInstance(target, C, NAME);
							var that = inheritIfRequired(new Base(), target, C);
							if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
							return that;
						});
						C.prototype = proto;
						proto.constructor = C;
					}
					if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
						fixMethod('delete');
						fixMethod('has');
						IS_MAP && fixMethod('get');
					}
					if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
					// weak collections should not contains .clear method
					if (IS_WEAK && proto.clear) delete proto.clear;
				}

				setToStringTag(C, NAME);

				O[NAME] = C;
				$export($export.G + $export.W + $export.F * (C != Base), O);

				if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

				return C;
			};

			/***/
		},
		/* 206 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var strong = __webpack_require__(204);

			// 23.2 Set Objects
			module.exports = __webpack_require__(205)('Set', function (get) {
				return function Set() {
					return get(this, arguments.length > 0 ? arguments[0] : undefined);
				};
			}, {
				// 23.2.3.1 Set.prototype.add(value)
				add: function add(value) {
					return strong.def(this, value = value === 0 ? 0 : value, value);
				}
			}, strong);

			/***/
		},
		/* 207 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var each = __webpack_require__(164)(0),
			    redefine = __webpack_require__(16),
			    meta = __webpack_require__(20),
			    assign = __webpack_require__(67),
			    weak = __webpack_require__(208),
			    isObject = __webpack_require__(11),
			    getWeak = meta.getWeak,
			    isExtensible = Object.isExtensible,
			    uncaughtFrozenStore = weak.ufstore,
			    tmp = {},
			    InternalMap;

			var wrapper = function (get) {
				return function WeakMap() {
					return get(this, arguments.length > 0 ? arguments[0] : undefined);
				};
			};

			var methods = {
				// 23.3.3.3 WeakMap.prototype.get(key)
				get: function get(key) {
					if (isObject(key)) {
						var data = getWeak(key);
						if (data === true) return uncaughtFrozenStore(this).get(key);
						return data ? data[this._i] : undefined;
					}
				},
				// 23.3.3.5 WeakMap.prototype.set(key, value)
				set: function set(key, value) {
					return weak.def(this, key, value);
				}
			};

			// 23.3 WeakMap Objects
			var $WeakMap = module.exports = __webpack_require__(205)('WeakMap', wrapper, methods, weak, true, true);

			// IE11 WeakMap frozen keys fix
			if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
				InternalMap = weak.getConstructor(wrapper);
				assign(InternalMap.prototype, methods);
				meta.NEED = true;
				each(['delete', 'has', 'get', 'set'], function (key) {
					var proto = $WeakMap.prototype,
					    method = proto[key];
					redefine(proto, key, function (a, b) {
						// store frozen objects on internal weakmap shim
						if (isObject(a) && !isExtensible(a)) {
							if (!this._f) this._f = new InternalMap();
							var result = this._f[key](a, b);
							return key == 'set' ? this : result;
							// store all the rest on native weakmap
						}return method.call(this, a, b);
					});
				});
			}

			/***/
		},
		/* 208 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var redefineAll = __webpack_require__(202),
			    getWeak = __webpack_require__(20).getWeak,
			    anObject = __webpack_require__(10),
			    isObject = __webpack_require__(11),
			    anInstance = __webpack_require__(197),
			    forOf = __webpack_require__(198),
			    createArrayMethod = __webpack_require__(164),
			    $has = __webpack_require__(3),
			    arrayFind = createArrayMethod(5),
			    arrayFindIndex = createArrayMethod(6),
			    id = 0;

			// fallback for uncaught frozen keys
			var uncaughtFrozenStore = function (that) {
				return that._l || (that._l = new UncaughtFrozenStore());
			};
			var UncaughtFrozenStore = function () {
				this.a = [];
			};
			var findUncaughtFrozen = function (store, key) {
				return arrayFind(store.a, function (it) {
					return it[0] === key;
				});
			};
			UncaughtFrozenStore.prototype = {
				get: function (key) {
					var entry = findUncaughtFrozen(this, key);
					if (entry) return entry[1];
				},
				has: function (key) {
					return !!findUncaughtFrozen(this, key);
				},
				set: function (key, value) {
					var entry = findUncaughtFrozen(this, key);
					if (entry) entry[1] = value;else this.a.push([key, value]);
				},
				'delete': function (key) {
					var index = arrayFindIndex(this.a, function (it) {
						return it[0] === key;
					});
					if (~index) this.a.splice(index, 1);
					return !!~index;
				}
			};

			module.exports = {
				getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
					var C = wrapper(function (that, iterable) {
						anInstance(that, C, NAME, '_i');
						that._i = id++; // collection id
						that._l = undefined; // leak store for uncaught frozen objects
						if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
					});
					redefineAll(C.prototype, {
						// 23.3.3.2 WeakMap.prototype.delete(key)
						// 23.4.3.3 WeakSet.prototype.delete(value)
						'delete': function (key) {
							if (!isObject(key)) return false;
							var data = getWeak(key);
							if (data === true) return uncaughtFrozenStore(this)['delete'](key);
							return data && $has(data, this._i) && delete data[this._i];
						},
						// 23.3.3.4 WeakMap.prototype.has(key)
						// 23.4.3.4 WeakSet.prototype.has(value)
						has: function has(key) {
							if (!isObject(key)) return false;
							var data = getWeak(key);
							if (data === true) return uncaughtFrozenStore(this).has(key);
							return data && $has(data, this._i);
						}
					});
					return C;
				},
				def: function (that, key, value) {
					var data = getWeak(anObject(key), true);
					if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
					return that;
				},
				ufstore: uncaughtFrozenStore
			};

			/***/
		},
		/* 209 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var weak = __webpack_require__(208);

			// 23.4 WeakSet Objects
			__webpack_require__(205)('WeakSet', function (get) {
				return function WeakSet() {
					return get(this, arguments.length > 0 ? arguments[0] : undefined);
				};
			}, {
				// 23.4.3.1 WeakSet.prototype.add(value)
				add: function add(value) {
					return weak.def(this, value, true);
				}
			}, weak, false, true);

			/***/
		},
		/* 210 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
			var $export = __webpack_require__(6),
			    aFunction = __webpack_require__(19),
			    anObject = __webpack_require__(10),
			    rApply = (__webpack_require__(2).Reflect || {}).apply,
			    fApply = Function.apply;
			// MS Edge argumentsList argument is optional
			$export($export.S + $export.F * !__webpack_require__(5)(function () {
				rApply(function () {});
			}), 'Reflect', {
				apply: function apply(target, thisArgument, argumentsList) {
					var T = aFunction(target),
					    L = anObject(argumentsList);
					return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
				}
			});

			/***/
		},
		/* 211 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
			var $export = __webpack_require__(6),
			    create = __webpack_require__(44),
			    aFunction = __webpack_require__(19),
			    anObject = __webpack_require__(10),
			    isObject = __webpack_require__(11),
			    fails = __webpack_require__(5),
			    bind = __webpack_require__(75),
			    rConstruct = (__webpack_require__(2).Reflect || {}).construct;

			// MS Edge supports only 2 arguments and argumentsList argument is optional
			// FF Nightly sets third argument as `new.target`, but does not create `this` from it
			var NEW_TARGET_BUG = fails(function () {
				function F() {}
				return !(rConstruct(function () {}, [], F) instanceof F);
			});
			var ARGS_BUG = !fails(function () {
				rConstruct(function () {});
			});

			$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
				construct: function construct(Target, args /*, newTarget*/) {
					aFunction(Target);
					anObject(args);
					var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
					if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
					if (Target == newTarget) {
						// w/o altered newTarget, optimization for 0-4 arguments
						switch (args.length) {
							case 0:
								return new Target();
							case 1:
								return new Target(args[0]);
							case 2:
								return new Target(args[0], args[1]);
							case 3:
								return new Target(args[0], args[1], args[2]);
							case 4:
								return new Target(args[0], args[1], args[2], args[3]);
						}
						// w/o altered newTarget, lot of arguments case
						var $args = [null];
						$args.push.apply($args, args);
						return new (bind.apply(Target, $args))();
					}
					// with altered newTarget, not support built-in constructors
					var proto = newTarget.prototype,
					    instance = create(isObject(proto) ? proto : Object.prototype),
					    result = Function.apply.call(Target, instance, args);
					return isObject(result) ? result : instance;
				}
			});

			/***/
		},
		/* 212 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
			var dP = __webpack_require__(9),
			    $export = __webpack_require__(6),
			    anObject = __webpack_require__(10),
			    toPrimitive = __webpack_require__(14);

			// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
			$export($export.S + $export.F * __webpack_require__(5)(function () {
				Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
			}), 'Reflect', {
				defineProperty: function defineProperty(target, propertyKey, attributes) {
					anObject(target);
					propertyKey = toPrimitive(propertyKey, true);
					anObject(attributes);
					try {
						dP.f(target, propertyKey, attributes);
						return true;
					} catch (e) {
						return false;
					}
				}
			});

			/***/
		},
		/* 213 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.4 Reflect.deleteProperty(target, propertyKey)
			var $export = __webpack_require__(6),
			    gOPD = __webpack_require__(49).f,
			    anObject = __webpack_require__(10);

			$export($export.S, 'Reflect', {
				deleteProperty: function deleteProperty(target, propertyKey) {
					var desc = gOPD(anObject(target), propertyKey);
					return desc && !desc.configurable ? false : delete target[propertyKey];
				}
			});

			/***/
		},
		/* 214 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// 26.1.5 Reflect.enumerate(target)

			var $export = __webpack_require__(6),
			    anObject = __webpack_require__(10);
			var Enumerate = function (iterated) {
				this._t = anObject(iterated); // target
				this._i = 0; // next index
				var keys = this._k = [] // keys
				,
				    key;
				for (key in iterated) keys.push(key);
			};
			__webpack_require__(136)(Enumerate, 'Object', function () {
				var that = this,
				    keys = that._k,
				    key;
				do {
					if (that._i >= keys.length) return { value: undefined, done: true };
				} while (!((key = keys[that._i++]) in that._t));
				return { value: key, done: false };
			});

			$export($export.S, 'Reflect', {
				enumerate: function enumerate(target) {
					return new Enumerate(target);
				}
			});

			/***/
		},
		/* 215 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.6 Reflect.get(target, propertyKey [, receiver])
			var gOPD = __webpack_require__(49),
			    getPrototypeOf = __webpack_require__(57),
			    has = __webpack_require__(3),
			    $export = __webpack_require__(6),
			    isObject = __webpack_require__(11),
			    anObject = __webpack_require__(10);

			function get(target, propertyKey /*, receiver*/) {
				var receiver = arguments.length < 3 ? target : arguments[2],
				    desc,
				    proto;
				if (anObject(target) === receiver) return target[propertyKey];
				if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
				if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
			}

			$export($export.S, 'Reflect', { get: get });

			/***/
		},
		/* 216 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
			var gOPD = __webpack_require__(49),
			    $export = __webpack_require__(6),
			    anObject = __webpack_require__(10);

			$export($export.S, 'Reflect', {
				getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
					return gOPD.f(anObject(target), propertyKey);
				}
			});

			/***/
		},
		/* 217 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.8 Reflect.getPrototypeOf(target)
			var $export = __webpack_require__(6),
			    getProto = __webpack_require__(57),
			    anObject = __webpack_require__(10);

			$export($export.S, 'Reflect', {
				getPrototypeOf: function getPrototypeOf(target) {
					return getProto(anObject(target));
				}
			});

			/***/
		},
		/* 218 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.9 Reflect.has(target, propertyKey)
			var $export = __webpack_require__(6);

			$export($export.S, 'Reflect', {
				has: function has(target, propertyKey) {
					return propertyKey in target;
				}
			});

			/***/
		},
		/* 219 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.10 Reflect.isExtensible(target)
			var $export = __webpack_require__(6),
			    anObject = __webpack_require__(10),
			    $isExtensible = Object.isExtensible;

			$export($export.S, 'Reflect', {
				isExtensible: function isExtensible(target) {
					anObject(target);
					return $isExtensible ? $isExtensible(target) : true;
				}
			});

			/***/
		},
		/* 220 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.11 Reflect.ownKeys(target)
			var $export = __webpack_require__(6);

			$export($export.S, 'Reflect', { ownKeys: __webpack_require__(221) });

			/***/
		},
		/* 221 */
		/***/function (module, exports, __webpack_require__) {

			// all object keys, includes non-enumerable and symbols
			var gOPN = __webpack_require__(48),
			    gOPS = __webpack_require__(41),
			    anObject = __webpack_require__(10),
			    Reflect = __webpack_require__(2).Reflect;
			module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
				var keys = gOPN.f(anObject(it)),
				    getSymbols = gOPS.f;
				return getSymbols ? keys.concat(getSymbols(it)) : keys;
			};

			/***/
		},
		/* 222 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.12 Reflect.preventExtensions(target)
			var $export = __webpack_require__(6),
			    anObject = __webpack_require__(10),
			    $preventExtensions = Object.preventExtensions;

			$export($export.S, 'Reflect', {
				preventExtensions: function preventExtensions(target) {
					anObject(target);
					try {
						if ($preventExtensions) $preventExtensions(target);
						return true;
					} catch (e) {
						return false;
					}
				}
			});

			/***/
		},
		/* 223 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
			var dP = __webpack_require__(9),
			    gOPD = __webpack_require__(49),
			    getPrototypeOf = __webpack_require__(57),
			    has = __webpack_require__(3),
			    $export = __webpack_require__(6),
			    createDesc = __webpack_require__(15),
			    anObject = __webpack_require__(10),
			    isObject = __webpack_require__(11);

			function set(target, propertyKey, V /*, receiver*/) {
				var receiver = arguments.length < 4 ? target : arguments[3],
				    ownDesc = gOPD.f(anObject(target), propertyKey),
				    existingDescriptor,
				    proto;
				if (!ownDesc) {
					if (isObject(proto = getPrototypeOf(target))) {
						return set(proto, propertyKey, V, receiver);
					}
					ownDesc = createDesc(0);
				}
				if (has(ownDesc, 'value')) {
					if (ownDesc.writable === false || !isObject(receiver)) return false;
					existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
					existingDescriptor.value = V;
					dP.f(receiver, propertyKey, existingDescriptor);
					return true;
				}
				return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
			}

			$export($export.S, 'Reflect', { set: set });

			/***/
		},
		/* 224 */
		/***/function (module, exports, __webpack_require__) {

			// 26.1.14 Reflect.setPrototypeOf(target, proto)
			var $export = __webpack_require__(6),
			    setProto = __webpack_require__(71);

			if (setProto) $export($export.S, 'Reflect', {
				setPrototypeOf: function setPrototypeOf(target, proto) {
					setProto.check(target, proto);
					try {
						setProto.set(target, proto);
						return true;
					} catch (e) {
						return false;
					}
				}
			});

			/***/
		},
		/* 225 */
		/***/function (module, exports, __webpack_require__) {

			// 20.3.3.1 / 15.9.4.4 Date.now()
			var $export = __webpack_require__(6);

			$export($export.S, 'Date', { now: function () {
					return new Date().getTime();
				} });

			/***/
		},
		/* 226 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    toObject = __webpack_require__(56),
			    toPrimitive = __webpack_require__(14);

			$export($export.P + $export.F * __webpack_require__(5)(function () {
				return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function () {
						return 1;
					} }) !== 1;
			}), 'Date', {
				toJSON: function toJSON(key) {
					var O = toObject(this),
					    pv = toPrimitive(O);
					return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
				}
			});

			/***/
		},
		/* 227 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

			var $export = __webpack_require__(6),
			    fails = __webpack_require__(5),
			    getTime = Date.prototype.getTime;

			var lz = function (num) {
				return num > 9 ? num : '0' + num;
			};

			// PhantomJS / old WebKit has a broken implementations
			$export($export.P + $export.F * (fails(function () {
				return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
			}) || !fails(function () {
				new Date(NaN).toISOString();
			})), 'Date', {
				toISOString: function toISOString() {
					if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
					var d = this,
					    y = d.getUTCFullYear(),
					    m = d.getUTCMilliseconds(),
					    s = y < 0 ? '-' : y > 9999 ? '+' : '';
					return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
				}
			});

			/***/
		},
		/* 228 */
		/***/function (module, exports, __webpack_require__) {

			var DateProto = Date.prototype,
			    INVALID_DATE = 'Invalid Date',
			    TO_STRING = 'toString',
			    $toString = DateProto[TO_STRING],
			    getTime = DateProto.getTime;
			if (new Date(NaN) + '' != INVALID_DATE) {
				__webpack_require__(16)(DateProto, TO_STRING, function toString() {
					var value = getTime.call(this);
					return value === value ? $toString.call(this) : INVALID_DATE;
				});
			}

			/***/
		},
		/* 229 */
		/***/function (module, exports, __webpack_require__) {

			var TO_PRIMITIVE = __webpack_require__(23)('toPrimitive'),
			    proto = Date.prototype;

			if (!(TO_PRIMITIVE in proto)) __webpack_require__(8)(proto, TO_PRIMITIVE, __webpack_require__(230));

			/***/
		},
		/* 230 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var anObject = __webpack_require__(10),
			    toPrimitive = __webpack_require__(14),
			    NUMBER = 'number';

			module.exports = function (hint) {
				if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
				return toPrimitive(anObject(this), hint != NUMBER);
			};

			/***/
		},
		/* 231 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    $typed = __webpack_require__(232),
			    buffer = __webpack_require__(233),
			    anObject = __webpack_require__(10),
			    toIndex = __webpack_require__(37),
			    toLength = __webpack_require__(35),
			    isObject = __webpack_require__(11),
			    ArrayBuffer = __webpack_require__(2).ArrayBuffer,
			    speciesConstructor = __webpack_require__(199),
			    $ArrayBuffer = buffer.ArrayBuffer,
			    $DataView = buffer.DataView,
			    $isView = $typed.ABV && ArrayBuffer.isView,
			    $slice = $ArrayBuffer.prototype.slice,
			    VIEW = $typed.VIEW,
			    ARRAY_BUFFER = 'ArrayBuffer';

			$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

			$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
				// 24.1.3.1 ArrayBuffer.isView(arg)
				isView: function isView(it) {
					return $isView && $isView(it) || isObject(it) && VIEW in it;
				}
			});

			$export($export.P + $export.U + $export.F * __webpack_require__(5)(function () {
				return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
			}), ARRAY_BUFFER, {
				// 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
				slice: function slice(start, end) {
					if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
					var len = anObject(this).byteLength,
					    first = toIndex(start, len),
					    final = toIndex(end === undefined ? len : end, len),
					    result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first)),
					    viewS = new $DataView(this),
					    viewT = new $DataView(result),
					    index = 0;
					while (first < final) {
						viewT.setUint8(index++, viewS.getUint8(first++));
					}return result;
				}
			});

			__webpack_require__(186)(ARRAY_BUFFER);

			/***/
		},
		/* 232 */
		/***/function (module, exports, __webpack_require__) {

			var global = __webpack_require__(2),
			    hide = __webpack_require__(8),
			    uid = __webpack_require__(17),
			    TYPED = uid('typed_array'),
			    VIEW = uid('view'),
			    ABV = !!(global.ArrayBuffer && global.DataView),
			    CONSTR = ABV,
			    i = 0,
			    l = 9,
			    Typed;

			var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

			while (i < l) {
				if (Typed = global[TypedArrayConstructors[i++]]) {
					hide(Typed.prototype, TYPED, true);
					hide(Typed.prototype, VIEW, true);
				} else CONSTR = false;
			}

			module.exports = {
				ABV: ABV,
				CONSTR: CONSTR,
				TYPED: TYPED,
				VIEW: VIEW
			};

			/***/
		},
		/* 233 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var global = __webpack_require__(2),
			    DESCRIPTORS = __webpack_require__(4),
			    LIBRARY = __webpack_require__(26),
			    $typed = __webpack_require__(232),
			    hide = __webpack_require__(8),
			    redefineAll = __webpack_require__(202),
			    fails = __webpack_require__(5),
			    anInstance = __webpack_require__(197),
			    toInteger = __webpack_require__(36),
			    toLength = __webpack_require__(35),
			    gOPN = __webpack_require__(48).f,
			    dP = __webpack_require__(9).f,
			    arrayFill = __webpack_require__(180),
			    setToStringTag = __webpack_require__(22),
			    ARRAY_BUFFER = 'ArrayBuffer',
			    DATA_VIEW = 'DataView',
			    PROTOTYPE = 'prototype',
			    WRONG_LENGTH = 'Wrong length!',
			    WRONG_INDEX = 'Wrong index!',
			    $ArrayBuffer = global[ARRAY_BUFFER],
			    $DataView = global[DATA_VIEW],
			    Math = global.Math,
			    RangeError = global.RangeError,
			    Infinity = global.Infinity,
			    BaseBuffer = $ArrayBuffer,
			    abs = Math.abs,
			    pow = Math.pow,
			    floor = Math.floor,
			    log = Math.log,
			    LN2 = Math.LN2,
			    BUFFER = 'buffer',
			    BYTE_LENGTH = 'byteLength',
			    BYTE_OFFSET = 'byteOffset',
			    $BUFFER = DESCRIPTORS ? '_b' : BUFFER,
			    $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH,
			    $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

			// IEEE754 conversions based on https://github.com/feross/ieee754
			var packIEEE754 = function (value, mLen, nBytes) {
				var buffer = Array(nBytes),
				    eLen = nBytes * 8 - mLen - 1,
				    eMax = (1 << eLen) - 1,
				    eBias = eMax >> 1,
				    rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0,
				    i = 0,
				    s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0,
				    e,
				    m,
				    c;
				value = abs(value);
				if (value != value || value === Infinity) {
					m = value != value ? 1 : 0;
					e = eMax;
				} else {
					e = floor(log(value) / LN2);
					if (value * (c = pow(2, -e)) < 1) {
						e--;
						c *= 2;
					}
					if (e + eBias >= 1) {
						value += rt / c;
					} else {
						value += rt * pow(2, 1 - eBias);
					}
					if (value * c >= 2) {
						e++;
						c /= 2;
					}
					if (e + eBias >= eMax) {
						m = 0;
						e = eMax;
					} else if (e + eBias >= 1) {
						m = (value * c - 1) * pow(2, mLen);
						e = e + eBias;
					} else {
						m = value * pow(2, eBias - 1) * pow(2, mLen);
						e = 0;
					}
				}
				for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
				e = e << mLen | m;
				eLen += mLen;
				for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
				buffer[--i] |= s * 128;
				return buffer;
			};
			var unpackIEEE754 = function (buffer, mLen, nBytes) {
				var eLen = nBytes * 8 - mLen - 1,
				    eMax = (1 << eLen) - 1,
				    eBias = eMax >> 1,
				    nBits = eLen - 7,
				    i = nBytes - 1,
				    s = buffer[i--],
				    e = s & 127,
				    m;
				s >>= 7;
				for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
				m = e & (1 << -nBits) - 1;
				e >>= -nBits;
				nBits += mLen;
				for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
				if (e === 0) {
					e = 1 - eBias;
				} else if (e === eMax) {
					return m ? NaN : s ? -Infinity : Infinity;
				} else {
					m = m + pow(2, mLen);
					e = e - eBias;
				}return (s ? -1 : 1) * m * pow(2, e - mLen);
			};

			var unpackI32 = function (bytes) {
				return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
			};
			var packI8 = function (it) {
				return [it & 0xff];
			};
			var packI16 = function (it) {
				return [it & 0xff, it >> 8 & 0xff];
			};
			var packI32 = function (it) {
				return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
			};
			var packF64 = function (it) {
				return packIEEE754(it, 52, 8);
			};
			var packF32 = function (it) {
				return packIEEE754(it, 23, 4);
			};

			var addGetter = function (C, key, internal) {
				dP(C[PROTOTYPE], key, { get: function () {
						return this[internal];
					} });
			};

			var get = function (view, bytes, index, isLittleEndian) {
				var numIndex = +index,
				    intIndex = toInteger(numIndex);
				if (numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
				var store = view[$BUFFER]._b,
				    start = intIndex + view[$OFFSET],
				    pack = store.slice(start, start + bytes);
				return isLittleEndian ? pack : pack.reverse();
			};
			var set = function (view, bytes, index, conversion, value, isLittleEndian) {
				var numIndex = +index,
				    intIndex = toInteger(numIndex);
				if (numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
				var store = view[$BUFFER]._b,
				    start = intIndex + view[$OFFSET],
				    pack = conversion(+value);
				for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
			};

			var validateArrayBufferArguments = function (that, length) {
				anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
				var numberLength = +length,
				    byteLength = toLength(numberLength);
				if (numberLength != byteLength) throw RangeError(WRONG_LENGTH);
				return byteLength;
			};

			if (!$typed.ABV) {
				$ArrayBuffer = function ArrayBuffer(length) {
					var byteLength = validateArrayBufferArguments(this, length);
					this._b = arrayFill.call(Array(byteLength), 0);
					this[$LENGTH] = byteLength;
				};

				$DataView = function DataView(buffer, byteOffset, byteLength) {
					anInstance(this, $DataView, DATA_VIEW);
					anInstance(buffer, $ArrayBuffer, DATA_VIEW);
					var bufferLength = buffer[$LENGTH],
					    offset = toInteger(byteOffset);
					if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
					byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
					if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
					this[$BUFFER] = buffer;
					this[$OFFSET] = offset;
					this[$LENGTH] = byteLength;
				};

				if (DESCRIPTORS) {
					addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
					addGetter($DataView, BUFFER, '_b');
					addGetter($DataView, BYTE_LENGTH, '_l');
					addGetter($DataView, BYTE_OFFSET, '_o');
				}

				redefineAll($DataView[PROTOTYPE], {
					getInt8: function getInt8(byteOffset) {
						return get(this, 1, byteOffset)[0] << 24 >> 24;
					},
					getUint8: function getUint8(byteOffset) {
						return get(this, 1, byteOffset)[0];
					},
					getInt16: function getInt16(byteOffset /*, littleEndian */) {
						var bytes = get(this, 2, byteOffset, arguments[1]);
						return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
					},
					getUint16: function getUint16(byteOffset /*, littleEndian */) {
						var bytes = get(this, 2, byteOffset, arguments[1]);
						return bytes[1] << 8 | bytes[0];
					},
					getInt32: function getInt32(byteOffset /*, littleEndian */) {
						return unpackI32(get(this, 4, byteOffset, arguments[1]));
					},
					getUint32: function getUint32(byteOffset /*, littleEndian */) {
						return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
					},
					getFloat32: function getFloat32(byteOffset /*, littleEndian */) {
						return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
					},
					getFloat64: function getFloat64(byteOffset /*, littleEndian */) {
						return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
					},
					setInt8: function setInt8(byteOffset, value) {
						set(this, 1, byteOffset, packI8, value);
					},
					setUint8: function setUint8(byteOffset, value) {
						set(this, 1, byteOffset, packI8, value);
					},
					setInt16: function setInt16(byteOffset, value /*, littleEndian */) {
						set(this, 2, byteOffset, packI16, value, arguments[2]);
					},
					setUint16: function setUint16(byteOffset, value /*, littleEndian */) {
						set(this, 2, byteOffset, packI16, value, arguments[2]);
					},
					setInt32: function setInt32(byteOffset, value /*, littleEndian */) {
						set(this, 4, byteOffset, packI32, value, arguments[2]);
					},
					setUint32: function setUint32(byteOffset, value /*, littleEndian */) {
						set(this, 4, byteOffset, packI32, value, arguments[2]);
					},
					setFloat32: function setFloat32(byteOffset, value /*, littleEndian */) {
						set(this, 4, byteOffset, packF32, value, arguments[2]);
					},
					setFloat64: function setFloat64(byteOffset, value /*, littleEndian */) {
						set(this, 8, byteOffset, packF64, value, arguments[2]);
					}
				});
			} else {
				if (!fails(function () {
					new $ArrayBuffer(); // eslint-disable-line no-new
				}) || !fails(function () {
					new $ArrayBuffer(.5); // eslint-disable-line no-new
				})) {
					$ArrayBuffer = function ArrayBuffer(length) {
						return new BaseBuffer(validateArrayBufferArguments(this, length));
					};
					var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
					for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
						if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
					};
					if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
				}
				// iOS Safari 7.x bug
				var view = new $DataView(new $ArrayBuffer(2)),
				    $setInt8 = $DataView[PROTOTYPE].setInt8;
				view.setInt8(0, 2147483648);
				view.setInt8(1, 2147483649);
				if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
					setInt8: function setInt8(byteOffset, value) {
						$setInt8.call(this, byteOffset, value << 24 >> 24);
					},
					setUint8: function setUint8(byteOffset, value) {
						$setInt8.call(this, byteOffset, value << 24 >> 24);
					}
				}, true);
			}
			setToStringTag($ArrayBuffer, ARRAY_BUFFER);
			setToStringTag($DataView, DATA_VIEW);
			hide($DataView[PROTOTYPE], $typed.VIEW, true);
			exports[ARRAY_BUFFER] = $ArrayBuffer;
			exports[DATA_VIEW] = $DataView;

			/***/
		},
		/* 234 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6);
			$export($export.G + $export.W + $export.F * !__webpack_require__(232).ABV, {
				DataView: __webpack_require__(233).DataView
			});

			/***/
		},
		/* 235 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(236)('Int8', 1, function (init) {
				return function Int8Array(data, byteOffset, length) {
					return init(this, data, byteOffset, length);
				};
			});

			/***/
		},
		/* 236 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			if (__webpack_require__(4)) {
				var LIBRARY = __webpack_require__(26),
				    global = __webpack_require__(2),
				    fails = __webpack_require__(5),
				    $export = __webpack_require__(6),
				    $typed = __webpack_require__(232),
				    $buffer = __webpack_require__(233),
				    ctx = __webpack_require__(18),
				    anInstance = __webpack_require__(197),
				    propertyDesc = __webpack_require__(15),
				    hide = __webpack_require__(8),
				    redefineAll = __webpack_require__(202),
				    toInteger = __webpack_require__(36),
				    toLength = __webpack_require__(35),
				    toIndex = __webpack_require__(37),
				    toPrimitive = __webpack_require__(14),
				    has = __webpack_require__(3),
				    same = __webpack_require__(69),
				    classof = __webpack_require__(73),
				    isObject = __webpack_require__(11),
				    toObject = __webpack_require__(56),
				    isArrayIter = __webpack_require__(154),
				    create = __webpack_require__(44),
				    getPrototypeOf = __webpack_require__(57),
				    gOPN = __webpack_require__(48).f,
				    getIterFn = __webpack_require__(156),
				    uid = __webpack_require__(17),
				    wks = __webpack_require__(23),
				    createArrayMethod = __webpack_require__(164),
				    createArrayIncludes = __webpack_require__(34),
				    speciesConstructor = __webpack_require__(199),
				    ArrayIterators = __webpack_require__(183),
				    Iterators = __webpack_require__(135),
				    $iterDetect = __webpack_require__(157),
				    setSpecies = __webpack_require__(186),
				    arrayFill = __webpack_require__(180),
				    arrayCopyWithin = __webpack_require__(177),
				    $DP = __webpack_require__(9),
				    $GOPD = __webpack_require__(49),
				    dP = $DP.f,
				    gOPD = $GOPD.f,
				    RangeError = global.RangeError,
				    TypeError = global.TypeError,
				    Uint8Array = global.Uint8Array,
				    ARRAY_BUFFER = 'ArrayBuffer',
				    SHARED_BUFFER = 'Shared' + ARRAY_BUFFER,
				    BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT',
				    PROTOTYPE = 'prototype',
				    ArrayProto = Array[PROTOTYPE],
				    $ArrayBuffer = $buffer.ArrayBuffer,
				    $DataView = $buffer.DataView,
				    arrayForEach = createArrayMethod(0),
				    arrayFilter = createArrayMethod(2),
				    arraySome = createArrayMethod(3),
				    arrayEvery = createArrayMethod(4),
				    arrayFind = createArrayMethod(5),
				    arrayFindIndex = createArrayMethod(6),
				    arrayIncludes = createArrayIncludes(true),
				    arrayIndexOf = createArrayIncludes(false),
				    arrayValues = ArrayIterators.values,
				    arrayKeys = ArrayIterators.keys,
				    arrayEntries = ArrayIterators.entries,
				    arrayLastIndexOf = ArrayProto.lastIndexOf,
				    arrayReduce = ArrayProto.reduce,
				    arrayReduceRight = ArrayProto.reduceRight,
				    arrayJoin = ArrayProto.join,
				    arraySort = ArrayProto.sort,
				    arraySlice = ArrayProto.slice,
				    arrayToString = ArrayProto.toString,
				    arrayToLocaleString = ArrayProto.toLocaleString,
				    ITERATOR = wks('iterator'),
				    TAG = wks('toStringTag'),
				    TYPED_CONSTRUCTOR = uid('typed_constructor'),
				    DEF_CONSTRUCTOR = uid('def_constructor'),
				    ALL_CONSTRUCTORS = $typed.CONSTR,
				    TYPED_ARRAY = $typed.TYPED,
				    VIEW = $typed.VIEW,
				    WRONG_LENGTH = 'Wrong length!';

				var $map = createArrayMethod(1, function (O, length) {
					return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
				});

				var LITTLE_ENDIAN = fails(function () {
					return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
				});

				var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
					new Uint8Array(1).set({});
				});

				var strictToLength = function (it, SAME) {
					if (it === undefined) throw TypeError(WRONG_LENGTH);
					var number = +it,
					    length = toLength(it);
					if (SAME && !same(number, length)) throw RangeError(WRONG_LENGTH);
					return length;
				};

				var toOffset = function (it, BYTES) {
					var offset = toInteger(it);
					if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
					return offset;
				};

				var validate = function (it) {
					if (isObject(it) && TYPED_ARRAY in it) return it;
					throw TypeError(it + ' is not a typed array!');
				};

				var allocate = function (C, length) {
					if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
						throw TypeError('It is not a typed array constructor!');
					}return new C(length);
				};

				var speciesFromList = function (O, list) {
					return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
				};

				var fromList = function (C, list) {
					var index = 0,
					    length = list.length,
					    result = allocate(C, length);
					while (length > index) result[index] = list[index++];
					return result;
				};

				var addGetter = function (it, key, internal) {
					dP(it, key, { get: function () {
							return this._d[internal];
						} });
				};

				var $from = function from(source /*, mapfn, thisArg */) {
					var O = toObject(source),
					    aLen = arguments.length,
					    mapfn = aLen > 1 ? arguments[1] : undefined,
					    mapping = mapfn !== undefined,
					    iterFn = getIterFn(O),
					    i,
					    length,
					    values,
					    result,
					    step,
					    iterator;
					if (iterFn != undefined && !isArrayIter(iterFn)) {
						for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
							values.push(step.value);
						}O = values;
					}
					if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
					for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
						result[i] = mapping ? mapfn(O[i], i) : O[i];
					}
					return result;
				};

				var $of = function of() /*...items*/{
					var index = 0,
					    length = arguments.length,
					    result = allocate(this, length);
					while (length > index) result[index] = arguments[index++];
					return result;
				};

				// iOS Safari 6.x fails here
				var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
					arrayToLocaleString.call(new Uint8Array(1));
				});

				var $toLocaleString = function toLocaleString() {
					return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
				};

				var proto = {
					copyWithin: function copyWithin(target, start /*, end */) {
						return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
					},
					every: function every(callbackfn /*, thisArg */) {
						return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
					},
					fill: function fill(value /*, start, end */) {
						// eslint-disable-line no-unused-vars
						return arrayFill.apply(validate(this), arguments);
					},
					filter: function filter(callbackfn /*, thisArg */) {
						return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
					},
					find: function find(predicate /*, thisArg */) {
						return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
					},
					findIndex: function findIndex(predicate /*, thisArg */) {
						return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
					},
					forEach: function forEach(callbackfn /*, thisArg */) {
						arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
					},
					indexOf: function indexOf(searchElement /*, fromIndex */) {
						return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
					},
					includes: function includes(searchElement /*, fromIndex */) {
						return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
					},
					join: function join(separator) {
						// eslint-disable-line no-unused-vars
						return arrayJoin.apply(validate(this), arguments);
					},
					lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */) {
						// eslint-disable-line no-unused-vars
						return arrayLastIndexOf.apply(validate(this), arguments);
					},
					map: function map(mapfn /*, thisArg */) {
						return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
					},
					reduce: function reduce(callbackfn /*, initialValue */) {
						// eslint-disable-line no-unused-vars
						return arrayReduce.apply(validate(this), arguments);
					},
					reduceRight: function reduceRight(callbackfn /*, initialValue */) {
						// eslint-disable-line no-unused-vars
						return arrayReduceRight.apply(validate(this), arguments);
					},
					reverse: function reverse() {
						var that = this,
						    length = validate(that).length,
						    middle = Math.floor(length / 2),
						    index = 0,
						    value;
						while (index < middle) {
							value = that[index];
							that[index++] = that[--length];
							that[length] = value;
						}return that;
					},
					some: function some(callbackfn /*, thisArg */) {
						return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
					},
					sort: function sort(comparefn) {
						return arraySort.call(validate(this), comparefn);
					},
					subarray: function subarray(begin, end) {
						var O = validate(this),
						    length = O.length,
						    $begin = toIndex(begin, length);
						return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toIndex(end, length)) - $begin));
					}
				};

				var $slice = function slice(start, end) {
					return speciesFromList(this, arraySlice.call(validate(this), start, end));
				};

				var $set = function set(arrayLike /*, offset */) {
					validate(this);
					var offset = toOffset(arguments[1], 1),
					    length = this.length,
					    src = toObject(arrayLike),
					    len = toLength(src.length),
					    index = 0;
					if (len + offset > length) throw RangeError(WRONG_LENGTH);
					while (index < len) this[offset + index] = src[index++];
				};

				var $iterators = {
					entries: function entries() {
						return arrayEntries.call(validate(this));
					},
					keys: function keys() {
						return arrayKeys.call(validate(this));
					},
					values: function values() {
						return arrayValues.call(validate(this));
					}
				};

				var isTAIndex = function (target, key) {
					return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
				};
				var $getDesc = function getOwnPropertyDescriptor(target, key) {
					return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
				};
				var $setDesc = function defineProperty(target, key, desc) {
					if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set')
					// TODO: add validation descriptor w/o calling accessors
					&& !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
						target[key] = desc.value;
						return target;
					} else return dP(target, key, desc);
				};

				if (!ALL_CONSTRUCTORS) {
					$GOPD.f = $getDesc;
					$DP.f = $setDesc;
				}

				$export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
					getOwnPropertyDescriptor: $getDesc,
					defineProperty: $setDesc
				});

				if (fails(function () {
					arrayToString.call({});
				})) {
					arrayToString = arrayToLocaleString = function toString() {
						return arrayJoin.call(this);
					};
				}

				var $TypedArrayPrototype$ = redefineAll({}, proto);
				redefineAll($TypedArrayPrototype$, $iterators);
				hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
				redefineAll($TypedArrayPrototype$, {
					slice: $slice,
					set: $set,
					constructor: function () {/* noop */},
					toString: arrayToString,
					toLocaleString: $toLocaleString
				});
				addGetter($TypedArrayPrototype$, 'buffer', 'b');
				addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
				addGetter($TypedArrayPrototype$, 'byteLength', 'l');
				addGetter($TypedArrayPrototype$, 'length', 'e');
				dP($TypedArrayPrototype$, TAG, {
					get: function () {
						return this[TYPED_ARRAY];
					}
				});

				module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
					CLAMPED = !!CLAMPED;
					var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array',
					    ISNT_UINT8 = NAME != 'Uint8Array',
					    GETTER = 'get' + KEY,
					    SETTER = 'set' + KEY,
					    TypedArray = global[NAME],
					    Base = TypedArray || {},
					    TAC = TypedArray && getPrototypeOf(TypedArray),
					    FORCED = !TypedArray || !$typed.ABV,
					    O = {},
					    TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
					var getter = function (that, index) {
						var data = that._d;
						return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
					};
					var setter = function (that, index, value) {
						var data = that._d;
						if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
						data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
					};
					var addElement = function (that, index) {
						dP(that, index, {
							get: function () {
								return getter(this, index);
							},
							set: function (value) {
								return setter(this, index, value);
							},
							enumerable: true
						});
					};
					if (FORCED) {
						TypedArray = wrapper(function (that, data, $offset, $length) {
							anInstance(that, TypedArray, NAME, '_d');
							var index = 0,
							    offset = 0,
							    buffer,
							    byteLength,
							    length,
							    klass;
							if (!isObject(data)) {
								length = strictToLength(data, true);
								byteLength = length * BYTES;
								buffer = new $ArrayBuffer(byteLength);
							} else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
								buffer = data;
								offset = toOffset($offset, BYTES);
								var $len = data.byteLength;
								if ($length === undefined) {
									if ($len % BYTES) throw RangeError(WRONG_LENGTH);
									byteLength = $len - offset;
									if (byteLength < 0) throw RangeError(WRONG_LENGTH);
								} else {
									byteLength = toLength($length) * BYTES;
									if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
								}
								length = byteLength / BYTES;
							} else if (TYPED_ARRAY in data) {
								return fromList(TypedArray, data);
							} else {
								return $from.call(TypedArray, data);
							}
							hide(that, '_d', {
								b: buffer,
								o: offset,
								l: byteLength,
								e: length,
								v: new $DataView(buffer)
							});
							while (index < length) addElement(that, index++);
						});
						TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
						hide(TypedArrayPrototype, 'constructor', TypedArray);
					} else if (!$iterDetect(function (iter) {
						// V8 works with iterators, but fails in many other cases
						// https://code.google.com/p/v8/issues/detail?id=4552
						new TypedArray(null); // eslint-disable-line no-new
						new TypedArray(iter); // eslint-disable-line no-new
					}, true)) {
						TypedArray = wrapper(function (that, data, $offset, $length) {
							anInstance(that, TypedArray, NAME);
							var klass;
							// `ws` module bug, temporarily remove validation length for Uint8Array
							// https://github.com/websockets/ws/pull/645
							if (!isObject(data)) return new Base(strictToLength(data, ISNT_UINT8));
							if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
								return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
							}
							if (TYPED_ARRAY in data) return fromList(TypedArray, data);
							return $from.call(TypedArray, data);
						});
						arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
							if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
						});
						TypedArray[PROTOTYPE] = TypedArrayPrototype;
						if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
					}
					var $nativeIterator = TypedArrayPrototype[ITERATOR],
					    CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined),
					    $iterator = $iterators.values;
					hide(TypedArray, TYPED_CONSTRUCTOR, true);
					hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
					hide(TypedArrayPrototype, VIEW, true);
					hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

					if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
						dP(TypedArrayPrototype, TAG, {
							get: function () {
								return NAME;
							}
						});
					}

					O[NAME] = TypedArray;

					$export($export.G + $export.W + $export.F * (TypedArray != Base), O);

					$export($export.S, NAME, {
						BYTES_PER_ELEMENT: BYTES,
						from: $from,
						of: $of
					});

					if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

					$export($export.P, NAME, proto);

					setSpecies(NAME);

					$export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

					$export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

					$export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, { toString: arrayToString });

					$export($export.P + $export.F * fails(function () {
						new TypedArray(1).slice();
					}), NAME, { slice: $slice });

					$export($export.P + $export.F * (fails(function () {
						return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
					}) || !fails(function () {
						TypedArrayPrototype.toLocaleString.call([1, 2]);
					})), NAME, { toLocaleString: $toLocaleString });

					Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
					if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
				};
			} else module.exports = function () {/* empty */};

			/***/
		},
		/* 237 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(236)('Uint8', 1, function (init) {
				return function Uint8Array(data, byteOffset, length) {
					return init(this, data, byteOffset, length);
				};
			});

			/***/
		},
		/* 238 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(236)('Uint8', 1, function (init) {
				return function Uint8ClampedArray(data, byteOffset, length) {
					return init(this, data, byteOffset, length);
				};
			}, true);

			/***/
		},
		/* 239 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(236)('Int16', 2, function (init) {
				return function Int16Array(data, byteOffset, length) {
					return init(this, data, byteOffset, length);
				};
			});

			/***/
		},
		/* 240 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(236)('Uint16', 2, function (init) {
				return function Uint16Array(data, byteOffset, length) {
					return init(this, data, byteOffset, length);
				};
			});

			/***/
		},
		/* 241 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(236)('Int32', 4, function (init) {
				return function Int32Array(data, byteOffset, length) {
					return init(this, data, byteOffset, length);
				};
			});

			/***/
		},
		/* 242 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(236)('Uint32', 4, function (init) {
				return function Uint32Array(data, byteOffset, length) {
					return init(this, data, byteOffset, length);
				};
			});

			/***/
		},
		/* 243 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(236)('Float32', 4, function (init) {
				return function Float32Array(data, byteOffset, length) {
					return init(this, data, byteOffset, length);
				};
			});

			/***/
		},
		/* 244 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(236)('Float64', 8, function (init) {
				return function Float64Array(data, byteOffset, length) {
					return init(this, data, byteOffset, length);
				};
			});

			/***/
		},
		/* 245 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// https://github.com/tc39/Array.prototype.includes

			var $export = __webpack_require__(6),
			    $includes = __webpack_require__(34)(true);

			$export($export.P, 'Array', {
				includes: function includes(el /*, fromIndex = 0 */) {
					return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
				}
			});

			__webpack_require__(178)('includes');

			/***/
		},
		/* 246 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// https://github.com/mathiasbynens/String.prototype.at

			var $export = __webpack_require__(6),
			    $at = __webpack_require__(125)(true);

			$export($export.P, 'String', {
				at: function at(pos) {
					return $at(this, pos);
				}
			});

			/***/
		},
		/* 247 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// https://github.com/tc39/proposal-string-pad-start-end

			var $export = __webpack_require__(6),
			    $pad = __webpack_require__(248);

			$export($export.P, 'String', {
				padStart: function padStart(maxLength /*, fillString = ' ' */) {
					return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
				}
			});

			/***/
		},
		/* 248 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/tc39/proposal-string-pad-start-end
			var toLength = __webpack_require__(35),
			    repeat = __webpack_require__(85),
			    defined = __webpack_require__(33);

			module.exports = function (that, maxLength, fillString, left) {
				var S = String(defined(that)),
				    stringLength = S.length,
				    fillStr = fillString === undefined ? ' ' : String(fillString),
				    intMaxLength = toLength(maxLength);
				if (intMaxLength <= stringLength || fillStr == '') return S;
				var fillLen = intMaxLength - stringLength,
				    stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
				if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
				return left ? stringFiller + S : S + stringFiller;
			};

			/***/
		},
		/* 249 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// https://github.com/tc39/proposal-string-pad-start-end

			var $export = __webpack_require__(6),
			    $pad = __webpack_require__(248);

			$export($export.P, 'String', {
				padEnd: function padEnd(maxLength /*, fillString = ' ' */) {
					return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
				}
			});

			/***/
		},
		/* 250 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// https://github.com/sebmarkbage/ecmascript-string-left-right-trim

			__webpack_require__(81)('trimLeft', function ($trim) {
				return function trimLeft() {
					return $trim(this, 1);
				};
			}, 'trimStart');

			/***/
		},
		/* 251 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// https://github.com/sebmarkbage/ecmascript-string-left-right-trim

			__webpack_require__(81)('trimRight', function ($trim) {
				return function trimRight() {
					return $trim(this, 2);
				};
			}, 'trimEnd');

			/***/
		},
		/* 252 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// https://tc39.github.io/String.prototype.matchAll/

			var $export = __webpack_require__(6),
			    defined = __webpack_require__(33),
			    toLength = __webpack_require__(35),
			    isRegExp = __webpack_require__(128),
			    getFlags = __webpack_require__(188),
			    RegExpProto = RegExp.prototype;

			var $RegExpStringIterator = function (regexp, string) {
				this._r = regexp;
				this._s = string;
			};

			__webpack_require__(136)($RegExpStringIterator, 'RegExp String', function next() {
				var match = this._r.exec(this._s);
				return { value: match, done: match === null };
			});

			$export($export.P, 'String', {
				matchAll: function matchAll(regexp) {
					defined(this);
					if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
					var S = String(this),
					    flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp),
					    rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
					rx.lastIndex = toLength(regexp.lastIndex);
					return new $RegExpStringIterator(rx, S);
				}
			});

			/***/
		},
		/* 253 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(25)('asyncIterator');

			/***/
		},
		/* 254 */
		/***/function (module, exports, __webpack_require__) {

			__webpack_require__(25)('observable');

			/***/
		},
		/* 255 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/tc39/proposal-object-getownpropertydescriptors
			var $export = __webpack_require__(6),
			    ownKeys = __webpack_require__(221),
			    toIObject = __webpack_require__(30),
			    gOPD = __webpack_require__(49),
			    createProperty = __webpack_require__(155);

			$export($export.S, 'Object', {
				getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
					var O = toIObject(object),
					    getDesc = gOPD.f,
					    keys = ownKeys(O),
					    result = {},
					    i = 0,
					    key;
					while (keys.length > i) createProperty(result, key = keys[i++], getDesc(O, key));
					return result;
				}
			});

			/***/
		},
		/* 256 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/tc39/proposal-object-values-entries
			var $export = __webpack_require__(6),
			    $values = __webpack_require__(257)(false);

			$export($export.S, 'Object', {
				values: function values(it) {
					return $values(it);
				}
			});

			/***/
		},
		/* 257 */
		/***/function (module, exports, __webpack_require__) {

			var getKeys = __webpack_require__(28),
			    toIObject = __webpack_require__(30),
			    isEnum = __webpack_require__(42).f;
			module.exports = function (isEntries) {
				return function (it) {
					var O = toIObject(it),
					    keys = getKeys(O),
					    length = keys.length,
					    i = 0,
					    result = [],
					    key;
					while (length > i) if (isEnum.call(O, key = keys[i++])) {
						result.push(isEntries ? [key, O[key]] : O[key]);
					}return result;
				};
			};

			/***/
		},
		/* 258 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/tc39/proposal-object-values-entries
			var $export = __webpack_require__(6),
			    $entries = __webpack_require__(257)(true);

			$export($export.S, 'Object', {
				entries: function entries(it) {
					return $entries(it);
				}
			});

			/***/
		},
		/* 259 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    toObject = __webpack_require__(56),
			    aFunction = __webpack_require__(19),
			    $defineProperty = __webpack_require__(9);

			// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
			__webpack_require__(4) && $export($export.P + __webpack_require__(260), 'Object', {
				__defineGetter__: function __defineGetter__(P, getter) {
					$defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
				}
			});

			/***/
		},
		/* 260 */
		/***/function (module, exports, __webpack_require__) {

			// Forced replacement prototype accessors methods
			module.exports = __webpack_require__(26) || !__webpack_require__(5)(function () {
				var K = Math.random();
				// In FF throws only define methods
				__defineSetter__.call(null, K, function () {/* empty */});
				delete __webpack_require__(2)[K];
			});

			/***/
		},
		/* 261 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    toObject = __webpack_require__(56),
			    aFunction = __webpack_require__(19),
			    $defineProperty = __webpack_require__(9);

			// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
			__webpack_require__(4) && $export($export.P + __webpack_require__(260), 'Object', {
				__defineSetter__: function __defineSetter__(P, setter) {
					$defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
				}
			});

			/***/
		},
		/* 262 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    toObject = __webpack_require__(56),
			    toPrimitive = __webpack_require__(14),
			    getPrototypeOf = __webpack_require__(57),
			    getOwnPropertyDescriptor = __webpack_require__(49).f;

			// B.2.2.4 Object.prototype.__lookupGetter__(P)
			__webpack_require__(4) && $export($export.P + __webpack_require__(260), 'Object', {
				__lookupGetter__: function __lookupGetter__(P) {
					var O = toObject(this),
					    K = toPrimitive(P, true),
					    D;
					do {
						if (D = getOwnPropertyDescriptor(O, K)) return D.get;
					} while (O = getPrototypeOf(O));
				}
			});

			/***/
		},
		/* 263 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6),
			    toObject = __webpack_require__(56),
			    toPrimitive = __webpack_require__(14),
			    getPrototypeOf = __webpack_require__(57),
			    getOwnPropertyDescriptor = __webpack_require__(49).f;

			// B.2.2.5 Object.prototype.__lookupSetter__(P)
			__webpack_require__(4) && $export($export.P + __webpack_require__(260), 'Object', {
				__lookupSetter__: function __lookupSetter__(P) {
					var O = toObject(this),
					    K = toPrimitive(P, true),
					    D;
					do {
						if (D = getOwnPropertyDescriptor(O, K)) return D.set;
					} while (O = getPrototypeOf(O));
				}
			});

			/***/
		},
		/* 264 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/DavidBruant/Map-Set.prototype.toJSON
			var $export = __webpack_require__(6);

			$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(265)('Map') });

			/***/
		},
		/* 265 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/DavidBruant/Map-Set.prototype.toJSON
			var classof = __webpack_require__(73),
			    from = __webpack_require__(266);
			module.exports = function (NAME) {
				return function toJSON() {
					if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
					return from(this);
				};
			};

			/***/
		},
		/* 266 */
		/***/function (module, exports, __webpack_require__) {

			var forOf = __webpack_require__(198);

			module.exports = function (iter, ITERATOR) {
				var result = [];
				forOf(iter, false, result.push, result, ITERATOR);
				return result;
			};

			/***/
		},
		/* 267 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/DavidBruant/Map-Set.prototype.toJSON
			var $export = __webpack_require__(6);

			$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(265)('Set') });

			/***/
		},
		/* 268 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/ljharb/proposal-global
			var $export = __webpack_require__(6);

			$export($export.S, 'System', { global: __webpack_require__(2) });

			/***/
		},
		/* 269 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/ljharb/proposal-is-error
			var $export = __webpack_require__(6),
			    cof = __webpack_require__(32);

			$export($export.S, 'Error', {
				isError: function isError(it) {
					return cof(it) === 'Error';
				}
			});

			/***/
		},
		/* 270 */
		/***/function (module, exports, __webpack_require__) {

			// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', {
				iaddh: function iaddh(x0, x1, y0, y1) {
					var $x0 = x0 >>> 0,
					    $x1 = x1 >>> 0,
					    $y0 = y0 >>> 0;
					return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
				}
			});

			/***/
		},
		/* 271 */
		/***/function (module, exports, __webpack_require__) {

			// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', {
				isubh: function isubh(x0, x1, y0, y1) {
					var $x0 = x0 >>> 0,
					    $x1 = x1 >>> 0,
					    $y0 = y0 >>> 0;
					return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
				}
			});

			/***/
		},
		/* 272 */
		/***/function (module, exports, __webpack_require__) {

			// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', {
				imulh: function imulh(u, v) {
					var UINT16 = 0xffff,
					    $u = +u,
					    $v = +v,
					    u0 = $u & UINT16,
					    v0 = $v & UINT16,
					    u1 = $u >> 16,
					    v1 = $v >> 16,
					    t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
					return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
				}
			});

			/***/
		},
		/* 273 */
		/***/function (module, exports, __webpack_require__) {

			// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
			var $export = __webpack_require__(6);

			$export($export.S, 'Math', {
				umulh: function umulh(u, v) {
					var UINT16 = 0xffff,
					    $u = +u,
					    $v = +v,
					    u0 = $u & UINT16,
					    v0 = $v & UINT16,
					    u1 = $u >>> 16,
					    v1 = $v >>> 16,
					    t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
					return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
				}
			});

			/***/
		},
		/* 274 */
		/***/function (module, exports, __webpack_require__) {

			var metadata = __webpack_require__(275),
			    anObject = __webpack_require__(10),
			    toMetaKey = metadata.key,
			    ordinaryDefineOwnMetadata = metadata.set;

			metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
					ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
				} });

			/***/
		},
		/* 275 */
		/***/function (module, exports, __webpack_require__) {

			var Map = __webpack_require__(203),
			    $export = __webpack_require__(6),
			    shared = __webpack_require__(21)('metadata'),
			    store = shared.store || (shared.store = new (__webpack_require__(207))());

			var getOrCreateMetadataMap = function (target, targetKey, create) {
				var targetMetadata = store.get(target);
				if (!targetMetadata) {
					if (!create) return undefined;
					store.set(target, targetMetadata = new Map());
				}
				var keyMetadata = targetMetadata.get(targetKey);
				if (!keyMetadata) {
					if (!create) return undefined;
					targetMetadata.set(targetKey, keyMetadata = new Map());
				}return keyMetadata;
			};
			var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
				var metadataMap = getOrCreateMetadataMap(O, P, false);
				return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
			};
			var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
				var metadataMap = getOrCreateMetadataMap(O, P, false);
				return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
			};
			var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
				getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
			};
			var ordinaryOwnMetadataKeys = function (target, targetKey) {
				var metadataMap = getOrCreateMetadataMap(target, targetKey, false),
				    keys = [];
				if (metadataMap) metadataMap.forEach(function (_, key) {
					keys.push(key);
				});
				return keys;
			};
			var toMetaKey = function (it) {
				return it === undefined || typeof it == 'symbol' ? it : String(it);
			};
			var exp = function (O) {
				$export($export.S, 'Reflect', O);
			};

			module.exports = {
				store: store,
				map: getOrCreateMetadataMap,
				has: ordinaryHasOwnMetadata,
				get: ordinaryGetOwnMetadata,
				set: ordinaryDefineOwnMetadata,
				keys: ordinaryOwnMetadataKeys,
				key: toMetaKey,
				exp: exp
			};

			/***/
		},
		/* 276 */
		/***/function (module, exports, __webpack_require__) {

			var metadata = __webpack_require__(275),
			    anObject = __webpack_require__(10),
			    toMetaKey = metadata.key,
			    getOrCreateMetadataMap = metadata.map,
			    store = metadata.store;

			metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */) {
					var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]),
					    metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
					if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
					if (metadataMap.size) return true;
					var targetMetadata = store.get(target);
					targetMetadata['delete'](targetKey);
					return !!targetMetadata.size || store['delete'](target);
				} });

			/***/
		},
		/* 277 */
		/***/function (module, exports, __webpack_require__) {

			var metadata = __webpack_require__(275),
			    anObject = __webpack_require__(10),
			    getPrototypeOf = __webpack_require__(57),
			    ordinaryHasOwnMetadata = metadata.has,
			    ordinaryGetOwnMetadata = metadata.get,
			    toMetaKey = metadata.key;

			var ordinaryGetMetadata = function (MetadataKey, O, P) {
				var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
				if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
				var parent = getPrototypeOf(O);
				return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
			};

			metadata.exp({ getMetadata: function getMetadata(metadataKey, target /*, targetKey */) {
					return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
				} });

			/***/
		},
		/* 278 */
		/***/function (module, exports, __webpack_require__) {

			var Set = __webpack_require__(206),
			    from = __webpack_require__(266),
			    metadata = __webpack_require__(275),
			    anObject = __webpack_require__(10),
			    getPrototypeOf = __webpack_require__(57),
			    ordinaryOwnMetadataKeys = metadata.keys,
			    toMetaKey = metadata.key;

			var ordinaryMetadataKeys = function (O, P) {
				var oKeys = ordinaryOwnMetadataKeys(O, P),
				    parent = getPrototypeOf(O);
				if (parent === null) return oKeys;
				var pKeys = ordinaryMetadataKeys(parent, P);
				return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
			};

			metadata.exp({ getMetadataKeys: function getMetadataKeys(target /*, targetKey */) {
					return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
				} });

			/***/
		},
		/* 279 */
		/***/function (module, exports, __webpack_require__) {

			var metadata = __webpack_require__(275),
			    anObject = __webpack_require__(10),
			    ordinaryGetOwnMetadata = metadata.get,
			    toMetaKey = metadata.key;

			metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */) {
					return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
				} });

			/***/
		},
		/* 280 */
		/***/function (module, exports, __webpack_require__) {

			var metadata = __webpack_require__(275),
			    anObject = __webpack_require__(10),
			    ordinaryOwnMetadataKeys = metadata.keys,
			    toMetaKey = metadata.key;

			metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */) {
					return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
				} });

			/***/
		},
		/* 281 */
		/***/function (module, exports, __webpack_require__) {

			var metadata = __webpack_require__(275),
			    anObject = __webpack_require__(10),
			    getPrototypeOf = __webpack_require__(57),
			    ordinaryHasOwnMetadata = metadata.has,
			    toMetaKey = metadata.key;

			var ordinaryHasMetadata = function (MetadataKey, O, P) {
				var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
				if (hasOwn) return true;
				var parent = getPrototypeOf(O);
				return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
			};

			metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */) {
					return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
				} });

			/***/
		},
		/* 282 */
		/***/function (module, exports, __webpack_require__) {

			var metadata = __webpack_require__(275),
			    anObject = __webpack_require__(10),
			    ordinaryHasOwnMetadata = metadata.has,
			    toMetaKey = metadata.key;

			metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */) {
					return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
				} });

			/***/
		},
		/* 283 */
		/***/function (module, exports, __webpack_require__) {

			var metadata = __webpack_require__(275),
			    anObject = __webpack_require__(10),
			    aFunction = __webpack_require__(19),
			    toMetaKey = metadata.key,
			    ordinaryDefineOwnMetadata = metadata.set;

			metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
					return function decorator(target, targetKey) {
						ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
					};
				} });

			/***/
		},
		/* 284 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
			var $export = __webpack_require__(6),
			    microtask = __webpack_require__(201)(),
			    process = __webpack_require__(2).process,
			    isNode = __webpack_require__(32)(process) == 'process';

			$export($export.G, {
				asap: function asap(fn) {
					var domain = isNode && process.domain;
					microtask(domain ? domain.bind(fn) : fn);
				}
			});

			/***/
		},
		/* 285 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			// https://github.com/zenparsing/es-observable

			var $export = __webpack_require__(6),
			    global = __webpack_require__(2),
			    core = __webpack_require__(7),
			    microtask = __webpack_require__(201)(),
			    OBSERVABLE = __webpack_require__(23)('observable'),
			    aFunction = __webpack_require__(19),
			    anObject = __webpack_require__(10),
			    anInstance = __webpack_require__(197),
			    redefineAll = __webpack_require__(202),
			    hide = __webpack_require__(8),
			    forOf = __webpack_require__(198),
			    RETURN = forOf.RETURN;

			var getMethod = function (fn) {
				return fn == null ? undefined : aFunction(fn);
			};

			var cleanupSubscription = function (subscription) {
				var cleanup = subscription._c;
				if (cleanup) {
					subscription._c = undefined;
					cleanup();
				}
			};

			var subscriptionClosed = function (subscription) {
				return subscription._o === undefined;
			};

			var closeSubscription = function (subscription) {
				if (!subscriptionClosed(subscription)) {
					subscription._o = undefined;
					cleanupSubscription(subscription);
				}
			};

			var Subscription = function (observer, subscriber) {
				anObject(observer);
				this._c = undefined;
				this._o = observer;
				observer = new SubscriptionObserver(this);
				try {
					var cleanup = subscriber(observer),
					    subscription = cleanup;
					if (cleanup != null) {
						if (typeof cleanup.unsubscribe === 'function') cleanup = function () {
							subscription.unsubscribe();
						};else aFunction(cleanup);
						this._c = cleanup;
					}
				} catch (e) {
					observer.error(e);
					return;
				}if (subscriptionClosed(this)) cleanupSubscription(this);
			};

			Subscription.prototype = redefineAll({}, {
				unsubscribe: function unsubscribe() {
					closeSubscription(this);
				}
			});

			var SubscriptionObserver = function (subscription) {
				this._s = subscription;
			};

			SubscriptionObserver.prototype = redefineAll({}, {
				next: function next(value) {
					var subscription = this._s;
					if (!subscriptionClosed(subscription)) {
						var observer = subscription._o;
						try {
							var m = getMethod(observer.next);
							if (m) return m.call(observer, value);
						} catch (e) {
							try {
								closeSubscription(subscription);
							} finally {
								throw e;
							}
						}
					}
				},
				error: function error(value) {
					var subscription = this._s;
					if (subscriptionClosed(subscription)) throw value;
					var observer = subscription._o;
					subscription._o = undefined;
					try {
						var m = getMethod(observer.error);
						if (!m) throw value;
						value = m.call(observer, value);
					} catch (e) {
						try {
							cleanupSubscription(subscription);
						} finally {
							throw e;
						}
					}cleanupSubscription(subscription);
					return value;
				},
				complete: function complete(value) {
					var subscription = this._s;
					if (!subscriptionClosed(subscription)) {
						var observer = subscription._o;
						subscription._o = undefined;
						try {
							var m = getMethod(observer.complete);
							value = m ? m.call(observer, value) : undefined;
						} catch (e) {
							try {
								cleanupSubscription(subscription);
							} finally {
								throw e;
							}
						}cleanupSubscription(subscription);
						return value;
					}
				}
			});

			var $Observable = function Observable(subscriber) {
				anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
			};

			redefineAll($Observable.prototype, {
				subscribe: function subscribe(observer) {
					return new Subscription(observer, this._f);
				},
				forEach: function forEach(fn) {
					var that = this;
					return new (core.Promise || global.Promise)(function (resolve, reject) {
						aFunction(fn);
						var subscription = that.subscribe({
							next: function (value) {
								try {
									return fn(value);
								} catch (e) {
									reject(e);
									subscription.unsubscribe();
								}
							},
							error: reject,
							complete: resolve
						});
					});
				}
			});

			redefineAll($Observable, {
				from: function from(x) {
					var C = typeof this === 'function' ? this : $Observable;
					var method = getMethod(anObject(x)[OBSERVABLE]);
					if (method) {
						var observable = anObject(method.call(x));
						return observable.constructor === C ? observable : new C(function (observer) {
							return observable.subscribe(observer);
						});
					}
					return new C(function (observer) {
						var done = false;
						microtask(function () {
							if (!done) {
								try {
									if (forOf(x, false, function (it) {
										observer.next(it);
										if (done) return RETURN;
									}) === RETURN) return;
								} catch (e) {
									if (done) throw e;
									observer.error(e);
									return;
								}observer.complete();
							}
						});
						return function () {
							done = true;
						};
					});
				},
				of: function of() {
					for (var i = 0, l = arguments.length, items = Array(l); i < l;) items[i] = arguments[i++];
					return new (typeof this === 'function' ? this : $Observable)(function (observer) {
						var done = false;
						microtask(function () {
							if (!done) {
								for (var i = 0; i < items.length; ++i) {
									observer.next(items[i]);
									if (done) return;
								}observer.complete();
							}
						});
						return function () {
							done = true;
						};
					});
				}
			});

			hide($Observable.prototype, OBSERVABLE, function () {
				return this;
			});

			$export($export.G, { Observable: $Observable });

			__webpack_require__(186)('Observable');

			/***/
		},
		/* 286 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    $task = __webpack_require__(200);
			$export($export.G + $export.B, {
				setImmediate: $task.set,
				clearImmediate: $task.clear
			});

			/***/
		},
		/* 287 */
		/***/function (module, exports, __webpack_require__) {

			var $iterators = __webpack_require__(183),
			    redefine = __webpack_require__(16),
			    global = __webpack_require__(2),
			    hide = __webpack_require__(8),
			    Iterators = __webpack_require__(135),
			    wks = __webpack_require__(23),
			    ITERATOR = wks('iterator'),
			    TO_STRING_TAG = wks('toStringTag'),
			    ArrayValues = Iterators.Array;

			for (var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++) {
				var NAME = collections[i],
				    Collection = global[NAME],
				    proto = Collection && Collection.prototype,
				    key;
				if (proto) {
					if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
					if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
					Iterators[NAME] = ArrayValues;
					for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
				}
			}

			/***/
		},
		/* 288 */
		/***/function (module, exports, __webpack_require__) {

			// ie9- setTimeout & setInterval additional parameters fix
			var global = __webpack_require__(2),
			    $export = __webpack_require__(6),
			    invoke = __webpack_require__(76),
			    partial = __webpack_require__(289),
			    navigator = global.navigator,
			    MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
			var wrap = function (set) {
				return MSIE ? function (fn, time /*, ...args */) {
					return set(invoke(partial, [].slice.call(arguments, 2), typeof fn == 'function' ? fn : Function(fn)), time);
				} : set;
			};
			$export($export.G + $export.B + $export.F * MSIE, {
				setTimeout: wrap(global.setTimeout),
				setInterval: wrap(global.setInterval)
			});

			/***/
		},
		/* 289 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var path = __webpack_require__(290),
			    invoke = __webpack_require__(76),
			    aFunction = __webpack_require__(19);
			module.exports = function () /* ...pargs */{
				var fn = aFunction(this),
				    length = arguments.length,
				    pargs = Array(length),
				    i = 0,
				    _ = path._,
				    holder = false;
				while (length > i) if ((pargs[i] = arguments[i++]) === _) holder = true;
				return function () /* ...args */{
					var that = this,
					    aLen = arguments.length,
					    j = 0,
					    k = 0,
					    args;
					if (!holder && !aLen) return invoke(fn, pargs, that);
					args = pargs.slice();
					if (holder) for (; length > j; j++) if (args[j] === _) args[j] = arguments[k++];
					while (aLen > k) args.push(arguments[k++]);
					return invoke(fn, args, that);
				};
			};

			/***/
		},
		/* 290 */
		/***/function (module, exports, __webpack_require__) {

			module.exports = __webpack_require__(2);

			/***/
		},
		/* 291 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var ctx = __webpack_require__(18),
			    $export = __webpack_require__(6),
			    createDesc = __webpack_require__(15),
			    assign = __webpack_require__(67),
			    create = __webpack_require__(44),
			    getPrototypeOf = __webpack_require__(57),
			    getKeys = __webpack_require__(28),
			    dP = __webpack_require__(9),
			    keyOf = __webpack_require__(27),
			    aFunction = __webpack_require__(19),
			    forOf = __webpack_require__(198),
			    isIterable = __webpack_require__(292),
			    $iterCreate = __webpack_require__(136),
			    step = __webpack_require__(184),
			    isObject = __webpack_require__(11),
			    toIObject = __webpack_require__(30),
			    DESCRIPTORS = __webpack_require__(4),
			    has = __webpack_require__(3);

			// 0 -> Dict.forEach
			// 1 -> Dict.map
			// 2 -> Dict.filter
			// 3 -> Dict.some
			// 4 -> Dict.every
			// 5 -> Dict.find
			// 6 -> Dict.findKey
			// 7 -> Dict.mapPairs
			var createDictMethod = function (TYPE) {
				var IS_MAP = TYPE == 1,
				    IS_EVERY = TYPE == 4;
				return function (object, callbackfn, that /* = undefined */) {
					var f = ctx(callbackfn, that, 3),
					    O = toIObject(object),
					    result = IS_MAP || TYPE == 7 || TYPE == 2 ? new (typeof this == 'function' ? this : Dict)() : undefined,
					    key,
					    val,
					    res;
					for (key in O) if (has(O, key)) {
						val = O[key];
						res = f(val, key, object);
						if (TYPE) {
							if (IS_MAP) result[key] = res; // map
							else if (res) switch (TYPE) {
									case 2:
										result[key] = val;break; // filter
									case 3:
										return true; // some
									case 5:
										return val; // find
									case 6:
										return key; // findKey
									case 7:
										result[res[0]] = res[1]; // mapPairs
								} else if (IS_EVERY) return false; // every
						}
					}
					return TYPE == 3 || IS_EVERY ? IS_EVERY : result;
				};
			};
			var findKey = createDictMethod(6);

			var createDictIter = function (kind) {
				return function (it) {
					return new DictIterator(it, kind);
				};
			};
			var DictIterator = function (iterated, kind) {
				this._t = toIObject(iterated); // target
				this._a = getKeys(iterated); // keys
				this._i = 0; // next index
				this._k = kind; // kind
			};
			$iterCreate(DictIterator, 'Dict', function () {
				var that = this,
				    O = that._t,
				    keys = that._a,
				    kind = that._k,
				    key;
				do {
					if (that._i >= keys.length) {
						that._t = undefined;
						return step(1);
					}
				} while (!has(O, key = keys[that._i++]));
				if (kind == 'keys') return step(0, key);
				if (kind == 'values') return step(0, O[key]);
				return step(0, [key, O[key]]);
			});

			function Dict(iterable) {
				var dict = create(null);
				if (iterable != undefined) {
					if (isIterable(iterable)) {
						forOf(iterable, true, function (key, value) {
							dict[key] = value;
						});
					} else assign(dict, iterable);
				}
				return dict;
			}
			Dict.prototype = null;

			function reduce(object, mapfn, init) {
				aFunction(mapfn);
				var O = toIObject(object),
				    keys = getKeys(O),
				    length = keys.length,
				    i = 0,
				    memo,
				    key;
				if (arguments.length < 3) {
					if (!length) throw TypeError('Reduce of empty object with no initial value');
					memo = O[keys[i++]];
				} else memo = Object(init);
				while (length > i) if (has(O, key = keys[i++])) {
					memo = mapfn(memo, O[key], key, object);
				}
				return memo;
			}

			function includes(object, el) {
				return (el == el ? keyOf(object, el) : findKey(object, function (it) {
					return it != it;
				})) !== undefined;
			}

			function get(object, key) {
				if (has(object, key)) return object[key];
			}
			function set(object, key, value) {
				if (DESCRIPTORS && key in Object) dP.f(object, key, createDesc(0, value));else object[key] = value;
				return object;
			}

			function isDict(it) {
				return isObject(it) && getPrototypeOf(it) === Dict.prototype;
			}

			$export($export.G + $export.F, { Dict: Dict });

			$export($export.S, 'Dict', {
				keys: createDictIter('keys'),
				values: createDictIter('values'),
				entries: createDictIter('entries'),
				forEach: createDictMethod(0),
				map: createDictMethod(1),
				filter: createDictMethod(2),
				some: createDictMethod(3),
				every: createDictMethod(4),
				find: createDictMethod(5),
				findKey: findKey,
				mapPairs: createDictMethod(7),
				reduce: reduce,
				keyOf: keyOf,
				includes: includes,
				has: has,
				get: get,
				set: set,
				isDict: isDict
			});

			/***/
		},
		/* 292 */
		/***/function (module, exports, __webpack_require__) {

			var classof = __webpack_require__(73),
			    ITERATOR = __webpack_require__(23)('iterator'),
			    Iterators = __webpack_require__(135);
			module.exports = __webpack_require__(7).isIterable = function (it) {
				var O = Object(it);
				return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
			};

			/***/
		},
		/* 293 */
		/***/function (module, exports, __webpack_require__) {

			var anObject = __webpack_require__(10),
			    get = __webpack_require__(156);
			module.exports = __webpack_require__(7).getIterator = function (it) {
				var iterFn = get(it);
				if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
				return anObject(iterFn.call(it));
			};

			/***/
		},
		/* 294 */
		/***/function (module, exports, __webpack_require__) {

			var global = __webpack_require__(2),
			    core = __webpack_require__(7),
			    $export = __webpack_require__(6),
			    partial = __webpack_require__(289);
			// https://esdiscuss.org/topic/promise-returning-delay-function
			$export($export.G + $export.F, {
				delay: function delay(time) {
					return new (core.Promise || global.Promise)(function (resolve) {
						setTimeout(partial.call(resolve, true), time);
					});
				}
			});

			/***/
		},
		/* 295 */
		/***/function (module, exports, __webpack_require__) {

			var path = __webpack_require__(290),
			    $export = __webpack_require__(6);

			// Placeholder
			__webpack_require__(7)._ = path._ = path._ || {};

			$export($export.P + $export.F, 'Function', { part: __webpack_require__(289) });

			/***/
		},
		/* 296 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6);

			$export($export.S + $export.F, 'Object', { isObject: __webpack_require__(11) });

			/***/
		},
		/* 297 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6);

			$export($export.S + $export.F, 'Object', { classof: __webpack_require__(73) });

			/***/
		},
		/* 298 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    define = __webpack_require__(299);

			$export($export.S + $export.F, 'Object', { define: define });

			/***/
		},
		/* 299 */
		/***/function (module, exports, __webpack_require__) {

			var dP = __webpack_require__(9),
			    gOPD = __webpack_require__(49),
			    ownKeys = __webpack_require__(221),
			    toIObject = __webpack_require__(30);

			module.exports = function define(target, mixin) {
				var keys = ownKeys(toIObject(mixin)),
				    length = keys.length,
				    i = 0,
				    key;
				while (length > i) dP.f(target, key = keys[i++], gOPD.f(mixin, key));
				return target;
			};

			/***/
		},
		/* 300 */
		/***/function (module, exports, __webpack_require__) {

			var $export = __webpack_require__(6),
			    define = __webpack_require__(299),
			    create = __webpack_require__(44);

			$export($export.S + $export.F, 'Object', {
				make: function (proto, mixin) {
					return define(create(proto), mixin);
				}
			});

			/***/
		},
		/* 301 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			__webpack_require__(134)(Number, 'Number', function (iterated) {
				this._l = +iterated;
				this._i = 0;
			}, function () {
				var i = this._i++,
				    done = !(i < this._l);
				return { done: done, value: done ? undefined : i };
			});

			/***/
		},
		/* 302 */
		/***/function (module, exports, __webpack_require__) {

			// https://github.com/benjamingr/RexExp.escape
			var $export = __webpack_require__(6),
			    $re = __webpack_require__(303)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

			$export($export.S, 'RegExp', { escape: function escape(it) {
					return $re(it);
				} });

			/***/
		},
		/* 303 */
		/***/function (module, exports) {

			module.exports = function (regExp, replace) {
				var replacer = replace === Object(replace) ? function (part) {
					return replace[part];
				} : replace;
				return function (it) {
					return String(it).replace(regExp, replacer);
				};
			};

			/***/
		},
		/* 304 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6);
			var $re = __webpack_require__(303)(/[&<>"']/g, {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				'"': '&quot;',
				"'": '&apos;'
			});

			$export($export.P + $export.F, 'String', { escapeHTML: function escapeHTML() {
					return $re(this);
				} });

			/***/
		},
		/* 305 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			var $export = __webpack_require__(6);
			var $re = __webpack_require__(303)(/&(?:amp|lt|gt|quot|apos);/g, {
				'&amp;': '&',
				'&lt;': '<',
				'&gt;': '>',
				'&quot;': '"',
				'&apos;': "'"
			});

			$export($export.P + $export.F, 'String', { unescapeHTML: function unescapeHTML() {
					return $re(this);
				} });

			/***/
		}
		/******/]);
		// CommonJS export
		if (typeof module != 'undefined' && module.exports) module.exports = __e;
		// RequireJS export
		else if (typeof undefined == 'function' && define.amd) define(function () {
				return __e;
			});
			// Export to global object
			else __g.core = __e;
	}(1, 1);
});
System.register("npm:systemjs-plugin-babel@0.0.17/babel-helpers/asyncToGenerator.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function (fn) {
        return function () {
          var gen = fn.apply(this, arguments);
          return new Promise(function (resolve, reject) {
            function step(key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }

              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then(function (value) {
                  step("next", value);
                }, function (err) {
                  step("throw", err);
                });
              }
            }

            return step("next");
          });
        };
      });
    }
  };
});
System.register("npm:systemjs-plugin-babel@0.0.17/babel-helpers/defineProperty.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function (obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      });
    }
  };
});
System.register("npm:systemjs-plugin-babel@0.0.17/babel-helpers/extends.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      });
    }
  };
});
System.register("npm:systemjs-plugin-babel@0.0.17/babel-helpers/slicedToArray.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }());
    }
  };
});
System.registerDynamic("npm:systemjs-plugin-babel@0.0.17.json", [], true, function() {
  return {
    "main": "plugin-babel.js",
    "map": {
      "systemjs-babel-build": {
        "browser": "./systemjs-babel-browser.js",
        "default": "./systemjs-babel-browser.js"
      }
    },
    "meta": {
      "./plugin-babel.js": {
        "format": "cjs"
      }
    }
  };
});

System.register("npm:systemjs-plugin-babel@0.0.17/regenerator-runtime.js", [], function (_export, _context) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function (module) {
        /**
         * Copyright (c) 2014, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
         * additional grant of patent rights can be found in the PATENTS file in
         * the same directory.
         */

        !function (global) {
          "use strict";

          var hasOwn = Object.prototype.hasOwnProperty;
          var undefined; // More compressible than void 0.
          var $Symbol = typeof Symbol === "function" ? Symbol : {};
          var iteratorSymbol = $Symbol.iterator || "@@iterator";
          var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

          var inModule = typeof module === "object";
          var runtime = global.regeneratorRuntime;
          if (runtime) {
            if (inModule) {
              // If regeneratorRuntime is defined globally and we're in a module,
              // make the exports object identical to regeneratorRuntime.
              module.exports = runtime;
            }
            // Don't bother evaluating the rest of this file if the runtime was
            // already defined globally.
            return;
          }

          // Define the runtime globally (as expected by generated code) as either
          // module.exports (if we're in a module) or a new, empty object.
          runtime = global.regeneratorRuntime = inModule ? module.exports : {};

          function wrap(innerFn, outerFn, self, tryLocsList) {
            // If outerFn provided, then outerFn.prototype instanceof Generator.
            var generator = Object.create((outerFn || Generator).prototype);
            var context = new Context(tryLocsList || []);

            // The ._invoke method unifies the implementations of the .next,
            // .throw, and .return methods.
            generator._invoke = makeInvokeMethod(innerFn, self, context);

            return generator;
          }
          runtime.wrap = wrap;

          // Try/catch helper to minimize deoptimizations. Returns a completion
          // record like context.tryEntries[i].completion. This interface could
          // have been (and was previously) designed to take a closure to be
          // invoked without arguments, but in all the cases we care about we
          // already have an existing method we want to call, so there's no need
          // to create a new function object. We can even get away with assuming
          // the method takes exactly one argument, since that happens to be true
          // in every case, so we don't have to touch the arguments object. The
          // only additional allocation required is the completion record, which
          // has a stable shape and so hopefully should be cheap to allocate.
          function tryCatch(fn, obj, arg) {
            try {
              return { type: "normal", arg: fn.call(obj, arg) };
            } catch (err) {
              return { type: "throw", arg: err };
            }
          }

          var GenStateSuspendedStart = "suspendedStart";
          var GenStateSuspendedYield = "suspendedYield";
          var GenStateExecuting = "executing";
          var GenStateCompleted = "completed";

          // Returning this object from the innerFn has the same effect as
          // breaking out of the dispatch switch statement.
          var ContinueSentinel = {};

          // Dummy constructor functions that we use as the .constructor and
          // .constructor.prototype properties for functions that return Generator
          // objects. For full spec compliance, you may wish to configure your
          // minifier not to mangle the names of these two functions.
          function Generator() {}
          function GeneratorFunction() {}
          function GeneratorFunctionPrototype() {}

          var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
          GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
          GeneratorFunctionPrototype.constructor = GeneratorFunction;
          GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

          // Helper for defining the .next, .throw, and .return methods of the
          // Iterator interface in terms of a single ._invoke method.
          function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function (method) {
              prototype[method] = function (arg) {
                return this._invoke(method, arg);
              };
            });
          }

          runtime.isGeneratorFunction = function (genFun) {
            var ctor = typeof genFun === "function" && genFun.constructor;
            return ctor ? ctor === GeneratorFunction ||
            // For the native GeneratorFunction constructor, the best we can
            // do is to check its .name property.
            (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
          };

          runtime.mark = function (genFun) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            } else {
              genFun.__proto__ = GeneratorFunctionPrototype;
              if (!(toStringTagSymbol in genFun)) {
                genFun[toStringTagSymbol] = "GeneratorFunction";
              }
            }
            genFun.prototype = Object.create(Gp);
            return genFun;
          };

          // Within the body of any async function, `await x` is transformed to
          // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
          // `value instanceof AwaitArgument` to determine if the yielded value is
          // meant to be awaited. Some may consider the name of this method too
          // cutesy, but they are curmudgeons.
          runtime.awrap = function (arg) {
            return new AwaitArgument(arg);
          };

          function AwaitArgument(arg) {
            this.arg = arg;
          }

          function AsyncIterator(generator) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);
              if (record.type === "throw") {
                reject(record.arg);
              } else {
                var result = record.arg;
                var value = result.value;
                if (value instanceof AwaitArgument) {
                  return Promise.resolve(value.arg).then(function (value) {
                    invoke("next", value, resolve, reject);
                  }, function (err) {
                    invoke("throw", err, resolve, reject);
                  });
                }

                return Promise.resolve(value).then(function (unwrapped) {
                  // When a yielded Promise is resolved, its final value becomes
                  // the .value of the Promise<{value,done}> result for the
                  // current iteration. If the Promise is rejected, however, the
                  // result for this iteration will be rejected with the same
                  // reason. Note that rejections of yielded Promises are not
                  // thrown back into the generator function, as is the case
                  // when an awaited Promise is rejected. This difference in
                  // behavior between yield and await is important, because it
                  // allows the consumer to decide what to do with the yielded
                  // rejection (swallow it and continue, manually .throw it back
                  // into the generator, abandon iteration, whatever). With
                  // await, by contrast, there is no opportunity to examine the
                  // rejection reason outside the generator function, so the
                  // only option is to throw it from the await expression, and
                  // let the generator function handle the exception.
                  result.value = unwrapped;
                  resolve(result);
                }, reject);
              }
            }

            if (typeof process === "object" && process.domain) {
              invoke = process.domain.bind(invoke);
            }

            var previousPromise;

            function enqueue(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new Promise(function (resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }

              return previousPromise =
              // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
              // Avoid propagating failures to Promises returned by later
              // invocations of the iterator.
              callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }

            // Define the unified helper method that is used to implement .next,
            // .throw, and .return (see defineIteratorMethods).
            this._invoke = enqueue;
          }

          defineIteratorMethods(AsyncIterator.prototype);

          // Note that simple async functions are implemented on top of
          // AsyncIterator objects; they just return a Promise for the value of
          // the final result produced by the iterator.
          runtime.async = function (innerFn, outerFn, self, tryLocsList) {
            var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

            return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
            : iter.next().then(function (result) {
              return result.done ? result.value : iter.next();
            });
          };

          function makeInvokeMethod(innerFn, self, context) {
            var state = GenStateSuspendedStart;

            return function invoke(method, arg) {
              if (state === GenStateExecuting) {
                throw new Error("Generator is already running");
              }

              if (state === GenStateCompleted) {
                if (method === "throw") {
                  throw arg;
                }

                // Be forgiving, per 25.3.3.3.3 of the spec:
                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                return doneResult();
              }

              while (true) {
                var delegate = context.delegate;
                if (delegate) {
                  if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
                    // A return or throw (when the delegate iterator has no throw
                    // method) always terminates the yield* loop.
                    context.delegate = null;

                    // If the delegate iterator has a return method, give it a
                    // chance to clean up.
                    var returnMethod = delegate.iterator["return"];
                    if (returnMethod) {
                      var record = tryCatch(returnMethod, delegate.iterator, arg);
                      if (record.type === "throw") {
                        // If the return method threw an exception, let that
                        // exception prevail over the original return or throw.
                        method = "throw";
                        arg = record.arg;
                        continue;
                      }
                    }

                    if (method === "return") {
                      // Continue with the outer return, now that the delegate
                      // iterator has been terminated.
                      continue;
                    }
                  }

                  var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

                  if (record.type === "throw") {
                    context.delegate = null;

                    // Like returning generator.throw(uncaught), but without the
                    // overhead of an extra function call.
                    method = "throw";
                    arg = record.arg;
                    continue;
                  }

                  // Delegate generator ran and handled its own exceptions so
                  // regardless of what the method was, we continue as if it is
                  // "next" with an undefined arg.
                  method = "next";
                  arg = undefined;

                  var info = record.arg;
                  if (info.done) {
                    context[delegate.resultName] = info.value;
                    context.next = delegate.nextLoc;
                  } else {
                    state = GenStateSuspendedYield;
                    return info;
                  }

                  context.delegate = null;
                }

                if (method === "next") {
                  // Setting context._sent for legacy support of Babel's
                  // function.sent implementation.
                  context.sent = context._sent = arg;
                } else if (method === "throw") {
                  if (state === GenStateSuspendedStart) {
                    state = GenStateCompleted;
                    throw arg;
                  }

                  if (context.dispatchException(arg)) {
                    // If the dispatched exception was caught by a catch block,
                    // then let that catch block handle the exception normally.
                    method = "next";
                    arg = undefined;
                  }
                } else if (method === "return") {
                  context.abrupt("return", arg);
                }

                state = GenStateExecuting;

                var record = tryCatch(innerFn, self, context);
                if (record.type === "normal") {
                  // If an exception is thrown from innerFn, we leave state ===
                  // GenStateExecuting and loop back for another invocation.
                  state = context.done ? GenStateCompleted : GenStateSuspendedYield;

                  var info = {
                    value: record.arg,
                    done: context.done
                  };

                  if (record.arg === ContinueSentinel) {
                    if (context.delegate && method === "next") {
                      // Deliberately forget the last sent value so that we don't
                      // accidentally pass it on to the delegate.
                      arg = undefined;
                    }
                  } else {
                    return info;
                  }
                } else if (record.type === "throw") {
                  state = GenStateCompleted;
                  // Dispatch the exception by looping back around to the
                  // context.dispatchException(arg) call above.
                  method = "throw";
                  arg = record.arg;
                }
              }
            };
          }

          // Define Generator.prototype.{next,throw,return} in terms of the
          // unified ._invoke helper method.
          defineIteratorMethods(Gp);

          Gp[iteratorSymbol] = function () {
            return this;
          };

          Gp[toStringTagSymbol] = "Generator";

          Gp.toString = function () {
            return "[object Generator]";
          };

          function pushTryEntry(locs) {
            var entry = { tryLoc: locs[0] };

            if (1 in locs) {
              entry.catchLoc = locs[1];
            }

            if (2 in locs) {
              entry.finallyLoc = locs[2];
              entry.afterLoc = locs[3];
            }

            this.tryEntries.push(entry);
          }

          function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal";
            delete record.arg;
            entry.completion = record;
          }

          function Context(tryLocsList) {
            // The root entry object (effectively a try statement without a catch
            // or a finally block) gives us a place to store values thrown from
            // locations where there is no enclosing try statement.
            this.tryEntries = [{ tryLoc: "root" }];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
          }

          runtime.keys = function (object) {
            var keys = [];
            for (var key in object) {
              keys.push(key);
            }
            keys.reverse();

            // Rather than returning an object with a next method, we keep
            // things simple and return the next function itself.
            return function next() {
              while (keys.length) {
                var key = keys.pop();
                if (key in object) {
                  next.value = key;
                  next.done = false;
                  return next;
                }
              }

              // To avoid creating an additional object, we just hang the .value
              // and .done properties off the next function object itself. This
              // also ensures that the minifier will not anonymize the function.
              next.done = true;
              return next;
            };
          };

          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod) {
                return iteratorMethod.call(iterable);
              }

              if (typeof iterable.next === "function") {
                return iterable;
              }

              if (!isNaN(iterable.length)) {
                var i = -1,
                    next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }

                  next.value = undefined;
                  next.done = true;

                  return next;
                };

                return next.next = next;
              }
            }

            // Return an iterator with no values.
            return { next: doneResult };
          }
          runtime.values = values;

          function doneResult() {
            return { value: undefined, done: true };
          }

          Context.prototype = {
            constructor: Context,

            reset: function reset(skipTempReset) {
              this.prev = 0;
              this.next = 0;
              // Resetting context._sent for legacy support of Babel's
              // function.sent implementation.
              this.sent = this._sent = undefined;
              this.done = false;
              this.delegate = null;

              this.tryEntries.forEach(resetTryEntry);

              if (!skipTempReset) {
                for (var name in this) {
                  // Not sure about the optimal order of these conditions:
                  if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                    this[name] = undefined;
                  }
                }
              }
            },

            stop: function stop() {
              this.done = true;

              var rootEntry = this.tryEntries[0];
              var rootRecord = rootEntry.completion;
              if (rootRecord.type === "throw") {
                throw rootRecord.arg;
              }

              return this.rval;
            },

            dispatchException: function dispatchException(exception) {
              if (this.done) {
                throw exception;
              }

              var context = this;
              function handle(loc, caught) {
                record.type = "throw";
                record.arg = exception;
                context.next = loc;
                return !!caught;
              }

              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                var record = entry.completion;

                if (entry.tryLoc === "root") {
                  // Exception thrown outside of any try block that could handle
                  // it, so set the completion value of the entire function to
                  // throw the exception.
                  return handle("end");
                }

                if (entry.tryLoc <= this.prev) {
                  var hasCatch = hasOwn.call(entry, "catchLoc");
                  var hasFinally = hasOwn.call(entry, "finallyLoc");

                  if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    } else if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else if (hasCatch) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    }
                  } else if (hasFinally) {
                    if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else {
                    throw new Error("try statement without catch or finally");
                  }
                }
              }
            },

            abrupt: function abrupt(type, arg) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                  var finallyEntry = entry;
                  break;
                }
              }

              if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                // Ignore the finally entry if control is not jumping to a
                // location outside the try/catch block.
                finallyEntry = null;
              }

              var record = finallyEntry ? finallyEntry.completion : {};
              record.type = type;
              record.arg = arg;

              if (finallyEntry) {
                this.next = finallyEntry.finallyLoc;
              } else {
                this.complete(record);
              }

              return ContinueSentinel;
            },

            complete: function complete(record, afterLoc) {
              if (record.type === "throw") {
                throw record.arg;
              }

              if (record.type === "break" || record.type === "continue") {
                this.next = record.arg;
              } else if (record.type === "return") {
                this.rval = record.arg;
                this.next = "end";
              } else if (record.type === "normal" && afterLoc) {
                this.next = afterLoc;
              }
            },

            finish: function finish(finallyLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) {
                  this.complete(entry.completion, entry.afterLoc);
                  resetTryEntry(entry);
                  return ContinueSentinel;
                }
              }
            },

            "catch": function _catch(tryLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                  var record = entry.completion;
                  if (record.type === "throw") {
                    var thrown = record.arg;
                    resetTryEntry(entry);
                  }
                  return thrown;
                }
              }

              // The context.catch method must only be called with a location
              // argument that corresponds to a known catch block.
              throw new Error("illegal catch attempt");
            },

            delegateYield: function delegateYield(iterable, resultName, nextLoc) {
              this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
              };

              return ContinueSentinel;
            }
          };
        }(
        // Among the various tricks for obtaining a reference to the global
        // object, this seems to be the most reliable technique that does not
        // use indirect eval (which violates Content Security Policy).
        typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this);
        return module.exports;
      }({ exports: {} }));
    }
  };
});
System.registerDynamic("npm:tslib@1.6.1.json", [], true, function() {
  return {
    "main": "tslib.es6.js",
    "format": "esm",
    "meta": {
      "tslib.js": {
        "esModule": true
      }
    }
  };
});

System.register("npm:tslib@1.6.1/tslib.es6.js", [], function (_export, _context) {
    "use strict";

    var extendStatics, __assign;

    function __extends(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    _export("__extends", __extends);

    function __rest(s, e) {
        var t = {};
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
        }return t;
    }

    _export("__rest", __rest);

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
            if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        }return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    _export("__decorate", __decorate);

    function __param(paramIndex, decorator) {
        return function (target, key) {
            decorator(target, key, paramIndex);
        };
    }

    _export("__param", __param);

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    _export("__metadata", __metadata);

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator.throw(value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : new P(function (resolve) {
                    resolve(result.value);
                }).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    _export("__awaiter", __awaiter);

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function sent() {
                if (t[0] & 1) throw t[1];return t[1];
            }, trys: [], ops: [] },
            f,
            y,
            t,
            g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
            return this;
        }), g;
        function verb(n) {
            return function (v) {
                return step([n, v]);
            };
        }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) {
                try {
                    if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                    if (y = 0, t) op = [0, t.value];
                    switch (op[0]) {
                        case 0:case 1:
                            t = op;break;
                        case 4:
                            _.label++;return { value: op[1], done: false };
                        case 5:
                            _.label++;y = op[1];op = [0];continue;
                        case 7:
                            op = _.ops.pop();_.trys.pop();continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;continue;
                            }
                            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                _.label = op[1];break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];t = op;break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];_.ops.push(op);break;
                            }
                            if (t[2]) _.ops.pop();
                            _.trys.pop();continue;
                    }
                    op = body.call(thisArg, _);
                } catch (e) {
                    op = [6, e];y = 0;
                } finally {
                    f = t = 0;
                }
            }if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    _export("__generator", __generator);

    function __exportStar(m, exports) {
        for (var p in m) {
            if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
    }

    _export("__exportStar", __exportStar);

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator],
            i = 0;
        if (m) return m.call(o);
        return {
            next: function next() {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    _export("__values", __values);

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o),
            r,
            ar = [],
            e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
                ar.push(r.value);
            }
        } catch (error) {
            e = { error: error };
        } finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            } finally {
                if (e) throw e.error;
            }
        }
        return ar;
    }
    _export("__read", __read);

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++) {
            ar = ar.concat(__read(arguments[i]));
        }return ar;
    }
    _export("__spread", __spread);

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []),
            q = [],
            c,
            i;
        return i = { next: verb("next"), "throw": verb("throw"), "return": verb("return") }, i[Symbol.asyncIterator] = function () {
            return this;
        }, i;
        function verb(n) {
            return function (v) {
                return new Promise(function (a, b) {
                    q.push([n, v, a, b]), next();
                });
            };
        }
        function next() {
            if (!c && q.length) resume((c = q.shift())[0], c[1]);
        }
        function resume(n, v) {
            try {
                step(g[n](v));
            } catch (e) {
                settle(c[3], e);
            }
        }
        function step(r) {
            r.done ? settle(c[2], r) : Promise.resolve(r.value[1]).then(r.value[0] === "yield" ? send : fulfill, reject);
        }
        function send(value) {
            settle(c[2], { value: value, done: false });
        }
        function fulfill(value) {
            resume("next", value);
        }
        function reject(value) {
            resume("throw", value);
        }
        function settle(f, v) {
            c = void 0, f(v), next();
        }
    }
    _export("__asyncGenerator", __asyncGenerator);

    function __asyncDelegator(o) {
        var i = { next: verb("next"), "throw": verb("throw", function (e) {
                throw e;
            }), "return": verb("return", function (v) {
                return { value: v, done: true };
            }) },
            p;
        return o = __asyncValues(o), i[Symbol.iterator] = function () {
            return this;
        }, i;
        function verb(n, f) {
            return function (v) {
                return v = p && n === "throw" ? f(v) : p && v.done ? v : { value: p ? ["yield", v.value] : ["await", (o[n] || f).call(o, v)], done: false }, p = !p, v;
            };
        }
    }
    _export("__asyncDelegator", __asyncDelegator);

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    }
    _export("__asyncValues", __asyncValues);

    return {
        setters: [],
        execute: function () {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                d.__proto__ = b;
            } || function (d, b) {
                for (var p in b) {
                    if (b.hasOwnProperty(p)) d[p] = b[p];
                }
            };

            _export("__assign", __assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) {
                        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                    }
                }
                return t;
            });

            _export("__assign", __assign);

            ;

            ;

            ;

            ;

            ;

            ;
        }
    };
});
//# sourceMappingURL=dependencies.js.map